'use strict';
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) =>
  key in obj
    ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value })
    : (obj[key] = value);
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) =>
  function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === 'object') || typeof from === 'function') {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, 'default', { value: mod, enumerable: true }) : target,
    mod
  )
);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj)) throw TypeError('Cannot ' + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, 'read from private field');
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj)) throw TypeError('Cannot add the same private member more than once');
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, 'write to private field');
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, 'access private method');
  return method;
};

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/json/builder.js
var require_builder = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/json/builder.js'(exports, module2) {
    var util = require_util();
    function JsonBuilder() {}
    JsonBuilder.prototype.build = function (value, shape) {
      return JSON.stringify(translate(value, shape));
    };
    function translate(value, shape) {
      if (!shape || value === void 0 || value === null) return void 0;
      switch (shape.type) {
        case 'structure':
          return translateStructure(value, shape);
        case 'map':
          return translateMap(value, shape);
        case 'list':
          return translateList(value, shape);
        default:
          return translateScalar(value, shape);
      }
    }
    function translateStructure(structure, shape) {
      if (shape.isDocument) {
        return structure;
      }
      var struct = {};
      util.each(structure, function (name, value) {
        var memberShape = shape.members[name];
        if (memberShape) {
          if (memberShape.location !== 'body') return;
          var locationName = memberShape.isLocationName ? memberShape.name : name;
          var result = translate(value, memberShape);
          if (result !== void 0) struct[locationName] = result;
        }
      });
      return struct;
    }
    function translateList(list, shape) {
      var out = [];
      util.arrayEach(list, function (value) {
        var result = translate(value, shape.member);
        if (result !== void 0) out.push(result);
      });
      return out;
    }
    function translateMap(map, shape) {
      var out = {};
      util.each(map, function (key, value) {
        var result = translate(value, shape.value);
        if (result !== void 0) out[key] = result;
      });
      return out;
    }
    function translateScalar(value, shape) {
      return shape.toWireFormat(value);
    }
    module2.exports = JsonBuilder;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/json/parser.js
var require_parser = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/json/parser.js'(exports, module2) {
    var util = require_util();
    function JsonParser() {}
    JsonParser.prototype.parse = function (value, shape) {
      return translate(JSON.parse(value), shape);
    };
    function translate(value, shape) {
      if (!shape || value === void 0) return void 0;
      switch (shape.type) {
        case 'structure':
          return translateStructure(value, shape);
        case 'map':
          return translateMap(value, shape);
        case 'list':
          return translateList(value, shape);
        default:
          return translateScalar(value, shape);
      }
    }
    function translateStructure(structure, shape) {
      if (structure == null) return void 0;
      if (shape.isDocument) return structure;
      var struct = {};
      var shapeMembers = shape.members;
      util.each(shapeMembers, function (name, memberShape) {
        var locationName = memberShape.isLocationName ? memberShape.name : name;
        if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
          var value = structure[locationName];
          var result = translate(value, memberShape);
          if (result !== void 0) struct[name] = result;
        }
      });
      return struct;
    }
    function translateList(list, shape) {
      if (list == null) return void 0;
      var out = [];
      util.arrayEach(list, function (value) {
        var result = translate(value, shape.member);
        if (result === void 0) out.push(null);
        else out.push(result);
      });
      return out;
    }
    function translateMap(map, shape) {
      if (map == null) return void 0;
      var out = {};
      util.each(map, function (key, value) {
        var result = translate(value, shape.value);
        if (result === void 0) out[key] = null;
        else out[key] = result;
      });
      return out;
    }
    function translateScalar(value, shape) {
      return shape.toType(value);
    }
    module2.exports = JsonParser;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/helpers.js
var require_helpers = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/helpers.js'(exports, module2) {
    var util = require_util();
    var AWS3 = require_core();
    function populateHostPrefix(request) {
      var enabled = request.service.config.hostPrefixEnabled;
      if (!enabled) return request;
      var operationModel = request.service.api.operations[request.operation];
      if (hasEndpointDiscover(request)) return request;
      if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
        var hostPrefixNotation = operationModel.endpoint.hostPrefix;
        var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
        prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
        validateHostname(request.httpRequest.endpoint.hostname);
      }
      return request;
    }
    function hasEndpointDiscover(request) {
      var api = request.service.api;
      var operationModel = api.operations[request.operation];
      var isEndpointOperation =
        api.endpointOperation && api.endpointOperation === util.string.lowerFirst(operationModel.name);
      return operationModel.endpointDiscoveryRequired !== 'NULL' || isEndpointOperation === true;
    }
    function expandHostPrefix(hostPrefixNotation, params, shape) {
      util.each(shape.members, function (name, member) {
        if (member.hostLabel === true) {
          if (typeof params[name] !== 'string' || params[name] === '') {
            throw util.error(new Error(), {
              message: 'Parameter ' + name + ' should be a non-empty string.',
              code: 'InvalidParameter',
            });
          }
          var regex = new RegExp('\\{' + name + '\\}', 'g');
          hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
        }
      });
      return hostPrefixNotation;
    }
    function prependEndpointPrefix(endpoint, prefix) {
      if (endpoint.host) {
        endpoint.host = prefix + endpoint.host;
      }
      if (endpoint.hostname) {
        endpoint.hostname = prefix + endpoint.hostname;
      }
    }
    function validateHostname(hostname) {
      var labels = hostname.split('.');
      var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
      util.arrayEach(labels, function (label) {
        if (!label.length || label.length < 1 || label.length > 63) {
          throw util.error(new Error(), {
            code: 'ValidationError',
            message: 'Hostname label length should be between 1 to 63 characters, inclusive.',
          });
        }
        if (!hostPattern.test(label)) {
          throw AWS3.util.error(new Error(), {
            code: 'ValidationError',
            message: label + ' is not hostname compatible.',
          });
        }
      });
    }
    module2.exports = {
      populateHostPrefix,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/json.js
var require_json = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/json.js'(exports, module2) {
    var util = require_util();
    var JsonBuilder = require_builder();
    var JsonParser = require_parser();
    var populateHostPrefix = require_helpers().populateHostPrefix;
    function buildRequest(req) {
      var httpRequest = req.httpRequest;
      var api = req.service.api;
      var target = api.targetPrefix + '.' + api.operations[req.operation].name;
      var version = api.jsonVersion || '1.0';
      var input = api.operations[req.operation].input;
      var builder = new JsonBuilder();
      if (version === 1) version = '1.0';
      if (api.awsQueryCompatible) {
        if (!httpRequest.params) {
          httpRequest.params = {};
        }
        Object.assign(httpRequest.params, req.params);
      }
      httpRequest.body = builder.build(req.params || {}, input);
      httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
      httpRequest.headers['X-Amz-Target'] = target;
      populateHostPrefix(req);
    }
    function extractError(resp) {
      var error = {};
      var httpResponse = resp.httpResponse;
      error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
      if (typeof error.code === 'string') {
        error.code = error.code.split(':')[0];
      }
      if (httpResponse.body.length > 0) {
        try {
          var e = JSON.parse(httpResponse.body.toString());
          var code = e.__type || e.code || e.Code;
          if (code) {
            error.code = code.split('#').pop();
          }
          if (error.code === 'RequestEntityTooLarge') {
            error.message = 'Request body must be less than 1 MB';
          } else {
            error.message = e.message || e.Message || null;
          }
          for (var key in e || {}) {
            if (key === 'code' || key === 'message') {
              continue;
            }
            error['[' + key + ']'] = 'See error.' + key + ' for details.';
            Object.defineProperty(error, key, {
              value: e[key],
              enumerable: false,
              writable: true,
            });
          }
        } catch (e2) {
          error.statusCode = httpResponse.statusCode;
          error.message = httpResponse.statusMessage;
        }
      } else {
        error.statusCode = httpResponse.statusCode;
        error.message = httpResponse.statusCode.toString();
      }
      resp.error = util.error(new Error(), error);
    }
    function extractData(resp) {
      var body = resp.httpResponse.body.toString() || '{}';
      if (resp.request.service.config.convertResponseTypes === false) {
        resp.data = JSON.parse(body);
      } else {
        var operation = resp.request.service.api.operations[resp.request.operation];
        var shape = operation.output || {};
        var parser = new JsonParser();
        resp.data = parser.parse(body, shape);
      }
    }
    module2.exports = {
      buildRequest,
      extractError,
      extractData,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/query/query_param_serializer.js
var require_query_param_serializer = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/query/query_param_serializer.js'(exports, module2) {
    var util = require_util();
    function QueryParamSerializer() {}
    QueryParamSerializer.prototype.serialize = function (params, shape, fn) {
      serializeStructure('', params, shape, fn);
    };
    function ucfirst(shape) {
      if (shape.isQueryName || shape.api.protocol !== 'ec2') {
        return shape.name;
      } else {
        return shape.name[0].toUpperCase() + shape.name.substr(1);
      }
    }
    function serializeStructure(prefix, struct, rules, fn) {
      util.each(rules.members, function (name, member) {
        var value = struct[name];
        if (value === null || value === void 0) return;
        var memberName = ucfirst(member);
        memberName = prefix ? prefix + '.' + memberName : memberName;
        serializeMember(memberName, value, member, fn);
      });
    }
    function serializeMap(name, map, rules, fn) {
      var i = 1;
      util.each(map, function (key, value) {
        var prefix = rules.flattened ? '.' : '.entry.';
        var position = prefix + i++ + '.';
        var keyName = position + (rules.key.name || 'key');
        var valueName = position + (rules.value.name || 'value');
        serializeMember(name + keyName, key, rules.key, fn);
        serializeMember(name + valueName, value, rules.value, fn);
      });
    }
    function serializeList(name, list, rules, fn) {
      var memberRules = rules.member || {};
      if (list.length === 0) {
        fn.call(this, name, null);
        return;
      }
      util.arrayEach(list, function (v, n) {
        var suffix = '.' + (n + 1);
        if (rules.api.protocol === 'ec2') {
          suffix = suffix + '';
        } else if (rules.flattened) {
          if (memberRules.name) {
            var parts = name.split('.');
            parts.pop();
            parts.push(ucfirst(memberRules));
            name = parts.join('.');
          }
        } else {
          suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;
        }
        serializeMember(name + suffix, v, memberRules, fn);
      });
    }
    function serializeMember(name, value, rules, fn) {
      if (value === null || value === void 0) return;
      if (rules.type === 'structure') {
        serializeStructure(name, value, rules, fn);
      } else if (rules.type === 'list') {
        serializeList(name, value, rules, fn);
      } else if (rules.type === 'map') {
        serializeMap(name, value, rules, fn);
      } else {
        fn(name, rules.toWireFormat(value).toString());
      }
    }
    module2.exports = QueryParamSerializer;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/collection.js
var require_collection = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/collection.js'(exports, module2) {
    var memoizedProperty = require_util().memoizedProperty;
    function memoize(name, value, factory, nameTr) {
      memoizedProperty(this, nameTr(name), function () {
        return factory(name, value);
      });
    }
    function Collection(iterable, options, factory, nameTr, callback) {
      nameTr = nameTr || String;
      var self = this;
      for (var id in iterable) {
        if (Object.prototype.hasOwnProperty.call(iterable, id)) {
          memoize.call(self, id, iterable[id], factory, nameTr);
          if (callback) callback(id, iterable[id]);
        }
      }
    }
    module2.exports = Collection;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/shape.js
var require_shape = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/shape.js'(exports, module2) {
    var Collection = require_collection();
    var util = require_util();
    function property(obj, name, value) {
      if (value !== null && value !== void 0) {
        util.property.apply(this, arguments);
      }
    }
    function memoizedProperty(obj, name) {
      if (!obj.constructor.prototype[name]) {
        util.memoizedProperty.apply(this, arguments);
      }
    }
    function Shape(shape, options, memberName) {
      options = options || {};
      property(this, 'shape', shape.shape);
      property(this, 'api', options.api, false);
      property(this, 'type', shape.type);
      property(this, 'enum', shape.enum);
      property(this, 'min', shape.min);
      property(this, 'max', shape.max);
      property(this, 'pattern', shape.pattern);
      property(this, 'location', shape.location || this.location || 'body');
      property(this, 'name', this.name || shape.xmlName || shape.queryName || shape.locationName || memberName);
      property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
      property(this, 'requiresLength', shape.requiresLength, false);
      property(this, 'isComposite', shape.isComposite || false);
      property(this, 'isShape', true, false);
      property(this, 'isQueryName', Boolean(shape.queryName), false);
      property(this, 'isLocationName', Boolean(shape.locationName), false);
      property(this, 'isIdempotent', shape.idempotencyToken === true);
      property(this, 'isJsonValue', shape.jsonvalue === true);
      property(
        this,
        'isSensitive',
        shape.sensitive === true || (shape.prototype && shape.prototype.sensitive === true)
      );
      property(this, 'isEventStream', Boolean(shape.eventstream), false);
      property(this, 'isEvent', Boolean(shape.event), false);
      property(this, 'isEventPayload', Boolean(shape.eventpayload), false);
      property(this, 'isEventHeader', Boolean(shape.eventheader), false);
      property(
        this,
        'isTimestampFormatSet',
        Boolean(shape.timestampFormat) || (shape.prototype && shape.prototype.isTimestampFormatSet === true),
        false
      );
      property(this, 'endpointDiscoveryId', Boolean(shape.endpointdiscoveryid), false);
      property(this, 'hostLabel', Boolean(shape.hostLabel), false);
      if (options.documentation) {
        property(this, 'documentation', shape.documentation);
        property(this, 'documentationUrl', shape.documentationUrl);
      }
      if (shape.xmlAttribute) {
        property(this, 'isXmlAttribute', shape.xmlAttribute || false);
      }
      property(this, 'defaultValue', null);
      this.toWireFormat = function (value) {
        if (value === null || value === void 0) return '';
        return value;
      };
      this.toType = function (value) {
        return value;
      };
    }
    Shape.normalizedTypes = {
      character: 'string',
      double: 'float',
      long: 'integer',
      short: 'integer',
      biginteger: 'integer',
      bigdecimal: 'float',
      blob: 'binary',
    };
    Shape.types = {
      structure: StructureShape,
      list: ListShape,
      map: MapShape,
      boolean: BooleanShape,
      timestamp: TimestampShape,
      float: FloatShape,
      integer: IntegerShape,
      string: StringShape,
      base64: Base64Shape,
      binary: BinaryShape,
    };
    Shape.resolve = function resolve(shape, options) {
      if (shape.shape) {
        var refShape = options.api.shapes[shape.shape];
        if (!refShape) {
          throw new Error('Cannot find shape reference: ' + shape.shape);
        }
        return refShape;
      } else {
        return null;
      }
    };
    Shape.create = function create(shape, options, memberName) {
      if (shape.isShape) return shape;
      var refShape = Shape.resolve(shape, options);
      if (refShape) {
        var filteredKeys = Object.keys(shape);
        if (!options.documentation) {
          filteredKeys = filteredKeys.filter(function (name) {
            return !name.match(/documentation/);
          });
        }
        var InlineShape = function () {
          refShape.constructor.call(this, shape, options, memberName);
        };
        InlineShape.prototype = refShape;
        return new InlineShape();
      } else {
        if (!shape.type) {
          if (shape.members) shape.type = 'structure';
          else if (shape.member) shape.type = 'list';
          else if (shape.key) shape.type = 'map';
          else shape.type = 'string';
        }
        var origType = shape.type;
        if (Shape.normalizedTypes[shape.type]) {
          shape.type = Shape.normalizedTypes[shape.type];
        }
        if (Shape.types[shape.type]) {
          return new Shape.types[shape.type](shape, options, memberName);
        } else {
          throw new Error('Unrecognized shape type: ' + origType);
        }
      }
    };
    function CompositeShape(shape) {
      Shape.apply(this, arguments);
      property(this, 'isComposite', true);
      if (shape.flattened) {
        property(this, 'flattened', shape.flattened || false);
      }
    }
    function StructureShape(shape, options) {
      var self = this;
      var requiredMap = null,
        firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, 'defaultValue', function () {
          return {};
        });
        property(this, 'members', {});
        property(this, 'memberNames', []);
        property(this, 'required', []);
        property(this, 'isRequired', function () {
          return false;
        });
        property(this, 'isDocument', Boolean(shape.document));
      }
      if (shape.members) {
        property(
          this,
          'members',
          new Collection(shape.members, options, function (name, member) {
            return Shape.create(member, options, name);
          })
        );
        memoizedProperty(this, 'memberNames', function () {
          return shape.xmlOrder || Object.keys(shape.members);
        });
        if (shape.event) {
          memoizedProperty(this, 'eventPayloadMemberName', function () {
            var members = self.members;
            var memberNames = self.memberNames;
            for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
              if (members[memberNames[i]].isEventPayload) {
                return memberNames[i];
              }
            }
          });
          memoizedProperty(this, 'eventHeaderMemberNames', function () {
            var members = self.members;
            var memberNames = self.memberNames;
            var eventHeaderMemberNames = [];
            for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
              if (members[memberNames[i]].isEventHeader) {
                eventHeaderMemberNames.push(memberNames[i]);
              }
            }
            return eventHeaderMemberNames;
          });
        }
      }
      if (shape.required) {
        property(this, 'required', shape.required);
        property(
          this,
          'isRequired',
          function (name) {
            if (!requiredMap) {
              requiredMap = {};
              for (var i = 0; i < shape.required.length; i++) {
                requiredMap[shape.required[i]] = true;
              }
            }
            return requiredMap[name];
          },
          false,
          true
        );
      }
      property(this, 'resultWrapper', shape.resultWrapper || null);
      if (shape.payload) {
        property(this, 'payload', shape.payload);
      }
      if (typeof shape.xmlNamespace === 'string') {
        property(this, 'xmlNamespaceUri', shape.xmlNamespace);
      } else if (typeof shape.xmlNamespace === 'object') {
        property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
        property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
      }
    }
    function ListShape(shape, options) {
      var self = this,
        firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, 'defaultValue', function () {
          return [];
        });
      }
      if (shape.member) {
        memoizedProperty(this, 'member', function () {
          return Shape.create(shape.member, options);
        });
      }
      if (this.flattened) {
        var oldName = this.name;
        memoizedProperty(this, 'name', function () {
          return self.member.name || oldName;
        });
      }
    }
    function MapShape(shape, options) {
      var firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, 'defaultValue', function () {
          return {};
        });
        property(this, 'key', Shape.create({ type: 'string' }, options));
        property(this, 'value', Shape.create({ type: 'string' }, options));
      }
      if (shape.key) {
        memoizedProperty(this, 'key', function () {
          return Shape.create(shape.key, options);
        });
      }
      if (shape.value) {
        memoizedProperty(this, 'value', function () {
          return Shape.create(shape.value, options);
        });
      }
    }
    function TimestampShape(shape) {
      var self = this;
      Shape.apply(this, arguments);
      if (shape.timestampFormat) {
        property(this, 'timestampFormat', shape.timestampFormat);
      } else if (self.isTimestampFormatSet && this.timestampFormat) {
        property(this, 'timestampFormat', this.timestampFormat);
      } else if (this.location === 'header') {
        property(this, 'timestampFormat', 'rfc822');
      } else if (this.location === 'querystring') {
        property(this, 'timestampFormat', 'iso8601');
      } else if (this.api) {
        switch (this.api.protocol) {
          case 'json':
          case 'rest-json':
            property(this, 'timestampFormat', 'unixTimestamp');
            break;
          case 'rest-xml':
          case 'query':
          case 'ec2':
            property(this, 'timestampFormat', 'iso8601');
            break;
        }
      }
      this.toType = function (value) {
        if (value === null || value === void 0) return null;
        if (typeof value.toUTCString === 'function') return value;
        return typeof value === 'string' || typeof value === 'number' ? util.date.parseTimestamp(value) : null;
      };
      this.toWireFormat = function (value) {
        return util.date.format(value, self.timestampFormat);
      };
    }
    function StringShape() {
      Shape.apply(this, arguments);
      var nullLessProtocols = ['rest-xml', 'query', 'ec2'];
      this.toType = function (value) {
        value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ? value || '' : value;
        if (this.isJsonValue) {
          return JSON.parse(value);
        }
        return value && typeof value.toString === 'function' ? value.toString() : value;
      };
      this.toWireFormat = function (value) {
        return this.isJsonValue ? JSON.stringify(value) : value;
      };
    }
    function FloatShape() {
      Shape.apply(this, arguments);
      this.toType = function (value) {
        if (value === null || value === void 0) return null;
        return parseFloat(value);
      };
      this.toWireFormat = this.toType;
    }
    function IntegerShape() {
      Shape.apply(this, arguments);
      this.toType = function (value) {
        if (value === null || value === void 0) return null;
        return parseInt(value, 10);
      };
      this.toWireFormat = this.toType;
    }
    function BinaryShape() {
      Shape.apply(this, arguments);
      this.toType = function (value) {
        var buf = util.base64.decode(value);
        if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === 'function') {
          var secureBuf = util.Buffer.alloc(buf.length, buf);
          buf.fill(0);
          buf = secureBuf;
        }
        return buf;
      };
      this.toWireFormat = util.base64.encode;
    }
    function Base64Shape() {
      BinaryShape.apply(this, arguments);
    }
    function BooleanShape() {
      Shape.apply(this, arguments);
      this.toType = function (value) {
        if (typeof value === 'boolean') return value;
        if (value === null || value === void 0) return null;
        return value === 'true';
      };
    }
    Shape.shapes = {
      StructureShape,
      ListShape,
      MapShape,
      StringShape,
      BooleanShape,
      Base64Shape,
    };
    module2.exports = Shape;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/query.js
var require_query = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/query.js'(exports, module2) {
    var AWS3 = require_core();
    var util = require_util();
    var QueryParamSerializer = require_query_param_serializer();
    var Shape = require_shape();
    var populateHostPrefix = require_helpers().populateHostPrefix;
    function buildRequest(req) {
      var operation = req.service.api.operations[req.operation];
      var httpRequest = req.httpRequest;
      httpRequest.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8';
      httpRequest.params = {
        Version: req.service.api.apiVersion,
        Action: operation.name,
      };
      var builder = new QueryParamSerializer();
      builder.serialize(req.params, operation.input, function (name, value) {
        httpRequest.params[name] = value;
      });
      httpRequest.body = util.queryParamsToString(httpRequest.params);
      populateHostPrefix(req);
    }
    function extractError(resp) {
      var data,
        body = resp.httpResponse.body.toString();
      if (body.match('<UnknownOperationException')) {
        data = {
          Code: 'UnknownOperation',
          Message: 'Unknown operation ' + resp.request.operation,
        };
      } else {
        try {
          data = new AWS3.XML.Parser().parse(body);
        } catch (e) {
          data = {
            Code: resp.httpResponse.statusCode,
            Message: resp.httpResponse.statusMessage,
          };
        }
      }
      if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
      if (data.Errors) data = data.Errors;
      if (data.Error) data = data.Error;
      if (data.Code) {
        resp.error = util.error(new Error(), {
          code: data.Code,
          message: data.Message,
        });
      } else {
        resp.error = util.error(new Error(), {
          code: resp.httpResponse.statusCode,
          message: null,
        });
      }
    }
    function extractData(resp) {
      var req = resp.request;
      var operation = req.service.api.operations[req.operation];
      var shape = operation.output || {};
      var origRules = shape;
      if (origRules.resultWrapper) {
        var tmp = Shape.create({ type: 'structure' });
        tmp.members[origRules.resultWrapper] = shape;
        tmp.memberNames = [origRules.resultWrapper];
        util.property(shape, 'name', shape.resultWrapper);
        shape = tmp;
      }
      var parser = new AWS3.XML.Parser();
      if (shape && shape.members && !shape.members._XAMZRequestId) {
        var requestIdShape = Shape.create({ type: 'string' }, { api: { protocol: 'query' } }, 'requestId');
        shape.members._XAMZRequestId = requestIdShape;
      }
      var data = parser.parse(resp.httpResponse.body.toString(), shape);
      resp.requestId = data._XAMZRequestId || data.requestId;
      if (data._XAMZRequestId) delete data._XAMZRequestId;
      if (origRules.resultWrapper) {
        if (data[origRules.resultWrapper]) {
          util.update(data, data[origRules.resultWrapper]);
          delete data[origRules.resultWrapper];
        }
      }
      resp.data = data;
    }
    module2.exports = {
      buildRequest,
      extractError,
      extractData,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/rest.js
var require_rest = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/rest.js'(exports, module2) {
    var util = require_util();
    var populateHostPrefix = require_helpers().populateHostPrefix;
    function populateMethod(req) {
      req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
    }
    function generateURI(endpointPath, operationPath, input, params) {
      var uri = [endpointPath, operationPath].join('/');
      uri = uri.replace(/\/+/g, '/');
      var queryString = {},
        queryStringSet = false;
      util.each(input.members, function (name, member) {
        var paramValue = params[name];
        if (paramValue === null || paramValue === void 0) return;
        if (member.location === 'uri') {
          var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
          uri = uri.replace(regex, function (_, plus) {
            var fn = plus ? util.uriEscapePath : util.uriEscape;
            return fn(String(paramValue));
          });
        } else if (member.location === 'querystring') {
          queryStringSet = true;
          if (member.type === 'list') {
            queryString[member.name] = paramValue.map(function (val) {
              return util.uriEscape(member.member.toWireFormat(val).toString());
            });
          } else if (member.type === 'map') {
            util.each(paramValue, function (key, value) {
              if (Array.isArray(value)) {
                queryString[key] = value.map(function (val) {
                  return util.uriEscape(String(val));
                });
              } else {
                queryString[key] = util.uriEscape(String(value));
              }
            });
          } else {
            queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
          }
        }
      });
      if (queryStringSet) {
        uri += uri.indexOf('?') >= 0 ? '&' : '?';
        var parts = [];
        util.arrayEach(Object.keys(queryString).sort(), function (key) {
          if (!Array.isArray(queryString[key])) {
            queryString[key] = [queryString[key]];
          }
          for (var i = 0; i < queryString[key].length; i++) {
            parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
          }
        });
        uri += parts.join('&');
      }
      return uri;
    }
    function populateURI(req) {
      var operation = req.service.api.operations[req.operation];
      var input = operation.input;
      var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
      req.httpRequest.path = uri;
    }
    function populateHeaders(req) {
      var operation = req.service.api.operations[req.operation];
      util.each(operation.input.members, function (name, member) {
        var value = req.params[name];
        if (value === null || value === void 0) return;
        if (member.location === 'headers' && member.type === 'map') {
          util.each(value, function (key, memberValue) {
            req.httpRequest.headers[member.name + key] = memberValue;
          });
        } else if (member.location === 'header') {
          value = member.toWireFormat(value).toString();
          if (member.isJsonValue) {
            value = util.base64.encode(value);
          }
          req.httpRequest.headers[member.name] = value;
        }
      });
    }
    function buildRequest(req) {
      populateMethod(req);
      populateURI(req);
      populateHeaders(req);
      populateHostPrefix(req);
    }
    function extractError() {}
    function extractData(resp) {
      var req = resp.request;
      var data = {};
      var r = resp.httpResponse;
      var operation = req.service.api.operations[req.operation];
      var output = operation.output;
      var headers = {};
      util.each(r.headers, function (k, v) {
        headers[k.toLowerCase()] = v;
      });
      util.each(output.members, function (name, member) {
        var header = (member.name || name).toLowerCase();
        if (member.location === 'headers' && member.type === 'map') {
          data[name] = {};
          var location = member.isLocationName ? member.name : '';
          var pattern = new RegExp('^' + location + '(.+)', 'i');
          util.each(r.headers, function (k, v) {
            var result = k.match(pattern);
            if (result !== null) {
              data[name][result[1]] = v;
            }
          });
        } else if (member.location === 'header') {
          if (headers[header] !== void 0) {
            var value = member.isJsonValue ? util.base64.decode(headers[header]) : headers[header];
            data[name] = member.toType(value);
          }
        } else if (member.location === 'statusCode') {
          data[name] = parseInt(r.statusCode, 10);
        }
      });
      resp.data = data;
    }
    module2.exports = {
      buildRequest,
      extractError,
      extractData,
      generateURI,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/rest_json.js
var require_rest_json = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/rest_json.js'(exports, module2) {
    var util = require_util();
    var Rest = require_rest();
    var Json = require_json();
    var JsonBuilder = require_builder();
    var JsonParser = require_parser();
    var METHODS_WITHOUT_BODY = ['GET', 'HEAD', 'DELETE'];
    function unsetContentLength(req) {
      var payloadMember = util.getRequestPayloadShape(req);
      if (payloadMember === void 0 && METHODS_WITHOUT_BODY.indexOf(req.httpRequest.method) >= 0) {
        delete req.httpRequest.headers['Content-Length'];
      }
    }
    function populateBody(req) {
      var builder = new JsonBuilder();
      var input = req.service.api.operations[req.operation].input;
      if (input.payload) {
        var params = {};
        var payloadShape = input.members[input.payload];
        params = req.params[input.payload];
        if (payloadShape.type === 'structure') {
          req.httpRequest.body = builder.build(params || {}, payloadShape);
          applyContentTypeHeader(req);
        } else if (params !== void 0) {
          req.httpRequest.body = params;
          if (payloadShape.type === 'binary' || payloadShape.isStreaming) {
            applyContentTypeHeader(req, true);
          }
        }
      } else {
        req.httpRequest.body = builder.build(req.params, input);
        applyContentTypeHeader(req);
      }
    }
    function applyContentTypeHeader(req, isBinary) {
      if (!req.httpRequest.headers['Content-Type']) {
        var type = isBinary ? 'binary/octet-stream' : 'application/json';
        req.httpRequest.headers['Content-Type'] = type;
      }
    }
    function buildRequest(req) {
      Rest.buildRequest(req);
      if (METHODS_WITHOUT_BODY.indexOf(req.httpRequest.method) < 0) {
        populateBody(req);
      }
    }
    function extractError(resp) {
      Json.extractError(resp);
    }
    function extractData(resp) {
      Rest.extractData(resp);
      var req = resp.request;
      var operation = req.service.api.operations[req.operation];
      var rules = req.service.api.operations[req.operation].output || {};
      var parser;
      var hasEventOutput = operation.hasEventOutput;
      if (rules.payload) {
        var payloadMember = rules.members[rules.payload];
        var body = resp.httpResponse.body;
        if (payloadMember.isEventStream) {
          parser = new JsonParser();
          resp.data[payload] = util.createEventStream(
            AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
            parser,
            payloadMember
          );
        } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
          var parser = new JsonParser();
          resp.data[rules.payload] = parser.parse(body, payloadMember);
        } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
          resp.data[rules.payload] = body;
        } else {
          resp.data[rules.payload] = payloadMember.toType(body);
        }
      } else {
        var data = resp.data;
        Json.extractData(resp);
        resp.data = util.merge(data, resp.data);
      }
    }
    module2.exports = {
      buildRequest,
      extractError,
      extractData,
      unsetContentLength,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/rest_xml.js
var require_rest_xml = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/protocol/rest_xml.js'(exports, module2) {
    var AWS3 = require_core();
    var util = require_util();
    var Rest = require_rest();
    function populateBody(req) {
      var input = req.service.api.operations[req.operation].input;
      var builder = new AWS3.XML.Builder();
      var params = req.params;
      var payload2 = input.payload;
      if (payload2) {
        var payloadMember = input.members[payload2];
        params = params[payload2];
        if (params === void 0) return;
        if (payloadMember.type === 'structure') {
          var rootElement = payloadMember.name;
          req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
        } else {
          req.httpRequest.body = params;
        }
      } else {
        req.httpRequest.body = builder.toXML(
          params,
          input,
          input.name || input.shape || util.string.upperFirst(req.operation) + 'Request'
        );
      }
    }
    function buildRequest(req) {
      Rest.buildRequest(req);
      if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
        populateBody(req);
      }
    }
    function extractError(resp) {
      Rest.extractError(resp);
      var data;
      try {
        data = new AWS3.XML.Parser().parse(resp.httpResponse.body.toString());
      } catch (e) {
        data = {
          Code: resp.httpResponse.statusCode,
          Message: resp.httpResponse.statusMessage,
        };
      }
      if (data.Errors) data = data.Errors;
      if (data.Error) data = data.Error;
      if (data.Code) {
        resp.error = util.error(new Error(), {
          code: data.Code,
          message: data.Message,
        });
      } else {
        resp.error = util.error(new Error(), {
          code: resp.httpResponse.statusCode,
          message: null,
        });
      }
    }
    function extractData(resp) {
      Rest.extractData(resp);
      var parser;
      var req = resp.request;
      var body = resp.httpResponse.body;
      var operation = req.service.api.operations[req.operation];
      var output = operation.output;
      var hasEventOutput = operation.hasEventOutput;
      var payload2 = output.payload;
      if (payload2) {
        var payloadMember = output.members[payload2];
        if (payloadMember.isEventStream) {
          parser = new AWS3.XML.Parser();
          resp.data[payload2] = util.createEventStream(
            AWS3.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
            parser,
            payloadMember
          );
        } else if (payloadMember.type === 'structure') {
          parser = new AWS3.XML.Parser();
          resp.data[payload2] = parser.parse(body.toString(), payloadMember);
        } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
          resp.data[payload2] = body;
        } else {
          resp.data[payload2] = payloadMember.toType(body);
        }
      } else if (body.length > 0) {
        parser = new AWS3.XML.Parser();
        var data = parser.parse(body.toString(), output);
        util.update(resp.data, data);
      }
    }
    module2.exports = {
      buildRequest,
      extractError,
      extractData,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/escape-attribute.js
var require_escape_attribute = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/escape-attribute.js'(exports, module2) {
    function escapeAttribute(value) {
      return value
        .replace(/&/g, '&amp;')
        .replace(/'/g, '&apos;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    }
    module2.exports = {
      escapeAttribute,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/xml-node.js
var require_xml_node = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/xml-node.js'(exports, module2) {
    var escapeAttribute = require_escape_attribute().escapeAttribute;
    function XmlNode(name, children2) {
      if (children2 === void 0) {
        children2 = [];
      }
      this.name = name;
      this.children = children2;
      this.attributes = {};
    }
    XmlNode.prototype.addAttribute = function (name, value) {
      this.attributes[name] = value;
      return this;
    };
    XmlNode.prototype.addChildNode = function (child) {
      this.children.push(child);
      return this;
    };
    XmlNode.prototype.removeAttribute = function (name) {
      delete this.attributes[name];
      return this;
    };
    XmlNode.prototype.toString = function () {
      var hasChildren = Boolean(this.children.length);
      var xmlText = '<' + this.name;
      var attributes = this.attributes;
      for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
        var attributeName = attributeNames[i];
        var attribute = attributes[attributeName];
        if (typeof attribute !== 'undefined' && attribute !== null) {
          xmlText += ' ' + attributeName + '="' + escapeAttribute('' + attribute) + '"';
        }
      }
      return (xmlText += !hasChildren
        ? '/>'
        : '>' +
          this.children
            .map(function (c) {
              return c.toString();
            })
            .join('') +
          '</' +
          this.name +
          '>');
    };
    module2.exports = {
      XmlNode,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/escape-element.js
var require_escape_element = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/escape-element.js'(exports, module2) {
    function escapeElement(value) {
      return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\r/g, '&#x0D;')
        .replace(/\n/g, '&#x0A;')
        .replace(/\u0085/g, '&#x85;')
        .replace(/\u2028/, '&#x2028;');
    }
    module2.exports = {
      escapeElement,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/xml-text.js
var require_xml_text = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/xml-text.js'(exports, module2) {
    var escapeElement = require_escape_element().escapeElement;
    function XmlText(value) {
      this.value = value;
    }
    XmlText.prototype.toString = function () {
      return escapeElement('' + this.value);
    };
    module2.exports = {
      XmlText,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/builder.js
var require_builder2 = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/builder.js'(exports, module2) {
    var util = require_util();
    var XmlNode = require_xml_node().XmlNode;
    var XmlText = require_xml_text().XmlText;
    function XmlBuilder() {}
    XmlBuilder.prototype.toXML = function (params, shape, rootElement, noEmpty) {
      var xml = new XmlNode(rootElement);
      applyNamespaces(xml, shape, true);
      serialize(xml, params, shape);
      return xml.children.length > 0 || noEmpty ? xml.toString() : '';
    };
    function serialize(xml, value, shape) {
      switch (shape.type) {
        case 'structure':
          return serializeStructure(xml, value, shape);
        case 'map':
          return serializeMap(xml, value, shape);
        case 'list':
          return serializeList(xml, value, shape);
        default:
          return serializeScalar(xml, value, shape);
      }
    }
    function serializeStructure(xml, params, shape) {
      util.arrayEach(shape.memberNames, function (memberName) {
        var memberShape = shape.members[memberName];
        if (memberShape.location !== 'body') return;
        var value = params[memberName];
        var name = memberShape.name;
        if (value !== void 0 && value !== null) {
          if (memberShape.isXmlAttribute) {
            xml.addAttribute(name, value);
          } else if (memberShape.flattened) {
            serialize(xml, value, memberShape);
          } else {
            var element = new XmlNode(name);
            xml.addChildNode(element);
            applyNamespaces(element, memberShape);
            serialize(element, value, memberShape);
          }
        }
      });
    }
    function serializeMap(xml, map, shape) {
      var xmlKey = shape.key.name || 'key';
      var xmlValue = shape.value.name || 'value';
      util.each(map, function (key, value) {
        var entry = new XmlNode(shape.flattened ? shape.name : 'entry');
        xml.addChildNode(entry);
        var entryKey = new XmlNode(xmlKey);
        var entryValue = new XmlNode(xmlValue);
        entry.addChildNode(entryKey);
        entry.addChildNode(entryValue);
        serialize(entryKey, key, shape.key);
        serialize(entryValue, value, shape.value);
      });
    }
    function serializeList(xml, list, shape) {
      if (shape.flattened) {
        util.arrayEach(list, function (value) {
          var name = shape.member.name || shape.name;
          var element = new XmlNode(name);
          xml.addChildNode(element);
          serialize(element, value, shape.member);
        });
      } else {
        util.arrayEach(list, function (value) {
          var name = shape.member.name || 'member';
          var element = new XmlNode(name);
          xml.addChildNode(element);
          serialize(element, value, shape.member);
        });
      }
    }
    function serializeScalar(xml, value, shape) {
      xml.addChildNode(new XmlText(shape.toWireFormat(value)));
    }
    function applyNamespaces(xml, shape, isRoot) {
      var uri,
        prefix = 'xmlns';
      if (shape.xmlNamespaceUri) {
        uri = shape.xmlNamespaceUri;
        if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
      } else if (isRoot && shape.api.xmlNamespaceUri) {
        uri = shape.api.xmlNamespaceUri;
      }
      if (uri) xml.addAttribute(prefix, uri);
    }
    module2.exports = XmlBuilder;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/operation.js
var require_operation = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/operation.js'(exports, module2) {
    var Shape = require_shape();
    var util = require_util();
    var property = util.property;
    var memoizedProperty = util.memoizedProperty;
    function Operation(name, operation, options) {
      var self = this;
      options = options || {};
      property(this, 'name', operation.name || name);
      property(this, 'api', options.api, false);
      operation.http = operation.http || {};
      property(this, 'endpoint', operation.endpoint);
      property(this, 'httpMethod', operation.http.method || 'POST');
      property(this, 'httpPath', operation.http.requestUri || '/');
      property(this, 'authtype', operation.authtype || '');
      property(
        this,
        'endpointDiscoveryRequired',
        operation.endpointdiscovery ? (operation.endpointdiscovery.required ? 'REQUIRED' : 'OPTIONAL') : 'NULL'
      );
      var httpChecksumRequired =
        operation.httpChecksumRequired || (operation.httpChecksum && operation.httpChecksum.requestChecksumRequired);
      property(this, 'httpChecksumRequired', httpChecksumRequired, false);
      memoizedProperty(this, 'input', function () {
        if (!operation.input) {
          return new Shape.create({ type: 'structure' }, options);
        }
        return Shape.create(operation.input, options);
      });
      memoizedProperty(this, 'output', function () {
        if (!operation.output) {
          return new Shape.create({ type: 'structure' }, options);
        }
        return Shape.create(operation.output, options);
      });
      memoizedProperty(this, 'errors', function () {
        var list = [];
        if (!operation.errors) return null;
        for (var i = 0; i < operation.errors.length; i++) {
          list.push(Shape.create(operation.errors[i], options));
        }
        return list;
      });
      memoizedProperty(this, 'paginator', function () {
        return options.api.paginators[name];
      });
      if (options.documentation) {
        property(this, 'documentation', operation.documentation);
        property(this, 'documentationUrl', operation.documentationUrl);
      }
      memoizedProperty(this, 'idempotentMembers', function () {
        var idempotentMembers = [];
        var input = self.input;
        var members = input.members;
        if (!input.members) {
          return idempotentMembers;
        }
        for (var name2 in members) {
          if (!members.hasOwnProperty(name2)) {
            continue;
          }
          if (members[name2].isIdempotent === true) {
            idempotentMembers.push(name2);
          }
        }
        return idempotentMembers;
      });
      memoizedProperty(this, 'hasEventOutput', function () {
        var output = self.output;
        return hasEventStream(output);
      });
    }
    function hasEventStream(topLevelShape) {
      var members = topLevelShape.members;
      var payload2 = topLevelShape.payload;
      if (!topLevelShape.members) {
        return false;
      }
      if (payload2) {
        var payloadMember = members[payload2];
        return payloadMember.isEventStream;
      }
      for (var name in members) {
        if (!members.hasOwnProperty(name)) {
          if (members[name].isEventStream === true) {
            return true;
          }
        }
      }
      return false;
    }
    module2.exports = Operation;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/paginator.js
var require_paginator = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/paginator.js'(exports, module2) {
    var property = require_util().property;
    function Paginator(name, paginator) {
      property(this, 'inputToken', paginator.input_token);
      property(this, 'limitKey', paginator.limit_key);
      property(this, 'moreResults', paginator.more_results);
      property(this, 'outputToken', paginator.output_token);
      property(this, 'resultKey', paginator.result_key);
    }
    module2.exports = Paginator;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/resource_waiter.js
var require_resource_waiter = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/resource_waiter.js'(exports, module2) {
    var util = require_util();
    var property = util.property;
    function ResourceWaiter(name, waiter, options) {
      options = options || {};
      property(this, 'name', name);
      property(this, 'api', options.api, false);
      if (waiter.operation) {
        property(this, 'operation', util.string.lowerFirst(waiter.operation));
      }
      var self = this;
      var keys = ['type', 'description', 'delay', 'maxAttempts', 'acceptors'];
      keys.forEach(function (key) {
        var value = waiter[key];
        if (value) {
          property(self, key, value);
        }
      });
    }
    module2.exports = ResourceWaiter;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/metadata.json
var require_metadata = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/metadata.json'(exports, module2) {
    module2.exports = {
      acm: {
        name: 'ACM',
        cors: true,
      },
      apigateway: {
        name: 'APIGateway',
        cors: true,
      },
      applicationautoscaling: {
        prefix: 'application-autoscaling',
        name: 'ApplicationAutoScaling',
        cors: true,
      },
      appstream: {
        name: 'AppStream',
      },
      autoscaling: {
        name: 'AutoScaling',
        cors: true,
      },
      batch: {
        name: 'Batch',
      },
      budgets: {
        name: 'Budgets',
      },
      clouddirectory: {
        name: 'CloudDirectory',
        versions: ['2016-05-10*'],
      },
      cloudformation: {
        name: 'CloudFormation',
        cors: true,
      },
      cloudfront: {
        name: 'CloudFront',
        versions: [
          '2013-05-12*',
          '2013-11-11*',
          '2014-05-31*',
          '2014-10-21*',
          '2014-11-06*',
          '2015-04-17*',
          '2015-07-27*',
          '2015-09-17*',
          '2016-01-13*',
          '2016-01-28*',
          '2016-08-01*',
          '2016-08-20*',
          '2016-09-07*',
          '2016-09-29*',
          '2016-11-25*',
          '2017-03-25*',
          '2017-10-30*',
          '2018-06-18*',
          '2018-11-05*',
          '2019-03-26*',
        ],
        cors: true,
      },
      cloudhsm: {
        name: 'CloudHSM',
        cors: true,
      },
      cloudsearch: {
        name: 'CloudSearch',
      },
      cloudsearchdomain: {
        name: 'CloudSearchDomain',
      },
      cloudtrail: {
        name: 'CloudTrail',
        cors: true,
      },
      cloudwatch: {
        prefix: 'monitoring',
        name: 'CloudWatch',
        cors: true,
      },
      cloudwatchevents: {
        prefix: 'events',
        name: 'CloudWatchEvents',
        versions: ['2014-02-03*'],
        cors: true,
      },
      cloudwatchlogs: {
        prefix: 'logs',
        name: 'CloudWatchLogs',
        cors: true,
      },
      codebuild: {
        name: 'CodeBuild',
        cors: true,
      },
      codecommit: {
        name: 'CodeCommit',
        cors: true,
      },
      codedeploy: {
        name: 'CodeDeploy',
        cors: true,
      },
      codepipeline: {
        name: 'CodePipeline',
        cors: true,
      },
      cognitoidentity: {
        prefix: 'cognito-identity',
        name: 'CognitoIdentity',
        cors: true,
      },
      cognitoidentityserviceprovider: {
        prefix: 'cognito-idp',
        name: 'CognitoIdentityServiceProvider',
        cors: true,
      },
      cognitosync: {
        prefix: 'cognito-sync',
        name: 'CognitoSync',
        cors: true,
      },
      configservice: {
        prefix: 'config',
        name: 'ConfigService',
        cors: true,
      },
      cur: {
        name: 'CUR',
        cors: true,
      },
      datapipeline: {
        name: 'DataPipeline',
      },
      devicefarm: {
        name: 'DeviceFarm',
        cors: true,
      },
      directconnect: {
        name: 'DirectConnect',
        cors: true,
      },
      directoryservice: {
        prefix: 'ds',
        name: 'DirectoryService',
      },
      discovery: {
        name: 'Discovery',
      },
      dms: {
        name: 'DMS',
      },
      dynamodb: {
        name: 'DynamoDB',
        cors: true,
      },
      dynamodbstreams: {
        prefix: 'streams.dynamodb',
        name: 'DynamoDBStreams',
        cors: true,
      },
      ec2: {
        name: 'EC2',
        versions: [
          '2013-06-15*',
          '2013-10-15*',
          '2014-02-01*',
          '2014-05-01*',
          '2014-06-15*',
          '2014-09-01*',
          '2014-10-01*',
          '2015-03-01*',
          '2015-04-15*',
          '2015-10-01*',
          '2016-04-01*',
          '2016-09-15*',
        ],
        cors: true,
      },
      ecr: {
        name: 'ECR',
        cors: true,
      },
      ecs: {
        name: 'ECS',
        cors: true,
      },
      efs: {
        prefix: 'elasticfilesystem',
        name: 'EFS',
        cors: true,
      },
      elasticache: {
        name: 'ElastiCache',
        versions: ['2012-11-15*', '2014-03-24*', '2014-07-15*', '2014-09-30*'],
        cors: true,
      },
      elasticbeanstalk: {
        name: 'ElasticBeanstalk',
        cors: true,
      },
      elb: {
        prefix: 'elasticloadbalancing',
        name: 'ELB',
        cors: true,
      },
      elbv2: {
        prefix: 'elasticloadbalancingv2',
        name: 'ELBv2',
        cors: true,
      },
      emr: {
        prefix: 'elasticmapreduce',
        name: 'EMR',
        cors: true,
      },
      es: {
        name: 'ES',
      },
      elastictranscoder: {
        name: 'ElasticTranscoder',
        cors: true,
      },
      firehose: {
        name: 'Firehose',
        cors: true,
      },
      gamelift: {
        name: 'GameLift',
        cors: true,
      },
      glacier: {
        name: 'Glacier',
      },
      health: {
        name: 'Health',
      },
      iam: {
        name: 'IAM',
        cors: true,
      },
      importexport: {
        name: 'ImportExport',
      },
      inspector: {
        name: 'Inspector',
        versions: ['2015-08-18*'],
        cors: true,
      },
      iot: {
        name: 'Iot',
        cors: true,
      },
      iotdata: {
        prefix: 'iot-data',
        name: 'IotData',
        cors: true,
      },
      kinesis: {
        name: 'Kinesis',
        cors: true,
      },
      kinesisanalytics: {
        name: 'KinesisAnalytics',
      },
      kms: {
        name: 'KMS',
        cors: true,
      },
      lambda: {
        name: 'Lambda',
        cors: true,
      },
      lexruntime: {
        prefix: 'runtime.lex',
        name: 'LexRuntime',
        cors: true,
      },
      lightsail: {
        name: 'Lightsail',
      },
      machinelearning: {
        name: 'MachineLearning',
        cors: true,
      },
      marketplacecommerceanalytics: {
        name: 'MarketplaceCommerceAnalytics',
        cors: true,
      },
      marketplacemetering: {
        prefix: 'meteringmarketplace',
        name: 'MarketplaceMetering',
      },
      mturk: {
        prefix: 'mturk-requester',
        name: 'MTurk',
        cors: true,
      },
      mobileanalytics: {
        name: 'MobileAnalytics',
        cors: true,
      },
      opsworks: {
        name: 'OpsWorks',
        cors: true,
      },
      opsworkscm: {
        name: 'OpsWorksCM',
      },
      organizations: {
        name: 'Organizations',
      },
      pinpoint: {
        name: 'Pinpoint',
      },
      polly: {
        name: 'Polly',
        cors: true,
      },
      rds: {
        name: 'RDS',
        versions: ['2014-09-01*'],
        cors: true,
      },
      redshift: {
        name: 'Redshift',
        cors: true,
      },
      rekognition: {
        name: 'Rekognition',
        cors: true,
      },
      resourcegroupstaggingapi: {
        name: 'ResourceGroupsTaggingAPI',
      },
      route53: {
        name: 'Route53',
        cors: true,
      },
      route53domains: {
        name: 'Route53Domains',
        cors: true,
      },
      s3: {
        name: 'S3',
        dualstackAvailable: true,
        cors: true,
      },
      s3control: {
        name: 'S3Control',
        dualstackAvailable: true,
        xmlNoDefaultLists: true,
      },
      servicecatalog: {
        name: 'ServiceCatalog',
        cors: true,
      },
      ses: {
        prefix: 'email',
        name: 'SES',
        cors: true,
      },
      shield: {
        name: 'Shield',
      },
      simpledb: {
        prefix: 'sdb',
        name: 'SimpleDB',
      },
      sms: {
        name: 'SMS',
      },
      snowball: {
        name: 'Snowball',
      },
      sns: {
        name: 'SNS',
        cors: true,
      },
      sqs: {
        name: 'SQS',
        cors: true,
      },
      ssm: {
        name: 'SSM',
        cors: true,
      },
      storagegateway: {
        name: 'StorageGateway',
        cors: true,
      },
      stepfunctions: {
        prefix: 'states',
        name: 'StepFunctions',
      },
      sts: {
        name: 'STS',
        cors: true,
      },
      support: {
        name: 'Support',
      },
      swf: {
        name: 'SWF',
      },
      xray: {
        name: 'XRay',
        cors: true,
      },
      waf: {
        name: 'WAF',
        cors: true,
      },
      wafregional: {
        prefix: 'waf-regional',
        name: 'WAFRegional',
      },
      workdocs: {
        name: 'WorkDocs',
        cors: true,
      },
      workspaces: {
        name: 'WorkSpaces',
      },
      codestar: {
        name: 'CodeStar',
      },
      lexmodelbuildingservice: {
        prefix: 'lex-models',
        name: 'LexModelBuildingService',
        cors: true,
      },
      marketplaceentitlementservice: {
        prefix: 'entitlement.marketplace',
        name: 'MarketplaceEntitlementService',
      },
      athena: {
        name: 'Athena',
        cors: true,
      },
      greengrass: {
        name: 'Greengrass',
      },
      dax: {
        name: 'DAX',
      },
      migrationhub: {
        prefix: 'AWSMigrationHub',
        name: 'MigrationHub',
      },
      cloudhsmv2: {
        name: 'CloudHSMV2',
        cors: true,
      },
      glue: {
        name: 'Glue',
      },
      mobile: {
        name: 'Mobile',
      },
      pricing: {
        name: 'Pricing',
        cors: true,
      },
      costexplorer: {
        prefix: 'ce',
        name: 'CostExplorer',
        cors: true,
      },
      mediaconvert: {
        name: 'MediaConvert',
      },
      medialive: {
        name: 'MediaLive',
      },
      mediapackage: {
        name: 'MediaPackage',
      },
      mediastore: {
        name: 'MediaStore',
      },
      mediastoredata: {
        prefix: 'mediastore-data',
        name: 'MediaStoreData',
        cors: true,
      },
      appsync: {
        name: 'AppSync',
      },
      guardduty: {
        name: 'GuardDuty',
      },
      mq: {
        name: 'MQ',
      },
      comprehend: {
        name: 'Comprehend',
        cors: true,
      },
      iotjobsdataplane: {
        prefix: 'iot-jobs-data',
        name: 'IoTJobsDataPlane',
      },
      kinesisvideoarchivedmedia: {
        prefix: 'kinesis-video-archived-media',
        name: 'KinesisVideoArchivedMedia',
        cors: true,
      },
      kinesisvideomedia: {
        prefix: 'kinesis-video-media',
        name: 'KinesisVideoMedia',
        cors: true,
      },
      kinesisvideo: {
        name: 'KinesisVideo',
        cors: true,
      },
      sagemakerruntime: {
        prefix: 'runtime.sagemaker',
        name: 'SageMakerRuntime',
      },
      sagemaker: {
        name: 'SageMaker',
      },
      translate: {
        name: 'Translate',
        cors: true,
      },
      resourcegroups: {
        prefix: 'resource-groups',
        name: 'ResourceGroups',
        cors: true,
      },
      alexaforbusiness: {
        name: 'AlexaForBusiness',
      },
      cloud9: {
        name: 'Cloud9',
      },
      serverlessapplicationrepository: {
        prefix: 'serverlessrepo',
        name: 'ServerlessApplicationRepository',
      },
      servicediscovery: {
        name: 'ServiceDiscovery',
      },
      workmail: {
        name: 'WorkMail',
      },
      autoscalingplans: {
        prefix: 'autoscaling-plans',
        name: 'AutoScalingPlans',
      },
      transcribeservice: {
        prefix: 'transcribe',
        name: 'TranscribeService',
      },
      connect: {
        name: 'Connect',
        cors: true,
      },
      acmpca: {
        prefix: 'acm-pca',
        name: 'ACMPCA',
      },
      fms: {
        name: 'FMS',
      },
      secretsmanager: {
        name: 'SecretsManager',
        cors: true,
      },
      iotanalytics: {
        name: 'IoTAnalytics',
        cors: true,
      },
      iot1clickdevicesservice: {
        prefix: 'iot1click-devices',
        name: 'IoT1ClickDevicesService',
      },
      iot1clickprojects: {
        prefix: 'iot1click-projects',
        name: 'IoT1ClickProjects',
      },
      pi: {
        name: 'PI',
      },
      neptune: {
        name: 'Neptune',
      },
      mediatailor: {
        name: 'MediaTailor',
      },
      eks: {
        name: 'EKS',
      },
      macie: {
        name: 'Macie',
      },
      dlm: {
        name: 'DLM',
      },
      signer: {
        name: 'Signer',
      },
      chime: {
        name: 'Chime',
      },
      pinpointemail: {
        prefix: 'pinpoint-email',
        name: 'PinpointEmail',
      },
      ram: {
        name: 'RAM',
      },
      route53resolver: {
        name: 'Route53Resolver',
      },
      pinpointsmsvoice: {
        prefix: 'sms-voice',
        name: 'PinpointSMSVoice',
      },
      quicksight: {
        name: 'QuickSight',
      },
      rdsdataservice: {
        prefix: 'rds-data',
        name: 'RDSDataService',
      },
      amplify: {
        name: 'Amplify',
      },
      datasync: {
        name: 'DataSync',
      },
      robomaker: {
        name: 'RoboMaker',
      },
      transfer: {
        name: 'Transfer',
      },
      globalaccelerator: {
        name: 'GlobalAccelerator',
      },
      comprehendmedical: {
        name: 'ComprehendMedical',
        cors: true,
      },
      kinesisanalyticsv2: {
        name: 'KinesisAnalyticsV2',
      },
      mediaconnect: {
        name: 'MediaConnect',
      },
      fsx: {
        name: 'FSx',
      },
      securityhub: {
        name: 'SecurityHub',
      },
      appmesh: {
        name: 'AppMesh',
        versions: ['2018-10-01*'],
      },
      licensemanager: {
        prefix: 'license-manager',
        name: 'LicenseManager',
      },
      kafka: {
        name: 'Kafka',
      },
      apigatewaymanagementapi: {
        name: 'ApiGatewayManagementApi',
      },
      apigatewayv2: {
        name: 'ApiGatewayV2',
      },
      docdb: {
        name: 'DocDB',
      },
      backup: {
        name: 'Backup',
      },
      worklink: {
        name: 'WorkLink',
      },
      textract: {
        name: 'Textract',
      },
      managedblockchain: {
        name: 'ManagedBlockchain',
      },
      mediapackagevod: {
        prefix: 'mediapackage-vod',
        name: 'MediaPackageVod',
      },
      groundstation: {
        name: 'GroundStation',
      },
      iotthingsgraph: {
        name: 'IoTThingsGraph',
      },
      iotevents: {
        name: 'IoTEvents',
      },
      ioteventsdata: {
        prefix: 'iotevents-data',
        name: 'IoTEventsData',
      },
      personalize: {
        name: 'Personalize',
        cors: true,
      },
      personalizeevents: {
        prefix: 'personalize-events',
        name: 'PersonalizeEvents',
        cors: true,
      },
      personalizeruntime: {
        prefix: 'personalize-runtime',
        name: 'PersonalizeRuntime',
        cors: true,
      },
      applicationinsights: {
        prefix: 'application-insights',
        name: 'ApplicationInsights',
      },
      servicequotas: {
        prefix: 'service-quotas',
        name: 'ServiceQuotas',
      },
      ec2instanceconnect: {
        prefix: 'ec2-instance-connect',
        name: 'EC2InstanceConnect',
      },
      eventbridge: {
        name: 'EventBridge',
      },
      lakeformation: {
        name: 'LakeFormation',
      },
      forecastservice: {
        prefix: 'forecast',
        name: 'ForecastService',
        cors: true,
      },
      forecastqueryservice: {
        prefix: 'forecastquery',
        name: 'ForecastQueryService',
        cors: true,
      },
      qldb: {
        name: 'QLDB',
      },
      qldbsession: {
        prefix: 'qldb-session',
        name: 'QLDBSession',
      },
      workmailmessageflow: {
        name: 'WorkMailMessageFlow',
      },
      codestarnotifications: {
        prefix: 'codestar-notifications',
        name: 'CodeStarNotifications',
      },
      savingsplans: {
        name: 'SavingsPlans',
      },
      sso: {
        name: 'SSO',
      },
      ssooidc: {
        prefix: 'sso-oidc',
        name: 'SSOOIDC',
      },
      marketplacecatalog: {
        prefix: 'marketplace-catalog',
        name: 'MarketplaceCatalog',
        cors: true,
      },
      dataexchange: {
        name: 'DataExchange',
      },
      sesv2: {
        name: 'SESV2',
      },
      migrationhubconfig: {
        prefix: 'migrationhub-config',
        name: 'MigrationHubConfig',
      },
      connectparticipant: {
        name: 'ConnectParticipant',
      },
      appconfig: {
        name: 'AppConfig',
      },
      iotsecuretunneling: {
        name: 'IoTSecureTunneling',
      },
      wafv2: {
        name: 'WAFV2',
      },
      elasticinference: {
        prefix: 'elastic-inference',
        name: 'ElasticInference',
      },
      imagebuilder: {
        name: 'Imagebuilder',
      },
      schemas: {
        name: 'Schemas',
      },
      accessanalyzer: {
        name: 'AccessAnalyzer',
      },
      codegurureviewer: {
        prefix: 'codeguru-reviewer',
        name: 'CodeGuruReviewer',
      },
      codeguruprofiler: {
        name: 'CodeGuruProfiler',
      },
      computeoptimizer: {
        prefix: 'compute-optimizer',
        name: 'ComputeOptimizer',
      },
      frauddetector: {
        name: 'FraudDetector',
      },
      kendra: {
        name: 'Kendra',
      },
      networkmanager: {
        name: 'NetworkManager',
      },
      outposts: {
        name: 'Outposts',
      },
      augmentedairuntime: {
        prefix: 'sagemaker-a2i-runtime',
        name: 'AugmentedAIRuntime',
      },
      ebs: {
        name: 'EBS',
      },
      kinesisvideosignalingchannels: {
        prefix: 'kinesis-video-signaling',
        name: 'KinesisVideoSignalingChannels',
        cors: true,
      },
      detective: {
        name: 'Detective',
      },
      codestarconnections: {
        prefix: 'codestar-connections',
        name: 'CodeStarconnections',
      },
      synthetics: {
        name: 'Synthetics',
      },
      iotsitewise: {
        name: 'IoTSiteWise',
      },
      macie2: {
        name: 'Macie2',
      },
      codeartifact: {
        name: 'CodeArtifact',
      },
      honeycode: {
        name: 'Honeycode',
      },
      ivs: {
        name: 'IVS',
      },
      braket: {
        name: 'Braket',
      },
      identitystore: {
        name: 'IdentityStore',
      },
      appflow: {
        name: 'Appflow',
      },
      redshiftdata: {
        prefix: 'redshift-data',
        name: 'RedshiftData',
      },
      ssoadmin: {
        prefix: 'sso-admin',
        name: 'SSOAdmin',
      },
      timestreamquery: {
        prefix: 'timestream-query',
        name: 'TimestreamQuery',
      },
      timestreamwrite: {
        prefix: 'timestream-write',
        name: 'TimestreamWrite',
      },
      s3outposts: {
        name: 'S3Outposts',
      },
      databrew: {
        name: 'DataBrew',
      },
      servicecatalogappregistry: {
        prefix: 'servicecatalog-appregistry',
        name: 'ServiceCatalogAppRegistry',
      },
      networkfirewall: {
        prefix: 'network-firewall',
        name: 'NetworkFirewall',
      },
      mwaa: {
        name: 'MWAA',
      },
      amplifybackend: {
        name: 'AmplifyBackend',
      },
      appintegrations: {
        name: 'AppIntegrations',
      },
      connectcontactlens: {
        prefix: 'connect-contact-lens',
        name: 'ConnectContactLens',
      },
      devopsguru: {
        prefix: 'devops-guru',
        name: 'DevOpsGuru',
      },
      ecrpublic: {
        prefix: 'ecr-public',
        name: 'ECRPUBLIC',
      },
      lookoutvision: {
        name: 'LookoutVision',
      },
      sagemakerfeaturestoreruntime: {
        prefix: 'sagemaker-featurestore-runtime',
        name: 'SageMakerFeatureStoreRuntime',
      },
      customerprofiles: {
        prefix: 'customer-profiles',
        name: 'CustomerProfiles',
      },
      auditmanager: {
        name: 'AuditManager',
      },
      emrcontainers: {
        prefix: 'emr-containers',
        name: 'EMRcontainers',
      },
      healthlake: {
        name: 'HealthLake',
      },
      sagemakeredge: {
        prefix: 'sagemaker-edge',
        name: 'SagemakerEdge',
      },
      amp: {
        name: 'Amp',
        cors: true,
      },
      greengrassv2: {
        name: 'GreengrassV2',
      },
      iotdeviceadvisor: {
        name: 'IotDeviceAdvisor',
      },
      iotfleethub: {
        name: 'IoTFleetHub',
      },
      iotwireless: {
        name: 'IoTWireless',
      },
      location: {
        name: 'Location',
        cors: true,
      },
      wellarchitected: {
        name: 'WellArchitected',
      },
      lexmodelsv2: {
        prefix: 'models.lex.v2',
        name: 'LexModelsV2',
      },
      lexruntimev2: {
        prefix: 'runtime.lex.v2',
        name: 'LexRuntimeV2',
        cors: true,
      },
      fis: {
        name: 'Fis',
      },
      lookoutmetrics: {
        name: 'LookoutMetrics',
      },
      mgn: {
        name: 'Mgn',
      },
      lookoutequipment: {
        name: 'LookoutEquipment',
      },
      nimble: {
        name: 'Nimble',
      },
      finspace: {
        name: 'Finspace',
      },
      finspacedata: {
        prefix: 'finspace-data',
        name: 'Finspacedata',
      },
      ssmcontacts: {
        prefix: 'ssm-contacts',
        name: 'SSMContacts',
      },
      ssmincidents: {
        prefix: 'ssm-incidents',
        name: 'SSMIncidents',
      },
      applicationcostprofiler: {
        name: 'ApplicationCostProfiler',
      },
      apprunner: {
        name: 'AppRunner',
      },
      proton: {
        name: 'Proton',
      },
      route53recoverycluster: {
        prefix: 'route53-recovery-cluster',
        name: 'Route53RecoveryCluster',
      },
      route53recoverycontrolconfig: {
        prefix: 'route53-recovery-control-config',
        name: 'Route53RecoveryControlConfig',
      },
      route53recoveryreadiness: {
        prefix: 'route53-recovery-readiness',
        name: 'Route53RecoveryReadiness',
      },
      chimesdkidentity: {
        prefix: 'chime-sdk-identity',
        name: 'ChimeSDKIdentity',
      },
      chimesdkmessaging: {
        prefix: 'chime-sdk-messaging',
        name: 'ChimeSDKMessaging',
      },
      snowdevicemanagement: {
        prefix: 'snow-device-management',
        name: 'SnowDeviceManagement',
      },
      memorydb: {
        name: 'MemoryDB',
      },
      opensearch: {
        name: 'OpenSearch',
      },
      kafkaconnect: {
        name: 'KafkaConnect',
      },
      voiceid: {
        prefix: 'voice-id',
        name: 'VoiceID',
      },
      wisdom: {
        name: 'Wisdom',
      },
      account: {
        name: 'Account',
      },
      cloudcontrol: {
        name: 'CloudControl',
      },
      grafana: {
        name: 'Grafana',
      },
      panorama: {
        name: 'Panorama',
      },
      chimesdkmeetings: {
        prefix: 'chime-sdk-meetings',
        name: 'ChimeSDKMeetings',
      },
      resiliencehub: {
        name: 'Resiliencehub',
      },
      migrationhubstrategy: {
        name: 'MigrationHubStrategy',
      },
      appconfigdata: {
        name: 'AppConfigData',
      },
      drs: {
        name: 'Drs',
      },
      migrationhubrefactorspaces: {
        prefix: 'migration-hub-refactor-spaces',
        name: 'MigrationHubRefactorSpaces',
      },
      evidently: {
        name: 'Evidently',
      },
      inspector2: {
        name: 'Inspector2',
      },
      rbin: {
        name: 'Rbin',
      },
      rum: {
        name: 'RUM',
      },
      backupgateway: {
        prefix: 'backup-gateway',
        name: 'BackupGateway',
      },
      iottwinmaker: {
        name: 'IoTTwinMaker',
      },
      workspacesweb: {
        prefix: 'workspaces-web',
        name: 'WorkSpacesWeb',
      },
      amplifyuibuilder: {
        name: 'AmplifyUIBuilder',
      },
      keyspaces: {
        name: 'Keyspaces',
      },
      billingconductor: {
        name: 'Billingconductor',
      },
      pinpointsmsvoicev2: {
        prefix: 'pinpoint-sms-voice-v2',
        name: 'PinpointSMSVoiceV2',
      },
      ivschat: {
        name: 'Ivschat',
      },
      chimesdkmediapipelines: {
        prefix: 'chime-sdk-media-pipelines',
        name: 'ChimeSDKMediaPipelines',
      },
      emrserverless: {
        prefix: 'emr-serverless',
        name: 'EMRServerless',
      },
      m2: {
        name: 'M2',
      },
      connectcampaigns: {
        name: 'ConnectCampaigns',
      },
      redshiftserverless: {
        prefix: 'redshift-serverless',
        name: 'RedshiftServerless',
      },
      rolesanywhere: {
        name: 'RolesAnywhere',
      },
      licensemanagerusersubscriptions: {
        prefix: 'license-manager-user-subscriptions',
        name: 'LicenseManagerUserSubscriptions',
      },
      backupstorage: {
        name: 'BackupStorage',
      },
      privatenetworks: {
        name: 'PrivateNetworks',
      },
      supportapp: {
        prefix: 'support-app',
        name: 'SupportApp',
      },
      controltower: {
        name: 'ControlTower',
      },
      iotfleetwise: {
        name: 'IoTFleetWise',
      },
      migrationhuborchestrator: {
        name: 'MigrationHubOrchestrator',
      },
      connectcases: {
        name: 'ConnectCases',
      },
      resourceexplorer2: {
        prefix: 'resource-explorer-2',
        name: 'ResourceExplorer2',
      },
      scheduler: {
        name: 'Scheduler',
      },
      chimesdkvoice: {
        prefix: 'chime-sdk-voice',
        name: 'ChimeSDKVoice',
      },
      iotroborunner: {
        prefix: 'iot-roborunner',
        name: 'IoTRoboRunner',
      },
      ssmsap: {
        prefix: 'ssm-sap',
        name: 'SsmSap',
      },
      oam: {
        name: 'OAM',
      },
      arczonalshift: {
        prefix: 'arc-zonal-shift',
        name: 'ARCZonalShift',
      },
      omics: {
        name: 'Omics',
      },
      opensearchserverless: {
        name: 'OpenSearchServerless',
      },
      securitylake: {
        name: 'SecurityLake',
      },
      simspaceweaver: {
        name: 'SimSpaceWeaver',
      },
      docdbelastic: {
        prefix: 'docdb-elastic',
        name: 'DocDBElastic',
      },
      sagemakergeospatial: {
        prefix: 'sagemaker-geospatial',
        name: 'SageMakerGeospatial',
      },
      codecatalyst: {
        name: 'CodeCatalyst',
      },
      pipes: {
        name: 'Pipes',
      },
      sagemakermetrics: {
        prefix: 'sagemaker-metrics',
        name: 'SageMakerMetrics',
      },
      kinesisvideowebrtcstorage: {
        prefix: 'kinesis-video-webrtc-storage',
        name: 'KinesisVideoWebRTCStorage',
      },
      licensemanagerlinuxsubscriptions: {
        prefix: 'license-manager-linux-subscriptions',
        name: 'LicenseManagerLinuxSubscriptions',
      },
      kendraranking: {
        prefix: 'kendra-ranking',
        name: 'KendraRanking',
      },
      cleanrooms: {
        name: 'CleanRooms',
      },
      cloudtraildata: {
        prefix: 'cloudtrail-data',
        name: 'CloudTrailData',
      },
      tnb: {
        name: 'Tnb',
      },
      internetmonitor: {
        name: 'InternetMonitor',
      },
      ivsrealtime: {
        prefix: 'ivs-realtime',
        name: 'IVSRealTime',
      },
      vpclattice: {
        prefix: 'vpc-lattice',
        name: 'VPCLattice',
      },
      osis: {
        name: 'OSIS',
      },
      mediapackagev2: {
        name: 'MediaPackageV2',
      },
      paymentcryptography: {
        prefix: 'payment-cryptography',
        name: 'PaymentCryptography',
      },
      paymentcryptographydata: {
        prefix: 'payment-cryptography-data',
        name: 'PaymentCryptographyData',
      },
      codegurusecurity: {
        prefix: 'codeguru-security',
        name: 'CodeGuruSecurity',
      },
      verifiedpermissions: {
        name: 'VerifiedPermissions',
      },
      appfabric: {
        name: 'AppFabric',
      },
      medicalimaging: {
        prefix: 'medical-imaging',
        name: 'MedicalImaging',
      },
      entityresolution: {
        name: 'EntityResolution',
      },
      managedblockchainquery: {
        prefix: 'managedblockchain-query',
        name: 'ManagedBlockchainQuery',
      },
      neptunedata: {
        name: 'Neptunedata',
      },
      pcaconnectorad: {
        prefix: 'pca-connector-ad',
        name: 'PcaConnectorAd',
      },
      bedrock: {
        name: 'Bedrock',
      },
      bedrockruntime: {
        prefix: 'bedrock-runtime',
        name: 'BedrockRuntime',
      },
      datazone: {
        name: 'DataZone',
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/api.js
var require_api = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/model/api.js'(exports, module2) {
    var Collection = require_collection();
    var Operation = require_operation();
    var Shape = require_shape();
    var Paginator = require_paginator();
    var ResourceWaiter = require_resource_waiter();
    var metadata = require_metadata();
    var util = require_util();
    var property = util.property;
    var memoizedProperty = util.memoizedProperty;
    function Api(api, options) {
      var self = this;
      api = api || {};
      options = options || {};
      options.api = this;
      api.metadata = api.metadata || {};
      var serviceIdentifier = options.serviceIdentifier;
      delete options.serviceIdentifier;
      property(this, 'isApi', true, false);
      property(this, 'apiVersion', api.metadata.apiVersion);
      property(this, 'endpointPrefix', api.metadata.endpointPrefix);
      property(this, 'signingName', api.metadata.signingName);
      property(this, 'globalEndpoint', api.metadata.globalEndpoint);
      property(this, 'signatureVersion', api.metadata.signatureVersion);
      property(this, 'jsonVersion', api.metadata.jsonVersion);
      property(this, 'targetPrefix', api.metadata.targetPrefix);
      property(this, 'protocol', api.metadata.protocol);
      property(this, 'timestampFormat', api.metadata.timestampFormat);
      property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
      property(this, 'abbreviation', api.metadata.serviceAbbreviation);
      property(this, 'fullName', api.metadata.serviceFullName);
      property(this, 'serviceId', api.metadata.serviceId);
      if (serviceIdentifier && metadata[serviceIdentifier]) {
        property(this, 'xmlNoDefaultLists', metadata[serviceIdentifier].xmlNoDefaultLists, false);
      }
      memoizedProperty(this, 'className', function () {
        var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
        if (!name) return null;
        name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
        if (name === 'ElasticLoadBalancing') name = 'ELB';
        return name;
      });
      function addEndpointOperation(name, operation) {
        if (operation.endpointoperation === true) {
          property(self, 'endpointOperation', util.string.lowerFirst(name));
        }
        if (operation.endpointdiscovery && !self.hasRequiredEndpointDiscovery) {
          property(self, 'hasRequiredEndpointDiscovery', operation.endpointdiscovery.required === true);
        }
      }
      property(
        this,
        'operations',
        new Collection(
          api.operations,
          options,
          function (name, operation) {
            return new Operation(name, operation, options);
          },
          util.string.lowerFirst,
          addEndpointOperation
        )
      );
      property(
        this,
        'shapes',
        new Collection(api.shapes, options, function (name, shape) {
          return Shape.create(shape, options);
        })
      );
      property(
        this,
        'paginators',
        new Collection(api.paginators, options, function (name, paginator) {
          return new Paginator(name, paginator, options);
        })
      );
      property(
        this,
        'waiters',
        new Collection(
          api.waiters,
          options,
          function (name, waiter) {
            return new ResourceWaiter(name, waiter, options);
          },
          util.string.lowerFirst
        )
      );
      if (options.documentation) {
        property(this, 'documentation', api.documentation);
        property(this, 'documentationUrl', api.documentationUrl);
      }
      property(this, 'awsQueryCompatible', api.metadata.awsQueryCompatible);
    }
    module2.exports = Api;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/api_loader.js
var require_api_loader = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/api_loader.js'(exports, module2) {
    function apiLoader(svc, version) {
      if (!apiLoader.services.hasOwnProperty(svc)) {
        throw new Error('InvalidService: Failed to load api for ' + svc);
      }
      return apiLoader.services[svc][version];
    }
    apiLoader.services = {};
    module2.exports = apiLoader;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js
var require_LRU = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var LinkedListNode = (function () {
      function LinkedListNode2(key, value) {
        this.key = key;
        this.value = value;
      }
      return LinkedListNode2;
    })();
    var LRUCache = (function () {
      function LRUCache2(size) {
        this.nodeMap = {};
        this.size = 0;
        if (typeof size !== 'number' || size < 1) {
          throw new Error('Cache size can only be positive number');
        }
        this.sizeLimit = size;
      }
      Object.defineProperty(LRUCache2.prototype, 'length', {
        get: function () {
          return this.size;
        },
        enumerable: true,
        configurable: true,
      });
      LRUCache2.prototype.prependToList = function (node) {
        if (!this.headerNode) {
          this.tailNode = node;
        } else {
          this.headerNode.prev = node;
          node.next = this.headerNode;
        }
        this.headerNode = node;
        this.size++;
      };
      LRUCache2.prototype.removeFromTail = function () {
        if (!this.tailNode) {
          return void 0;
        }
        var node = this.tailNode;
        var prevNode = node.prev;
        if (prevNode) {
          prevNode.next = void 0;
        }
        node.prev = void 0;
        this.tailNode = prevNode;
        this.size--;
        return node;
      };
      LRUCache2.prototype.detachFromList = function (node) {
        if (this.headerNode === node) {
          this.headerNode = node.next;
        }
        if (this.tailNode === node) {
          this.tailNode = node.prev;
        }
        if (node.prev) {
          node.prev.next = node.next;
        }
        if (node.next) {
          node.next.prev = node.prev;
        }
        node.next = void 0;
        node.prev = void 0;
        this.size--;
      };
      LRUCache2.prototype.get = function (key) {
        if (this.nodeMap[key]) {
          var node = this.nodeMap[key];
          this.detachFromList(node);
          this.prependToList(node);
          return node.value;
        }
      };
      LRUCache2.prototype.remove = function (key) {
        if (this.nodeMap[key]) {
          var node = this.nodeMap[key];
          this.detachFromList(node);
          delete this.nodeMap[key];
        }
      };
      LRUCache2.prototype.put = function (key, value) {
        if (this.nodeMap[key]) {
          this.remove(key);
        } else if (this.size === this.sizeLimit) {
          var tailNode = this.removeFromTail();
          var key_1 = tailNode.key;
          delete this.nodeMap[key_1];
        }
        var newNode = new LinkedListNode(key, value);
        this.nodeMap[key] = newNode;
        this.prependToList(newNode);
      };
      LRUCache2.prototype.empty = function () {
        var keys = Object.keys(this.nodeMap);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var node = this.nodeMap[key];
          this.detachFromList(node);
          delete this.nodeMap[key];
        }
      };
      return LRUCache2;
    })();
    exports.LRUCache = LRUCache;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/vendor/endpoint-cache/index.js
var require_endpoint_cache = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/vendor/endpoint-cache/index.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var LRU_1 = require_LRU();
    var CACHE_SIZE = 1e3;
    var EndpointCache = (function () {
      function EndpointCache2(maxSize) {
        if (maxSize === void 0) {
          maxSize = CACHE_SIZE;
        }
        this.maxSize = maxSize;
        this.cache = new LRU_1.LRUCache(maxSize);
      }
      Object.defineProperty(EndpointCache2.prototype, 'size', {
        get: function () {
          return this.cache.length;
        },
        enumerable: true,
        configurable: true,
      });
      EndpointCache2.prototype.put = function (key, value) {
        var keyString = typeof key !== 'string' ? EndpointCache2.getKeyString(key) : key;
        var endpointRecord = this.populateValue(value);
        this.cache.put(keyString, endpointRecord);
      };
      EndpointCache2.prototype.get = function (key) {
        var keyString = typeof key !== 'string' ? EndpointCache2.getKeyString(key) : key;
        var now = Date.now();
        var records = this.cache.get(keyString);
        if (records) {
          for (var i = records.length - 1; i >= 0; i--) {
            var record = records[i];
            if (record.Expire < now) {
              records.splice(i, 1);
            }
          }
          if (records.length === 0) {
            this.cache.remove(keyString);
            return void 0;
          }
        }
        return records;
      };
      EndpointCache2.getKeyString = function (key) {
        var identifiers = [];
        var identifierNames = Object.keys(key).sort();
        for (var i = 0; i < identifierNames.length; i++) {
          var identifierName = identifierNames[i];
          if (key[identifierName] === void 0) continue;
          identifiers.push(key[identifierName]);
        }
        return identifiers.join(' ');
      };
      EndpointCache2.prototype.populateValue = function (endpoints) {
        var now = Date.now();
        return endpoints.map(function (endpoint) {
          return {
            Address: endpoint.Address || '',
            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1e3,
          };
        });
      };
      EndpointCache2.prototype.empty = function () {
        this.cache.empty();
      };
      EndpointCache2.prototype.remove = function (key) {
        var keyString = typeof key !== 'string' ? EndpointCache2.getKeyString(key) : key;
        this.cache.remove(keyString);
      };
      return EndpointCache2;
    })();
    exports.EndpointCache = EndpointCache;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/sequential_executor.js
var require_sequential_executor = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/sequential_executor.js'(exports, module2) {
    var AWS3 = require_core();
    AWS3.SequentialExecutor = AWS3.util.inherit({
      constructor: function SequentialExecutor() {
        this._events = {};
      },
      listeners: function listeners(eventName) {
        return this._events[eventName] ? this._events[eventName].slice(0) : [];
      },
      on: function on(eventName, listener, toHead) {
        if (this._events[eventName]) {
          toHead ? this._events[eventName].unshift(listener) : this._events[eventName].push(listener);
        } else {
          this._events[eventName] = [listener];
        }
        return this;
      },
      onAsync: function onAsync(eventName, listener, toHead) {
        listener._isAsync = true;
        return this.on(eventName, listener, toHead);
      },
      removeListener: function removeListener(eventName, listener) {
        var listeners = this._events[eventName];
        if (listeners) {
          var length = listeners.length;
          var position = -1;
          for (var i = 0; i < length; ++i) {
            if (listeners[i] === listener) {
              position = i;
            }
          }
          if (position > -1) {
            listeners.splice(position, 1);
          }
        }
        return this;
      },
      removeAllListeners: function removeAllListeners(eventName) {
        if (eventName) {
          delete this._events[eventName];
        } else {
          this._events = {};
        }
        return this;
      },
      emit: function emit(eventName, eventArgs, doneCallback) {
        if (!doneCallback) doneCallback = function () {};
        var listeners = this.listeners(eventName);
        var count = listeners.length;
        this.callListeners(listeners, eventArgs, doneCallback);
        return count > 0;
      },
      callListeners: function callListeners(listeners, args, doneCallback, prevError) {
        var self = this;
        var error = prevError || null;
        function callNextListener(err) {
          if (err) {
            error = AWS3.util.error(error || new Error(), err);
            if (self._haltHandlersOnError) {
              return doneCallback.call(self, error);
            }
          }
          self.callListeners(listeners, args, doneCallback, error);
        }
        while (listeners.length > 0) {
          var listener = listeners.shift();
          if (listener._isAsync) {
            listener.apply(self, args.concat([callNextListener]));
            return;
          } else {
            try {
              listener.apply(self, args);
            } catch (err) {
              error = AWS3.util.error(error || new Error(), err);
            }
            if (error && self._haltHandlersOnError) {
              doneCallback.call(self, error);
              return;
            }
          }
        }
        doneCallback.call(self, error);
      },
      addListeners: function addListeners(listeners) {
        var self = this;
        if (listeners._events) listeners = listeners._events;
        AWS3.util.each(listeners, function (event, callbacks) {
          if (typeof callbacks === 'function') callbacks = [callbacks];
          AWS3.util.arrayEach(callbacks, function (callback) {
            self.on(event, callback);
          });
        });
        return self;
      },
      addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
        this[name] = callback;
        this.addListener(eventName, callback, toHead);
        return this;
      },
      addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
        callback._isAsync = true;
        return this.addNamedListener(name, eventName, callback, toHead);
      },
      addNamedListeners: function addNamedListeners(callback) {
        var self = this;
        callback(
          function () {
            self.addNamedListener.apply(self, arguments);
          },
          function () {
            self.addNamedAsyncListener.apply(self, arguments);
          }
        );
        return this;
      },
    });
    AWS3.SequentialExecutor.prototype.addListener = AWS3.SequentialExecutor.prototype.on;
    module2.exports = AWS3.SequentialExecutor;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/region_config_data.json
var require_region_config_data = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/region_config_data.json'(exports, module2) {
    module2.exports = {
      rules: {
        '*/*': {
          endpoint: '{service}.{region}.amazonaws.com',
        },
        'cn-*/*': {
          endpoint: '{service}.{region}.amazonaws.com.cn',
        },
        'us-iso-*/*': 'usIso',
        'us-isob-*/*': 'usIsob',
        '*/budgets': 'globalSSL',
        '*/cloudfront': 'globalSSL',
        '*/sts': 'globalSSL',
        '*/importexport': {
          endpoint: '{service}.amazonaws.com',
          signatureVersion: 'v2',
          globalEndpoint: true,
        },
        '*/route53': 'globalSSL',
        'cn-*/route53': {
          endpoint: '{service}.amazonaws.com.cn',
          globalEndpoint: true,
          signingRegion: 'cn-northwest-1',
        },
        'us-gov-*/route53': 'globalGovCloud',
        'us-iso-*/route53': {
          endpoint: '{service}.c2s.ic.gov',
          globalEndpoint: true,
          signingRegion: 'us-iso-east-1',
        },
        'us-isob-*/route53': {
          endpoint: '{service}.sc2s.sgov.gov',
          globalEndpoint: true,
          signingRegion: 'us-isob-east-1',
        },
        '*/waf': 'globalSSL',
        '*/iam': 'globalSSL',
        'cn-*/iam': {
          endpoint: '{service}.cn-north-1.amazonaws.com.cn',
          globalEndpoint: true,
          signingRegion: 'cn-north-1',
        },
        'us-iso-*/iam': {
          endpoint: '{service}.us-iso-east-1.c2s.ic.gov',
          globalEndpoint: true,
          signingRegion: 'us-iso-east-1',
        },
        'us-gov-*/iam': 'globalGovCloud',
        '*/ce': {
          endpoint: '{service}.us-east-1.amazonaws.com',
          globalEndpoint: true,
          signingRegion: 'us-east-1',
        },
        'cn-*/ce': {
          endpoint: '{service}.cn-northwest-1.amazonaws.com.cn',
          globalEndpoint: true,
          signingRegion: 'cn-northwest-1',
        },
        'us-gov-*/sts': {
          endpoint: '{service}.{region}.amazonaws.com',
        },
        'us-gov-west-1/s3': 's3signature',
        'us-west-1/s3': 's3signature',
        'us-west-2/s3': 's3signature',
        'eu-west-1/s3': 's3signature',
        'ap-southeast-1/s3': 's3signature',
        'ap-southeast-2/s3': 's3signature',
        'ap-northeast-1/s3': 's3signature',
        'sa-east-1/s3': 's3signature',
        'us-east-1/s3': {
          endpoint: '{service}.amazonaws.com',
          signatureVersion: 's3',
        },
        'us-east-1/sdb': {
          endpoint: '{service}.amazonaws.com',
          signatureVersion: 'v2',
        },
        '*/sdb': {
          endpoint: '{service}.{region}.amazonaws.com',
          signatureVersion: 'v2',
        },
        '*/resource-explorer-2': 'dualstackByDefault',
        '*/kendra-ranking': 'dualstackByDefault',
        '*/internetmonitor': 'dualstackByDefault',
        '*/codecatalyst': 'globalDualstackByDefault',
      },
      fipsRules: {
        '*/*': 'fipsStandard',
        'us-gov-*/*': 'fipsStandard',
        'us-iso-*/*': {
          endpoint: '{service}-fips.{region}.c2s.ic.gov',
        },
        'us-iso-*/dms': 'usIso',
        'us-isob-*/*': {
          endpoint: '{service}-fips.{region}.sc2s.sgov.gov',
        },
        'us-isob-*/dms': 'usIsob',
        'cn-*/*': {
          endpoint: '{service}-fips.{region}.amazonaws.com.cn',
        },
        '*/api.ecr': 'fips.api.ecr',
        '*/api.sagemaker': 'fips.api.sagemaker',
        '*/batch': 'fipsDotPrefix',
        '*/eks': 'fipsDotPrefix',
        '*/models.lex': 'fips.models.lex',
        '*/runtime.lex': 'fips.runtime.lex',
        '*/runtime.sagemaker': {
          endpoint: 'runtime-fips.sagemaker.{region}.amazonaws.com',
        },
        '*/iam': 'fipsWithoutRegion',
        '*/route53': 'fipsWithoutRegion',
        '*/transcribe': 'fipsDotPrefix',
        '*/waf': 'fipsWithoutRegion',
        'us-gov-*/transcribe': 'fipsDotPrefix',
        'us-gov-*/api.ecr': 'fips.api.ecr',
        'us-gov-*/api.sagemaker': 'fips.api.sagemaker',
        'us-gov-*/models.lex': 'fips.models.lex',
        'us-gov-*/runtime.lex': 'fips.runtime.lex',
        'us-gov-*/acm-pca': 'fipsWithServiceOnly',
        'us-gov-*/batch': 'fipsWithServiceOnly',
        'us-gov-*/cloudformation': 'fipsWithServiceOnly',
        'us-gov-*/config': 'fipsWithServiceOnly',
        'us-gov-*/eks': 'fipsWithServiceOnly',
        'us-gov-*/elasticmapreduce': 'fipsWithServiceOnly',
        'us-gov-*/identitystore': 'fipsWithServiceOnly',
        'us-gov-*/dynamodb': 'fipsWithServiceOnly',
        'us-gov-*/elasticloadbalancing': 'fipsWithServiceOnly',
        'us-gov-*/guardduty': 'fipsWithServiceOnly',
        'us-gov-*/monitoring': 'fipsWithServiceOnly',
        'us-gov-*/resource-groups': 'fipsWithServiceOnly',
        'us-gov-*/runtime.sagemaker': 'fipsWithServiceOnly',
        'us-gov-*/servicecatalog-appregistry': 'fipsWithServiceOnly',
        'us-gov-*/servicequotas': 'fipsWithServiceOnly',
        'us-gov-*/ssm': 'fipsWithServiceOnly',
        'us-gov-*/sts': 'fipsWithServiceOnly',
        'us-gov-*/support': 'fipsWithServiceOnly',
        'us-gov-west-1/states': 'fipsWithServiceOnly',
        'us-iso-east-1/elasticfilesystem': {
          endpoint: 'elasticfilesystem-fips.{region}.c2s.ic.gov',
        },
        'us-gov-west-1/organizations': 'fipsWithServiceOnly',
        'us-gov-west-1/route53': {
          endpoint: 'route53.us-gov.amazonaws.com',
        },
        '*/resource-explorer-2': 'fipsDualstackByDefault',
        '*/kendra-ranking': 'dualstackByDefault',
        '*/internetmonitor': 'dualstackByDefault',
        '*/codecatalyst': 'fipsGlobalDualstackByDefault',
      },
      dualstackRules: {
        '*/*': {
          endpoint: '{service}.{region}.api.aws',
        },
        'cn-*/*': {
          endpoint: '{service}.{region}.api.amazonwebservices.com.cn',
        },
        '*/s3': 'dualstackLegacy',
        'cn-*/s3': 'dualstackLegacyCn',
        '*/s3-control': 'dualstackLegacy',
        'cn-*/s3-control': 'dualstackLegacyCn',
        'ap-south-1/ec2': 'dualstackLegacyEc2',
        'eu-west-1/ec2': 'dualstackLegacyEc2',
        'sa-east-1/ec2': 'dualstackLegacyEc2',
        'us-east-1/ec2': 'dualstackLegacyEc2',
        'us-east-2/ec2': 'dualstackLegacyEc2',
        'us-west-2/ec2': 'dualstackLegacyEc2',
      },
      dualstackFipsRules: {
        '*/*': {
          endpoint: '{service}-fips.{region}.api.aws',
        },
        'cn-*/*': {
          endpoint: '{service}-fips.{region}.api.amazonwebservices.com.cn',
        },
        '*/s3': 'dualstackFipsLegacy',
        'cn-*/s3': 'dualstackFipsLegacyCn',
        '*/s3-control': 'dualstackFipsLegacy',
        'cn-*/s3-control': 'dualstackFipsLegacyCn',
      },
      patterns: {
        globalSSL: {
          endpoint: 'https://{service}.amazonaws.com',
          globalEndpoint: true,
          signingRegion: 'us-east-1',
        },
        globalGovCloud: {
          endpoint: '{service}.us-gov.amazonaws.com',
          globalEndpoint: true,
          signingRegion: 'us-gov-west-1',
        },
        s3signature: {
          endpoint: '{service}.{region}.amazonaws.com',
          signatureVersion: 's3',
        },
        usIso: {
          endpoint: '{service}.{region}.c2s.ic.gov',
        },
        usIsob: {
          endpoint: '{service}.{region}.sc2s.sgov.gov',
        },
        fipsStandard: {
          endpoint: '{service}-fips.{region}.amazonaws.com',
        },
        fipsDotPrefix: {
          endpoint: 'fips.{service}.{region}.amazonaws.com',
        },
        fipsWithoutRegion: {
          endpoint: '{service}-fips.amazonaws.com',
        },
        'fips.api.ecr': {
          endpoint: 'ecr-fips.{region}.amazonaws.com',
        },
        'fips.api.sagemaker': {
          endpoint: 'api-fips.sagemaker.{region}.amazonaws.com',
        },
        'fips.models.lex': {
          endpoint: 'models-fips.lex.{region}.amazonaws.com',
        },
        'fips.runtime.lex': {
          endpoint: 'runtime-fips.lex.{region}.amazonaws.com',
        },
        fipsWithServiceOnly: {
          endpoint: '{service}.{region}.amazonaws.com',
        },
        dualstackLegacy: {
          endpoint: '{service}.dualstack.{region}.amazonaws.com',
        },
        dualstackLegacyCn: {
          endpoint: '{service}.dualstack.{region}.amazonaws.com.cn',
        },
        dualstackFipsLegacy: {
          endpoint: '{service}-fips.dualstack.{region}.amazonaws.com',
        },
        dualstackFipsLegacyCn: {
          endpoint: '{service}-fips.dualstack.{region}.amazonaws.com.cn',
        },
        dualstackLegacyEc2: {
          endpoint: 'api.ec2.{region}.aws',
        },
        dualstackByDefault: {
          endpoint: '{service}.{region}.api.aws',
        },
        fipsDualstackByDefault: {
          endpoint: '{service}-fips.{region}.api.aws',
        },
        globalDualstackByDefault: {
          endpoint: '{service}.global.api.aws',
        },
        fipsGlobalDualstackByDefault: {
          endpoint: '{service}-fips.global.api.aws',
        },
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/region_config.js
var require_region_config = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/region_config.js'(exports, module2) {
    var util = require_util();
    var regionConfig = require_region_config_data();
    function generateRegionPrefix(region) {
      if (!region) return null;
      var parts = region.split('-');
      if (parts.length < 3) return null;
      return parts.slice(0, parts.length - 2).join('-') + '-*';
    }
    function derivedKeys(service) {
      var region = service.config.region;
      var regionPrefix = generateRegionPrefix(region);
      var endpointPrefix = service.api.endpointPrefix;
      return [
        [region, endpointPrefix],
        [regionPrefix, endpointPrefix],
        [region, '*'],
        [regionPrefix, '*'],
        ['*', endpointPrefix],
        [region, 'internal-*'],
        ['*', '*'],
      ].map(function (item) {
        return item[0] && item[1] ? item.join('/') : null;
      });
    }
    function applyConfig(service, config) {
      util.each(config, function (key, value) {
        if (key === 'globalEndpoint') return;
        if (service.config[key] === void 0 || service.config[key] === null) {
          service.config[key] = value;
        }
      });
    }
    function configureEndpoint(service) {
      var keys = derivedKeys(service);
      var useFipsEndpoint = service.config.useFipsEndpoint;
      var useDualstackEndpoint = service.config.useDualstackEndpoint;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!key) continue;
        var rules = useFipsEndpoint
          ? useDualstackEndpoint
            ? regionConfig.dualstackFipsRules
            : regionConfig.fipsRules
          : useDualstackEndpoint
          ? regionConfig.dualstackRules
          : regionConfig.rules;
        if (Object.prototype.hasOwnProperty.call(rules, key)) {
          var config = rules[key];
          if (typeof config === 'string') {
            config = regionConfig.patterns[config];
          }
          service.isGlobalEndpoint = !!config.globalEndpoint;
          if (config.signingRegion) {
            service.signingRegion = config.signingRegion;
          }
          if (!config.signatureVersion) {
            config.signatureVersion = 'v4';
          }
          var useBearer = (service.api && service.api.signatureVersion) === 'bearer';
          applyConfig(
            service,
            Object.assign({}, config, { signatureVersion: useBearer ? 'bearer' : config.signatureVersion })
          );
          return;
        }
      }
    }
    function getEndpointSuffix(region) {
      var regionRegexes = {
        '^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$': 'amazonaws.com',
        '^cn\\-\\w+\\-\\d+$': 'amazonaws.com.cn',
        '^us\\-gov\\-\\w+\\-\\d+$': 'amazonaws.com',
        '^us\\-iso\\-\\w+\\-\\d+$': 'c2s.ic.gov',
        '^us\\-isob\\-\\w+\\-\\d+$': 'sc2s.sgov.gov',
      };
      var defaultSuffix = 'amazonaws.com';
      var regexes = Object.keys(regionRegexes);
      for (var i = 0; i < regexes.length; i++) {
        var regionPattern = RegExp(regexes[i]);
        var dnsSuffix = regionRegexes[regexes[i]];
        if (regionPattern.test(region)) return dnsSuffix;
      }
      return defaultSuffix;
    }
    module2.exports = {
      configureEndpoint,
      getEndpointSuffix,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/region/utils.js
var require_utils = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/region/utils.js'(exports, module2) {
    function isFipsRegion(region) {
      return typeof region === 'string' && (region.startsWith('fips-') || region.endsWith('-fips'));
    }
    function isGlobalRegion(region) {
      return typeof region === 'string' && ['aws-global', 'aws-us-gov-global'].includes(region);
    }
    function getRealRegion(region) {
      return ['fips-aws-global', 'aws-fips', 'aws-global'].includes(region)
        ? 'us-east-1'
        : ['fips-aws-us-gov-global', 'aws-us-gov-global'].includes(region)
        ? 'us-gov-west-1'
        : region.replace(/fips-(dkr-|prod-)?|-fips/, '');
    }
    module2.exports = {
      isFipsRegion,
      isGlobalRegion,
      getRealRegion,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/service.js
var require_service = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/service.js'(exports, module2) {
    var AWS3 = require_core();
    var Api = require_api();
    var regionConfig = require_region_config();
    var inherit = AWS3.util.inherit;
    var clientCount = 0;
    var region_utils = require_utils();
    AWS3.Service = inherit({
      constructor: function Service(config) {
        if (!this.loadServiceClass) {
          throw AWS3.util.error(new Error(), "Service must be constructed with `new' operator");
        }
        if (config) {
          if (config.region) {
            var region = config.region;
            if (region_utils.isFipsRegion(region)) {
              config.region = region_utils.getRealRegion(region);
              config.useFipsEndpoint = true;
            }
            if (region_utils.isGlobalRegion(region)) {
              config.region = region_utils.getRealRegion(region);
            }
          }
          if (typeof config.useDualstack === 'boolean' && typeof config.useDualstackEndpoint !== 'boolean') {
            config.useDualstackEndpoint = config.useDualstack;
          }
        }
        var ServiceClass = this.loadServiceClass(config || {});
        if (ServiceClass) {
          var originalConfig = AWS3.util.copy(config);
          var svc = new ServiceClass(config);
          Object.defineProperty(svc, '_originalConfig', {
            get: function () {
              return originalConfig;
            },
            enumerable: false,
            configurable: true,
          });
          svc._clientId = ++clientCount;
          return svc;
        }
        this.initialize(config);
      },
      initialize: function initialize(config) {
        var svcConfig = AWS3.config[this.serviceIdentifier];
        this.config = new AWS3.Config(AWS3.config);
        if (svcConfig) this.config.update(svcConfig, true);
        if (config) this.config.update(config, true);
        this.validateService();
        if (!this.config.endpoint) regionConfig.configureEndpoint(this);
        this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
        this.setEndpoint(this.config.endpoint);
        AWS3.SequentialExecutor.call(this);
        AWS3.Service.addDefaultMonitoringListeners(this);
        if ((this.config.clientSideMonitoring || AWS3.Service._clientSideMonitoring) && this.publisher) {
          var publisher = this.publisher;
          this.addNamedListener('PUBLISH_API_CALL', 'apiCall', function PUBLISH_API_CALL(event) {
            process.nextTick(function () {
              publisher.eventHandler(event);
            });
          });
          this.addNamedListener('PUBLISH_API_ATTEMPT', 'apiCallAttempt', function PUBLISH_API_ATTEMPT(event) {
            process.nextTick(function () {
              publisher.eventHandler(event);
            });
          });
        }
      },
      validateService: function validateService() {},
      loadServiceClass: function loadServiceClass(serviceConfig) {
        var config = serviceConfig;
        if (!AWS3.util.isEmpty(this.api)) {
          return null;
        } else if (config.apiConfig) {
          return AWS3.Service.defineServiceApi(this.constructor, config.apiConfig);
        } else if (!this.constructor.services) {
          return null;
        } else {
          config = new AWS3.Config(AWS3.config);
          config.update(serviceConfig, true);
          var version = config.apiVersions[this.constructor.serviceIdentifier];
          version = version || config.apiVersion;
          return this.getLatestServiceClass(version);
        }
      },
      getLatestServiceClass: function getLatestServiceClass(version) {
        version = this.getLatestServiceVersion(version);
        if (this.constructor.services[version] === null) {
          AWS3.Service.defineServiceApi(this.constructor, version);
        }
        return this.constructor.services[version];
      },
      getLatestServiceVersion: function getLatestServiceVersion(version) {
        if (!this.constructor.services || this.constructor.services.length === 0) {
          throw new Error('No services defined on ' + this.constructor.serviceIdentifier);
        }
        if (!version) {
          version = 'latest';
        } else if (AWS3.util.isType(version, Date)) {
          version = AWS3.util.date.iso8601(version).split('T')[0];
        }
        if (Object.hasOwnProperty(this.constructor.services, version)) {
          return version;
        }
        var keys = Object.keys(this.constructor.services).sort();
        var selectedVersion = null;
        for (var i = keys.length - 1; i >= 0; i--) {
          if (keys[i][keys[i].length - 1] !== '*') {
            selectedVersion = keys[i];
          }
          if (keys[i].substr(0, 10) <= version) {
            return selectedVersion;
          }
        }
        throw new Error(
          'Could not find ' +
            this.constructor.serviceIdentifier +
            ' API to satisfy version constraint `' +
            version +
            "'"
        );
      },
      api: {},
      defaultRetryCount: 3,
      customizeRequests: function customizeRequests(callback) {
        if (!callback) {
          this.customRequestHandler = null;
        } else if (typeof callback === 'function') {
          this.customRequestHandler = callback;
        } else {
          throw new Error("Invalid callback type '" + typeof callback + "' provided in customizeRequests");
        }
      },
      makeRequest: function makeRequest(operation, params, callback) {
        if (typeof params === 'function') {
          callback = params;
          params = null;
        }
        params = params || {};
        if (this.config.params) {
          var rules = this.api.operations[operation];
          if (rules) {
            params = AWS3.util.copy(params);
            AWS3.util.each(this.config.params, function (key, value) {
              if (rules.input.members[key]) {
                if (params[key] === void 0 || params[key] === null) {
                  params[key] = value;
                }
              }
            });
          }
        }
        var request = new AWS3.Request(this, operation, params);
        this.addAllRequestListeners(request);
        this.attachMonitoringEmitter(request);
        if (callback) request.send(callback);
        return request;
      },
      makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
        if (typeof params === 'function') {
          callback = params;
          params = {};
        }
        var request = this.makeRequest(operation, params).toUnauthenticated();
        return callback ? request.send(callback) : request;
      },
      waitFor: function waitFor(state, params, callback) {
        var waiter = new AWS3.ResourceWaiter(this, state);
        return waiter.wait(params, callback);
      },
      addAllRequestListeners: function addAllRequestListeners(request) {
        var list = [AWS3.events, AWS3.EventListeners.Core, this.serviceInterface(), AWS3.EventListeners.CorePost];
        for (var i = 0; i < list.length; i++) {
          if (list[i]) request.addListeners(list[i]);
        }
        if (!this.config.paramValidation) {
          request.removeListener('validate', AWS3.EventListeners.Core.VALIDATE_PARAMETERS);
        }
        if (this.config.logger) {
          request.addListeners(AWS3.EventListeners.Logger);
        }
        this.setupRequestListeners(request);
        if (typeof this.constructor.prototype.customRequestHandler === 'function') {
          this.constructor.prototype.customRequestHandler(request);
        }
        if (
          Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') &&
          typeof this.customRequestHandler === 'function'
        ) {
          this.customRequestHandler(request);
        }
      },
      apiCallEvent: function apiCallEvent(request) {
        var api = request.service.api.operations[request.operation];
        var monitoringEvent = {
          Type: 'ApiCall',
          Api: api ? api.name : request.operation,
          Version: 1,
          Service: request.service.api.serviceId || request.service.api.endpointPrefix,
          Region: request.httpRequest.region,
          MaxRetriesExceeded: 0,
          UserAgent: request.httpRequest.getUserAgent(),
        };
        var response = request.response;
        if (response.httpResponse.statusCode) {
          monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
        }
        if (response.error) {
          var error = response.error;
          var statusCode = response.httpResponse.statusCode;
          if (statusCode > 299) {
            if (error.code) monitoringEvent.FinalAwsException = error.code;
            if (error.message) monitoringEvent.FinalAwsExceptionMessage = error.message;
          } else {
            if (error.code || error.name) monitoringEvent.FinalSdkException = error.code || error.name;
            if (error.message) monitoringEvent.FinalSdkExceptionMessage = error.message;
          }
        }
        return monitoringEvent;
      },
      apiAttemptEvent: function apiAttemptEvent(request) {
        var api = request.service.api.operations[request.operation];
        var monitoringEvent = {
          Type: 'ApiCallAttempt',
          Api: api ? api.name : request.operation,
          Version: 1,
          Service: request.service.api.serviceId || request.service.api.endpointPrefix,
          Fqdn: request.httpRequest.endpoint.hostname,
          UserAgent: request.httpRequest.getUserAgent(),
        };
        var response = request.response;
        if (response.httpResponse.statusCode) {
          monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
        }
        if (
          !request._unAuthenticated &&
          request.service.config.credentials &&
          request.service.config.credentials.accessKeyId
        ) {
          monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
        }
        if (!response.httpResponse.headers) return monitoringEvent;
        if (request.httpRequest.headers['x-amz-security-token']) {
          monitoringEvent.SessionToken = request.httpRequest.headers['x-amz-security-token'];
        }
        if (response.httpResponse.headers['x-amzn-requestid']) {
          monitoringEvent.XAmznRequestId = response.httpResponse.headers['x-amzn-requestid'];
        }
        if (response.httpResponse.headers['x-amz-request-id']) {
          monitoringEvent.XAmzRequestId = response.httpResponse.headers['x-amz-request-id'];
        }
        if (response.httpResponse.headers['x-amz-id-2']) {
          monitoringEvent.XAmzId2 = response.httpResponse.headers['x-amz-id-2'];
        }
        return monitoringEvent;
      },
      attemptFailEvent: function attemptFailEvent(request) {
        var monitoringEvent = this.apiAttemptEvent(request);
        var response = request.response;
        var error = response.error;
        if (response.httpResponse.statusCode > 299) {
          if (error.code) monitoringEvent.AwsException = error.code;
          if (error.message) monitoringEvent.AwsExceptionMessage = error.message;
        } else {
          if (error.code || error.name) monitoringEvent.SdkException = error.code || error.name;
          if (error.message) monitoringEvent.SdkExceptionMessage = error.message;
        }
        return monitoringEvent;
      },
      attachMonitoringEmitter: function attachMonitoringEmitter(request) {
        var attemptTimestamp;
        var attemptStartRealTime;
        var attemptLatency;
        var callStartRealTime;
        var attemptCount = 0;
        var region;
        var callTimestamp;
        var self = this;
        var addToHead = true;
        request.on(
          'validate',
          function () {
            callStartRealTime = AWS3.util.realClock.now();
            callTimestamp = Date.now();
          },
          addToHead
        );
        request.on(
          'sign',
          function () {
            attemptStartRealTime = AWS3.util.realClock.now();
            attemptTimestamp = Date.now();
            region = request.httpRequest.region;
            attemptCount++;
          },
          addToHead
        );
        request.on('validateResponse', function () {
          attemptLatency = Math.round(AWS3.util.realClock.now() - attemptStartRealTime);
        });
        request.addNamedListener('API_CALL_ATTEMPT', 'success', function API_CALL_ATTEMPT() {
          var apiAttemptEvent = self.apiAttemptEvent(request);
          apiAttemptEvent.Timestamp = attemptTimestamp;
          apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
          apiAttemptEvent.Region = region;
          self.emit('apiCallAttempt', [apiAttemptEvent]);
        });
        request.addNamedListener('API_CALL_ATTEMPT_RETRY', 'retry', function API_CALL_ATTEMPT_RETRY() {
          var apiAttemptEvent = self.attemptFailEvent(request);
          apiAttemptEvent.Timestamp = attemptTimestamp;
          attemptLatency = attemptLatency || Math.round(AWS3.util.realClock.now() - attemptStartRealTime);
          apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
          apiAttemptEvent.Region = region;
          self.emit('apiCallAttempt', [apiAttemptEvent]);
        });
        request.addNamedListener('API_CALL', 'complete', function API_CALL() {
          var apiCallEvent = self.apiCallEvent(request);
          apiCallEvent.AttemptCount = attemptCount;
          if (apiCallEvent.AttemptCount <= 0) return;
          apiCallEvent.Timestamp = callTimestamp;
          var latency = Math.round(AWS3.util.realClock.now() - callStartRealTime);
          apiCallEvent.Latency = latency >= 0 ? latency : 0;
          var response = request.response;
          if (
            response.error &&
            response.error.retryable &&
            typeof response.retryCount === 'number' &&
            typeof response.maxRetries === 'number' &&
            response.retryCount >= response.maxRetries
          ) {
            apiCallEvent.MaxRetriesExceeded = 1;
          }
          self.emit('apiCall', [apiCallEvent]);
        });
      },
      setupRequestListeners: function setupRequestListeners(request) {},
      getSigningName: function getSigningName() {
        return this.api.signingName || this.api.endpointPrefix;
      },
      getSignerClass: function getSignerClass(request) {
        var version;
        var operation = null;
        var authtype = '';
        if (request) {
          var operations = request.service.api.operations || {};
          operation = operations[request.operation] || null;
          authtype = operation ? operation.authtype : '';
        }
        if (this.config.signatureVersion) {
          version = this.config.signatureVersion;
        } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {
          version = 'v4';
        } else if (authtype === 'bearer') {
          version = 'bearer';
        } else {
          version = this.api.signatureVersion;
        }
        return AWS3.Signers.RequestSigner.getVersion(version);
      },
      serviceInterface: function serviceInterface() {
        switch (this.api.protocol) {
          case 'ec2':
            return AWS3.EventListeners.Query;
          case 'query':
            return AWS3.EventListeners.Query;
          case 'json':
            return AWS3.EventListeners.Json;
          case 'rest-json':
            return AWS3.EventListeners.RestJson;
          case 'rest-xml':
            return AWS3.EventListeners.RestXml;
        }
        if (this.api.protocol) {
          throw new Error("Invalid service `protocol' " + this.api.protocol + ' in API config');
        }
      },
      successfulResponse: function successfulResponse(resp) {
        return resp.httpResponse.statusCode < 300;
      },
      numRetries: function numRetries() {
        if (this.config.maxRetries !== void 0) {
          return this.config.maxRetries;
        } else {
          return this.defaultRetryCount;
        }
      },
      retryDelays: function retryDelays(retryCount, err) {
        return AWS3.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
      },
      retryableError: function retryableError(error) {
        if (this.timeoutError(error)) return true;
        if (this.networkingError(error)) return true;
        if (this.expiredCredentialsError(error)) return true;
        if (this.throttledError(error)) return true;
        if (error.statusCode >= 500) return true;
        return false;
      },
      networkingError: function networkingError(error) {
        return error.code === 'NetworkingError';
      },
      timeoutError: function timeoutError(error) {
        return error.code === 'TimeoutError';
      },
      expiredCredentialsError: function expiredCredentialsError(error) {
        return error.code === 'ExpiredTokenException';
      },
      clockSkewError: function clockSkewError(error) {
        switch (error.code) {
          case 'RequestTimeTooSkewed':
          case 'RequestExpired':
          case 'InvalidSignatureException':
          case 'SignatureDoesNotMatch':
          case 'AuthFailure':
          case 'RequestInTheFuture':
            return true;
          default:
            return false;
        }
      },
      getSkewCorrectedDate: function getSkewCorrectedDate() {
        return new Date(Date.now() + this.config.systemClockOffset);
      },
      applyClockOffset: function applyClockOffset(newServerTime) {
        if (newServerTime) {
          this.config.systemClockOffset = newServerTime - Date.now();
        }
      },
      isClockSkewed: function isClockSkewed(newServerTime) {
        if (newServerTime) {
          return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 3e5;
        }
      },
      throttledError: function throttledError(error) {
        if (error.statusCode === 429) return true;
        switch (error.code) {
          case 'ProvisionedThroughputExceededException':
          case 'Throttling':
          case 'ThrottlingException':
          case 'RequestLimitExceeded':
          case 'RequestThrottled':
          case 'RequestThrottledException':
          case 'TooManyRequestsException':
          case 'TransactionInProgressException':
          case 'EC2ThrottledException':
            return true;
          default:
            return false;
        }
      },
      endpointFromTemplate: function endpointFromTemplate(endpoint) {
        if (typeof endpoint !== 'string') return endpoint;
        var e = endpoint;
        e = e.replace(/\{service\}/g, this.api.endpointPrefix);
        e = e.replace(/\{region\}/g, this.config.region);
        e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
        return e;
      },
      setEndpoint: function setEndpoint(endpoint) {
        this.endpoint = new AWS3.Endpoint(endpoint, this.config);
      },
      paginationConfig: function paginationConfig(operation, throwException) {
        var paginator = this.api.operations[operation].paginator;
        if (!paginator) {
          if (throwException) {
            var e = new Error();
            throw AWS3.util.error(e, 'No pagination configuration for ' + operation);
          }
          return null;
        }
        return paginator;
      },
    });
    AWS3.util.update(AWS3.Service, {
      defineMethods: function defineMethods(svc) {
        AWS3.util.each(svc.prototype.api.operations, function iterator(method) {
          if (svc.prototype[method]) return;
          var operation = svc.prototype.api.operations[method];
          if (operation.authtype === 'none') {
            svc.prototype[method] = function (params, callback) {
              return this.makeUnauthenticatedRequest(method, params, callback);
            };
          } else {
            svc.prototype[method] = function (params, callback) {
              return this.makeRequest(method, params, callback);
            };
          }
        });
      },
      defineService: function defineService(serviceIdentifier, versions, features) {
        AWS3.Service._serviceMap[serviceIdentifier] = true;
        if (!Array.isArray(versions)) {
          features = versions;
          versions = [];
        }
        var svc = inherit(AWS3.Service, features || {});
        if (typeof serviceIdentifier === 'string') {
          AWS3.Service.addVersions(svc, versions);
          var identifier = svc.serviceIdentifier || serviceIdentifier;
          svc.serviceIdentifier = identifier;
        } else {
          svc.prototype.api = serviceIdentifier;
          AWS3.Service.defineMethods(svc);
        }
        AWS3.SequentialExecutor.call(this.prototype);
        if (!this.prototype.publisher && AWS3.util.clientSideMonitoring) {
          var Publisher = AWS3.util.clientSideMonitoring.Publisher;
          var configProvider = AWS3.util.clientSideMonitoring.configProvider;
          var publisherConfig = configProvider();
          this.prototype.publisher = new Publisher(publisherConfig);
          if (publisherConfig.enabled) {
            AWS3.Service._clientSideMonitoring = true;
          }
        }
        AWS3.SequentialExecutor.call(svc.prototype);
        AWS3.Service.addDefaultMonitoringListeners(svc.prototype);
        return svc;
      },
      addVersions: function addVersions(svc, versions) {
        if (!Array.isArray(versions)) versions = [versions];
        svc.services = svc.services || {};
        for (var i = 0; i < versions.length; i++) {
          if (svc.services[versions[i]] === void 0) {
            svc.services[versions[i]] = null;
          }
        }
        svc.apiVersions = Object.keys(svc.services).sort();
      },
      defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
        var svc = inherit(superclass, {
          serviceIdentifier: superclass.serviceIdentifier,
        });
        function setApi(api) {
          if (api.isApi) {
            svc.prototype.api = api;
          } else {
            svc.prototype.api = new Api(api, {
              serviceIdentifier: superclass.serviceIdentifier,
            });
          }
        }
        if (typeof version === 'string') {
          if (apiConfig) {
            setApi(apiConfig);
          } else {
            try {
              setApi(AWS3.apiLoader(superclass.serviceIdentifier, version));
            } catch (err) {
              throw AWS3.util.error(err, {
                message: 'Could not find API configuration ' + superclass.serviceIdentifier + '-' + version,
              });
            }
          }
          if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
            superclass.apiVersions = superclass.apiVersions.concat(version).sort();
          }
          superclass.services[version] = svc;
        } else {
          setApi(version);
        }
        AWS3.Service.defineMethods(svc);
        return svc;
      },
      hasService: function (identifier) {
        return Object.prototype.hasOwnProperty.call(AWS3.Service._serviceMap, identifier);
      },
      addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
        attachOn.addNamedListener('MONITOR_EVENTS_BUBBLE', 'apiCallAttempt', function EVENTS_BUBBLE(event) {
          var baseClass = Object.getPrototypeOf(attachOn);
          if (baseClass._events) baseClass.emit('apiCallAttempt', [event]);
        });
        attachOn.addNamedListener('CALL_EVENTS_BUBBLE', 'apiCall', function CALL_EVENTS_BUBBLE(event) {
          var baseClass = Object.getPrototypeOf(attachOn);
          if (baseClass._events) baseClass.emit('apiCall', [event]);
        });
      },
      _serviceMap: {},
    });
    AWS3.util.mixin(AWS3.Service, AWS3.SequentialExecutor);
    module2.exports = AWS3.Service;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials.js
var require_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials.js'() {
    var AWS3 = require_core();
    AWS3.Credentials = AWS3.util.inherit({
      constructor: function Credentials() {
        AWS3.util.hideProperties(this, ['secretAccessKey']);
        this.expired = false;
        this.expireTime = null;
        this.refreshCallbacks = [];
        if (arguments.length === 1 && typeof arguments[0] === 'object') {
          var creds = arguments[0].credentials || arguments[0];
          this.accessKeyId = creds.accessKeyId;
          this.secretAccessKey = creds.secretAccessKey;
          this.sessionToken = creds.sessionToken;
        } else {
          this.accessKeyId = arguments[0];
          this.secretAccessKey = arguments[1];
          this.sessionToken = arguments[2];
        }
      },
      expiryWindow: 15,
      needsRefresh: function needsRefresh() {
        var currentTime = AWS3.util.date.getDate().getTime();
        var adjustedTime = new Date(currentTime + this.expiryWindow * 1e3);
        if (this.expireTime && adjustedTime > this.expireTime) {
          return true;
        } else {
          return this.expired || !this.accessKeyId || !this.secretAccessKey;
        }
      },
      get: function get(callback) {
        var self = this;
        if (this.needsRefresh()) {
          this.refresh(function (err) {
            if (!err) self.expired = false;
            if (callback) callback(err);
          });
        } else if (callback) {
          callback();
        }
      },
      refresh: function refresh(callback) {
        this.expired = false;
        callback();
      },
      coalesceRefresh: function coalesceRefresh(callback, sync) {
        var self = this;
        if (self.refreshCallbacks.push(callback) === 1) {
          self.load(function onLoad(err) {
            AWS3.util.arrayEach(self.refreshCallbacks, function (callback2) {
              if (sync) {
                callback2(err);
              } else {
                AWS3.util.defer(function () {
                  callback2(err);
                });
              }
            });
            self.refreshCallbacks.length = 0;
          });
        }
      },
      load: function load(callback) {
        callback();
      },
    });
    AWS3.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.getPromise = AWS3.util.promisifyMethod('get', PromiseDependency);
      this.prototype.refreshPromise = AWS3.util.promisifyMethod('refresh', PromiseDependency);
    };
    AWS3.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.getPromise;
      delete this.prototype.refreshPromise;
    };
    AWS3.util.addPromises(AWS3.Credentials);
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/credential_provider_chain.js
var require_credential_provider_chain = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/credential_provider_chain.js'() {
    var AWS3 = require_core();
    AWS3.CredentialProviderChain = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function CredentialProviderChain(providers) {
        if (providers) {
          this.providers = providers;
        } else {
          this.providers = AWS3.CredentialProviderChain.defaultProviders.slice(0);
        }
        this.resolveCallbacks = [];
      },
      resolve: function resolve(callback) {
        var self = this;
        if (self.providers.length === 0) {
          callback(new Error('No providers'));
          return self;
        }
        if (self.resolveCallbacks.push(callback) === 1) {
          let resolveNext2 = function (err, creds) {
            if ((!err && creds) || index === providers.length) {
              AWS3.util.arrayEach(self.resolveCallbacks, function (callback2) {
                callback2(err, creds);
              });
              self.resolveCallbacks.length = 0;
              return;
            }
            var provider = providers[index++];
            if (typeof provider === 'function') {
              creds = provider.call();
            } else {
              creds = provider;
            }
            if (creds.get) {
              creds.get(function (getErr) {
                resolveNext2(getErr, getErr ? null : creds);
              });
            } else {
              resolveNext2(null, creds);
            }
          };
          var resolveNext = resolveNext2;
          var index = 0;
          var providers = self.providers.slice(0);
          resolveNext2();
        }
        return self;
      },
    });
    AWS3.CredentialProviderChain.defaultProviders = [];
    AWS3.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.resolvePromise = AWS3.util.promisifyMethod('resolve', PromiseDependency);
    };
    AWS3.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.resolvePromise;
    };
    AWS3.util.addPromises(AWS3.CredentialProviderChain);
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/config.js
var require_config = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/config.js'() {
    var AWS3 = require_core();
    require_credentials();
    require_credential_provider_chain();
    var PromisesDependency;
    AWS3.Config = AWS3.util.inherit({
      constructor: function Config(options) {
        if (options === void 0) options = {};
        options = this.extractCredentials(options);
        AWS3.util.each.call(this, this.keys, function (key, value) {
          this.set(key, options[key], value);
        });
      },
      getCredentials: function getCredentials(callback) {
        var self = this;
        function finish(err) {
          callback(err, err ? null : self.credentials);
        }
        function credError(msg, err) {
          return new AWS3.util.error(err || new Error(), {
            code: 'CredentialsError',
            message: msg,
            name: 'CredentialsError',
          });
        }
        function getAsyncCredentials() {
          self.credentials.get(function (err) {
            if (err) {
              var msg = 'Could not load credentials from ' + self.credentials.constructor.name;
              err = credError(msg, err);
            }
            finish(err);
          });
        }
        function getStaticCredentials() {
          var err = null;
          if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
            err = credError('Missing credentials');
          }
          finish(err);
        }
        if (self.credentials) {
          if (typeof self.credentials.get === 'function') {
            getAsyncCredentials();
          } else {
            getStaticCredentials();
          }
        } else if (self.credentialProvider) {
          self.credentialProvider.resolve(function (err, creds) {
            if (err) {
              err = credError('Could not load credentials from any providers', err);
            }
            self.credentials = creds;
            finish(err);
          });
        } else {
          finish(credError('No credentials to load'));
        }
      },
      getToken: function getToken(callback) {
        var self = this;
        function finish(err) {
          callback(err, err ? null : self.token);
        }
        function tokenError(msg, err) {
          return new AWS3.util.error(err || new Error(), {
            code: 'TokenError',
            message: msg,
            name: 'TokenError',
          });
        }
        function getAsyncToken() {
          self.token.get(function (err) {
            if (err) {
              var msg = 'Could not load token from ' + self.token.constructor.name;
              err = tokenError(msg, err);
            }
            finish(err);
          });
        }
        function getStaticToken() {
          var err = null;
          if (!self.token.token) {
            err = tokenError('Missing token');
          }
          finish(err);
        }
        if (self.token) {
          if (typeof self.token.get === 'function') {
            getAsyncToken();
          } else {
            getStaticToken();
          }
        } else if (self.tokenProvider) {
          self.tokenProvider.resolve(function (err, token) {
            if (err) {
              err = tokenError('Could not load token from any providers', err);
            }
            self.token = token;
            finish(err);
          });
        } else {
          finish(tokenError('No token to load'));
        }
      },
      update: function update(options, allowUnknownKeys) {
        allowUnknownKeys = allowUnknownKeys || false;
        options = this.extractCredentials(options);
        AWS3.util.each.call(this, options, function (key, value) {
          if (
            allowUnknownKeys ||
            Object.prototype.hasOwnProperty.call(this.keys, key) ||
            AWS3.Service.hasService(key)
          ) {
            this.set(key, value);
          }
        });
      },
      loadFromPath: function loadFromPath(path) {
        this.clear();
        var options = JSON.parse(AWS3.util.readFileSync(path));
        var fileSystemCreds = new AWS3.FileSystemCredentials(path);
        var chain = new AWS3.CredentialProviderChain();
        chain.providers.unshift(fileSystemCreds);
        chain.resolve(function (err, creds) {
          if (err) throw err;
          else options.credentials = creds;
        });
        this.constructor(options);
        return this;
      },
      clear: function clear() {
        AWS3.util.each.call(this, this.keys, function (key) {
          delete this[key];
        });
        this.set('credentials', void 0);
        this.set('credentialProvider', void 0);
      },
      set: function set(property, value, defaultValue) {
        if (value === void 0) {
          if (defaultValue === void 0) {
            defaultValue = this.keys[property];
          }
          if (typeof defaultValue === 'function') {
            this[property] = defaultValue.call(this);
          } else {
            this[property] = defaultValue;
          }
        } else if (property === 'httpOptions' && this[property]) {
          this[property] = AWS3.util.merge(this[property], value);
        } else {
          this[property] = value;
        }
      },
      keys: {
        credentials: null,
        credentialProvider: null,
        region: null,
        logger: null,
        apiVersions: {},
        apiVersion: null,
        endpoint: void 0,
        httpOptions: {
          timeout: 12e4,
        },
        maxRetries: void 0,
        maxRedirects: 10,
        paramValidation: true,
        sslEnabled: true,
        s3ForcePathStyle: false,
        s3BucketEndpoint: false,
        s3DisableBodySigning: true,
        s3UsEast1RegionalEndpoint: 'legacy',
        s3UseArnRegion: void 0,
        computeChecksums: true,
        convertResponseTypes: true,
        correctClockSkew: false,
        customUserAgent: null,
        dynamoDbCrc32: true,
        systemClockOffset: 0,
        signatureVersion: null,
        signatureCache: true,
        retryDelayOptions: {},
        useAccelerateEndpoint: false,
        clientSideMonitoring: false,
        endpointDiscoveryEnabled: void 0,
        endpointCacheSize: 1e3,
        hostPrefixEnabled: true,
        stsRegionalEndpoints: 'legacy',
        useFipsEndpoint: false,
        useDualstackEndpoint: false,
        token: null,
      },
      extractCredentials: function extractCredentials(options) {
        if (options.accessKeyId && options.secretAccessKey) {
          options = AWS3.util.copy(options);
          options.credentials = new AWS3.Credentials(options);
        }
        return options;
      },
      setPromisesDependency: function setPromisesDependency(dep) {
        PromisesDependency = dep;
        if (dep === null && typeof Promise === 'function') {
          PromisesDependency = Promise;
        }
        var constructors = [AWS3.Request, AWS3.Credentials, AWS3.CredentialProviderChain];
        if (AWS3.S3) {
          constructors.push(AWS3.S3);
          if (AWS3.S3.ManagedUpload) {
            constructors.push(AWS3.S3.ManagedUpload);
          }
        }
        AWS3.util.addPromises(constructors, PromisesDependency);
      },
      getPromisesDependency: function getPromisesDependency() {
        return PromisesDependency;
      },
    });
    AWS3.config = new AWS3.Config();
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/http.js
var require_http = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/http.js'() {
    var AWS3 = require_core();
    var inherit = AWS3.util.inherit;
    AWS3.Endpoint = inherit({
      constructor: function Endpoint(endpoint, config) {
        AWS3.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);
        if (typeof endpoint === 'undefined' || endpoint === null) {
          throw new Error('Invalid endpoint: ' + endpoint);
        } else if (typeof endpoint !== 'string') {
          return AWS3.util.copy(endpoint);
        }
        if (!endpoint.match(/^http/)) {
          var useSSL = config && config.sslEnabled !== void 0 ? config.sslEnabled : AWS3.config.sslEnabled;
          endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
        }
        AWS3.util.update(this, AWS3.util.urlParse(endpoint));
        if (this.port) {
          this.port = parseInt(this.port, 10);
        } else {
          this.port = this.protocol === 'https:' ? 443 : 80;
        }
      },
    });
    AWS3.HttpRequest = inherit({
      constructor: function HttpRequest(endpoint, region) {
        endpoint = new AWS3.Endpoint(endpoint);
        this.method = 'POST';
        this.path = endpoint.path || '/';
        this.headers = {};
        this.body = '';
        this.endpoint = endpoint;
        this.region = region;
        this._userAgent = '';
        this.setUserAgent();
      },
      setUserAgent: function setUserAgent() {
        this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS3.util.userAgent();
      },
      getUserAgentHeaderName: function getUserAgentHeaderName() {
        var prefix = AWS3.util.isBrowser() ? 'X-Amz-' : '';
        return prefix + 'User-Agent';
      },
      appendToUserAgent: function appendToUserAgent(agentPartial) {
        if (typeof agentPartial === 'string' && agentPartial) {
          this._userAgent += ' ' + agentPartial;
        }
        this.headers[this.getUserAgentHeaderName()] = this._userAgent;
      },
      getUserAgent: function getUserAgent() {
        return this._userAgent;
      },
      pathname: function pathname() {
        return this.path.split('?', 1)[0];
      },
      search: function search() {
        var query = this.path.split('?', 2)[1];
        if (query) {
          query = AWS3.util.queryStringParse(query);
          return AWS3.util.queryParamsToString(query);
        }
        return '';
      },
      updateEndpoint: function updateEndpoint(endpointStr) {
        var newEndpoint = new AWS3.Endpoint(endpointStr);
        this.endpoint = newEndpoint;
        this.path = newEndpoint.path || '/';
        if (this.headers['Host']) {
          this.headers['Host'] = newEndpoint.host;
        }
      },
    });
    AWS3.HttpResponse = inherit({
      constructor: function HttpResponse() {
        this.statusCode = void 0;
        this.headers = {};
        this.body = void 0;
        this.streaming = false;
        this.stream = null;
      },
      createUnbufferedStream: function createUnbufferedStream() {
        this.streaming = true;
        return this.stream;
      },
    });
    AWS3.HttpClient = inherit({});
    AWS3.HttpClient.getInstance = function getInstance() {
      if (this.singleton === void 0) {
        this.singleton = new this();
      }
      return this.singleton;
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/discover_endpoint.js
var require_discover_endpoint = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/discover_endpoint.js'(exports, module2) {
    var AWS3 = require_core();
    var util = require_util();
    var endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];
    function getCacheKey(request) {
      var service = request.service;
      var api = service.api || {};
      var operations = api.operations;
      var identifiers = {};
      if (service.config.region) {
        identifiers.region = service.config.region;
      }
      if (api.serviceId) {
        identifiers.serviceId = api.serviceId;
      }
      if (service.config.credentials.accessKeyId) {
        identifiers.accessKeyId = service.config.credentials.accessKeyId;
      }
      return identifiers;
    }
    function marshallCustomIdentifiersHelper(result, params, shape) {
      if (!shape || params === void 0 || params === null) return;
      if (shape.type === 'structure' && shape.required && shape.required.length > 0) {
        util.arrayEach(shape.required, function (name) {
          var memberShape = shape.members[name];
          if (memberShape.endpointDiscoveryId === true) {
            var locationName = memberShape.isLocationName ? memberShape.name : name;
            result[locationName] = String(params[name]);
          } else {
            marshallCustomIdentifiersHelper(result, params[name], memberShape);
          }
        });
      }
    }
    function marshallCustomIdentifiers(request, shape) {
      var identifiers = {};
      marshallCustomIdentifiersHelper(identifiers, request.params, shape);
      return identifiers;
    }
    function optionalDiscoverEndpoint(request) {
      var service = request.service;
      var api = service.api;
      var operationModel = api.operations ? api.operations[request.operation] : void 0;
      var inputShape = operationModel ? operationModel.input : void 0;
      var identifiers = marshallCustomIdentifiers(request, inputShape);
      var cacheKey = getCacheKey(request);
      if (Object.keys(identifiers).length > 0) {
        cacheKey = util.update(cacheKey, identifiers);
        if (operationModel) cacheKey.operation = operationModel.name;
      }
      var endpoints = AWS3.endpointCache.get(cacheKey);
      if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
        return;
      } else if (endpoints && endpoints.length > 0) {
        request.httpRequest.updateEndpoint(endpoints[0].Address);
      } else {
        var endpointRequest = service.makeRequest(api.endpointOperation, {
          Operation: operationModel.name,
          Identifiers: identifiers,
        });
        addApiVersionHeader(endpointRequest);
        endpointRequest.removeListener('validate', AWS3.EventListeners.Core.VALIDATE_PARAMETERS);
        endpointRequest.removeListener('retry', AWS3.EventListeners.Core.RETRY_CHECK);
        AWS3.endpointCache.put(cacheKey, [
          {
            Address: '',
            CachePeriodInMinutes: 1,
          },
        ]);
        endpointRequest.send(function (err, data) {
          if (data && data.Endpoints) {
            AWS3.endpointCache.put(cacheKey, data.Endpoints);
          } else if (err) {
            AWS3.endpointCache.put(cacheKey, [
              {
                Address: '',
                CachePeriodInMinutes: 1,
              },
            ]);
          }
        });
      }
    }
    var requestQueue = {};
    function requiredDiscoverEndpoint(request, done) {
      var service = request.service;
      var api = service.api;
      var operationModel = api.operations ? api.operations[request.operation] : void 0;
      var inputShape = operationModel ? operationModel.input : void 0;
      var identifiers = marshallCustomIdentifiers(request, inputShape);
      var cacheKey = getCacheKey(request);
      if (Object.keys(identifiers).length > 0) {
        cacheKey = util.update(cacheKey, identifiers);
        if (operationModel) cacheKey.operation = operationModel.name;
      }
      var cacheKeyStr = AWS3.EndpointCache.getKeyString(cacheKey);
      var endpoints = AWS3.endpointCache.get(cacheKeyStr);
      if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
        if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];
        requestQueue[cacheKeyStr].push({ request, callback: done });
        return;
      } else if (endpoints && endpoints.length > 0) {
        request.httpRequest.updateEndpoint(endpoints[0].Address);
        done();
      } else {
        var endpointRequest = service.makeRequest(api.endpointOperation, {
          Operation: operationModel.name,
          Identifiers: identifiers,
        });
        endpointRequest.removeListener('validate', AWS3.EventListeners.Core.VALIDATE_PARAMETERS);
        addApiVersionHeader(endpointRequest);
        AWS3.endpointCache.put(cacheKeyStr, [
          {
            Address: '',
            CachePeriodInMinutes: 60,
          },
        ]);
        endpointRequest.send(function (err, data) {
          if (err) {
            request.response.error = util.error(err, { retryable: false });
            AWS3.endpointCache.remove(cacheKey);
            if (requestQueue[cacheKeyStr]) {
              var pendingRequests = requestQueue[cacheKeyStr];
              util.arrayEach(pendingRequests, function (requestContext) {
                requestContext.request.response.error = util.error(err, { retryable: false });
                requestContext.callback();
              });
              delete requestQueue[cacheKeyStr];
            }
          } else if (data) {
            AWS3.endpointCache.put(cacheKeyStr, data.Endpoints);
            request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
            if (requestQueue[cacheKeyStr]) {
              var pendingRequests = requestQueue[cacheKeyStr];
              util.arrayEach(pendingRequests, function (requestContext) {
                requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
                requestContext.callback();
              });
              delete requestQueue[cacheKeyStr];
            }
          }
          done();
        });
      }
    }
    function addApiVersionHeader(endpointRequest) {
      var api = endpointRequest.service.api;
      var apiVersion2 = api.apiVersion;
      if (apiVersion2 && !endpointRequest.httpRequest.headers['x-amz-api-version']) {
        endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion2;
      }
    }
    function invalidateCachedEndpoints(response) {
      var error = response.error;
      var httpResponse = response.httpResponse;
      if (error && (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)) {
        var request = response.request;
        var operations = request.service.api.operations || {};
        var inputShape = operations[request.operation] ? operations[request.operation].input : void 0;
        var identifiers = marshallCustomIdentifiers(request, inputShape);
        var cacheKey = getCacheKey(request);
        if (Object.keys(identifiers).length > 0) {
          cacheKey = util.update(cacheKey, identifiers);
          if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;
        }
        AWS3.endpointCache.remove(cacheKey);
      }
    }
    function hasCustomEndpoint(client) {
      if (
        client._originalConfig &&
        client._originalConfig.endpoint &&
        client._originalConfig.endpointDiscoveryEnabled === true
      ) {
        throw util.error(new Error(), {
          code: 'ConfigurationException',
          message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.',
        });
      }
      var svcConfig = AWS3.config[client.serviceIdentifier] || {};
      return Boolean(
        AWS3.config.endpoint || svcConfig.endpoint || (client._originalConfig && client._originalConfig.endpoint)
      );
    }
    function isFalsy(value) {
      return ['false', '0'].indexOf(value) >= 0;
    }
    function resolveEndpointDiscoveryConfig(request) {
      var service = request.service || {};
      if (service.config.endpointDiscoveryEnabled !== void 0) {
        return service.config.endpointDiscoveryEnabled;
      }
      if (util.isBrowser()) return void 0;
      for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
        var env = endpointDiscoveryEnabledEnvs[i];
        if (Object.prototype.hasOwnProperty.call(process.env, env)) {
          if (process.env[env] === '' || process.env[env] === void 0) {
            throw util.error(new Error(), {
              code: 'ConfigurationException',
              message: 'environmental variable ' + env + ' cannot be set to nothing',
            });
          }
          return !isFalsy(process.env[env]);
        }
      }
      var configFile = {};
      try {
        configFile = AWS3.util.iniLoader
          ? AWS3.util.iniLoader.loadFrom({
              isConfig: true,
              filename: process.env[AWS3.util.sharedConfigFileEnv],
            })
          : {};
      } catch (e) {}
      var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS3.util.defaultProfile] || {};
      if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {
        if (sharedFileConfig.endpoint_discovery_enabled === void 0) {
          throw util.error(new Error(), {
            code: 'ConfigurationException',
            message: "config file entry 'endpoint_discovery_enabled' cannot be set to nothing",
          });
        }
        return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);
      }
      return void 0;
    }
    function discoverEndpoint(request, done) {
      var service = request.service || {};
      if (hasCustomEndpoint(service) || request.isPresigned()) return done();
      var operations = service.api.operations || {};
      var operationModel = operations[request.operation];
      var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';
      var isEnabled = resolveEndpointDiscoveryConfig(request);
      var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;
      if (isEnabled || hasRequiredEndpointDiscovery) {
        request.httpRequest.appendToUserAgent('endpoint-discovery');
      }
      switch (isEndpointDiscoveryRequired) {
        case 'OPTIONAL':
          if (isEnabled || hasRequiredEndpointDiscovery) {
            optionalDiscoverEndpoint(request);
            request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
          }
          done();
          break;
        case 'REQUIRED':
          if (isEnabled === false) {
            request.response.error = util.error(new Error(), {
              code: 'ConfigurationException',
              message:
                'Endpoint Discovery is disabled but ' +
                service.api.className +
                '.' +
                request.operation +
                '() requires it. Please check your configurations.',
            });
            done();
            break;
          }
          request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
          requiredDiscoverEndpoint(request, done);
          break;
        case 'NULL':
        default:
          done();
          break;
      }
    }
    module2.exports = {
      discoverEndpoint,
      requiredDiscoverEndpoint,
      optionalDiscoverEndpoint,
      marshallCustomIdentifiers,
      getCacheKey,
      invalidateCachedEndpoint: invalidateCachedEndpoints,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event_listeners.js
var require_event_listeners = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event_listeners.js'() {
    var AWS3 = require_core();
    var SequentialExecutor = require_sequential_executor();
    var DISCOVER_ENDPOINT = require_discover_endpoint().discoverEndpoint;
    AWS3.EventListeners = {
      Core: {},
    };
    function getOperationAuthtype(req) {
      if (!req.service.api.operations) {
        return '';
      }
      var operation = req.service.api.operations[req.operation];
      return operation ? operation.authtype : '';
    }
    function getIdentityType(req) {
      var service = req.service;
      if (service.config.signatureVersion) {
        return service.config.signatureVersion;
      }
      if (service.api.signatureVersion) {
        return service.api.signatureVersion;
      }
      return getOperationAuthtype(req);
    }
    AWS3.EventListeners = {
      Core: new SequentialExecutor().addNamedListeners(function (add, addAsync) {
        addAsync('VALIDATE_CREDENTIALS', 'validate', function VALIDATE_CREDENTIALS(req, done) {
          if (!req.service.api.signatureVersion && !req.service.config.signatureVersion) return done();
          var identityType = getIdentityType(req);
          if (identityType === 'bearer') {
            req.service.config.getToken(function (err) {
              if (err) {
                req.response.error = AWS3.util.error(err, { code: 'TokenError' });
              }
              done();
            });
            return;
          }
          req.service.config.getCredentials(function (err) {
            if (err) {
              req.response.error = AWS3.util.error(err, {
                code: 'CredentialsError',
                message: 'Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1',
              });
            }
            done();
          });
        });
        add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
          if (!req.service.isGlobalEndpoint) {
            var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
            if (!req.service.config.region) {
              req.response.error = AWS3.util.error(new Error(), {
                code: 'ConfigError',
                message: 'Missing region in config',
              });
            } else if (!dnsHostRegex.test(req.service.config.region)) {
              req.response.error = AWS3.util.error(new Error(), {
                code: 'ConfigError',
                message: 'Invalid region in config',
              });
            }
          }
        });
        add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          if (!operation) {
            return;
          }
          var idempotentMembers = operation.idempotentMembers;
          if (!idempotentMembers.length) {
            return;
          }
          var params = AWS3.util.copy(req.params);
          for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
            if (!params[idempotentMembers[i]]) {
              params[idempotentMembers[i]] = AWS3.util.uuid.v4();
            }
          }
          req.params = params;
        });
        add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
          if (!req.service.api.operations) {
            return;
          }
          var rules = req.service.api.operations[req.operation].input;
          var validation = req.service.config.paramValidation;
          new AWS3.ParamValidator(validation).validate(rules, req.params);
        });
        add('COMPUTE_CHECKSUM', 'afterBuild', function COMPUTE_CHECKSUM(req) {
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          if (!operation) {
            return;
          }
          var body = req.httpRequest.body;
          var isNonStreamingPayload = body && (AWS3.util.Buffer.isBuffer(body) || typeof body === 'string');
          var headers = req.httpRequest.headers;
          if (
            operation.httpChecksumRequired &&
            req.service.config.computeChecksums &&
            isNonStreamingPayload &&
            !headers['Content-MD5']
          ) {
            var md5 = AWS3.util.crypto.md5(body, 'base64');
            headers['Content-MD5'] = md5;
          }
        });
        addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
          req.haltHandlersOnError();
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          var authtype = operation ? operation.authtype : '';
          if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion) return done();
          if (req.service.getSignerClass(req) === AWS3.Signers.V4) {
            var body = req.httpRequest.body || '';
            if (authtype.indexOf('unsigned-body') >= 0) {
              req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
              return done();
            }
            AWS3.util.computeSha256(body, function (err, sha) {
              if (err) {
                done(err);
              } else {
                req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
                done();
              }
            });
          } else {
            done();
          }
        });
        add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
          var authtype = getOperationAuthtype(req);
          var payloadMember = AWS3.util.getRequestPayloadShape(req);
          if (req.httpRequest.headers['Content-Length'] === void 0) {
            try {
              var length = AWS3.util.string.byteLength(req.httpRequest.body);
              req.httpRequest.headers['Content-Length'] = length;
            } catch (err) {
              if (payloadMember && payloadMember.isStreaming) {
                if (payloadMember.requiresLength) {
                  throw err;
                } else if (authtype.indexOf('unsigned-body') >= 0) {
                  req.httpRequest.headers['Transfer-Encoding'] = 'chunked';
                  return;
                } else {
                  throw err;
                }
              }
              throw err;
            }
          }
        });
        add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
          req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
        });
        add('SET_TRACE_ID', 'afterBuild', function SET_TRACE_ID(req) {
          var traceIdHeaderName = 'X-Amzn-Trace-Id';
          if (AWS3.util.isNode() && !Object.hasOwnProperty.call(req.httpRequest.headers, traceIdHeaderName)) {
            var ENV_LAMBDA_FUNCTION_NAME = 'AWS_LAMBDA_FUNCTION_NAME';
            var ENV_TRACE_ID = '_X_AMZN_TRACE_ID';
            var functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
            var traceId = process.env[ENV_TRACE_ID];
            if (
              typeof functionName === 'string' &&
              functionName.length > 0 &&
              typeof traceId === 'string' &&
              traceId.length > 0
            ) {
              req.httpRequest.headers[traceIdHeaderName] = traceId;
            }
          }
        });
        add('RESTART', 'restart', function RESTART() {
          var err = this.response.error;
          if (!err || !err.retryable) return;
          this.httpRequest = new AWS3.HttpRequest(this.service.endpoint, this.service.region);
          if (this.response.retryCount < this.service.config.maxRetries) {
            this.response.retryCount++;
          } else {
            this.response.error = null;
          }
        });
        var addToHead = true;
        addAsync('DISCOVER_ENDPOINT', 'sign', DISCOVER_ENDPOINT, addToHead);
        addAsync('SIGN', 'sign', function SIGN(req, done) {
          var service = req.service;
          var identityType = getIdentityType(req);
          if (!identityType || identityType.length === 0) return done();
          if (identityType === 'bearer') {
            service.config.getToken(function (err, token) {
              if (err) {
                req.response.error = err;
                return done();
              }
              try {
                var SignerClass = service.getSignerClass(req);
                var signer = new SignerClass(req.httpRequest);
                signer.addAuthorization(token);
              } catch (e) {
                req.response.error = e;
              }
              done();
            });
          } else {
            service.config.getCredentials(function (err, credentials) {
              if (err) {
                req.response.error = err;
                return done();
              }
              try {
                var date = service.getSkewCorrectedDate();
                var SignerClass = service.getSignerClass(req);
                var operations = req.service.api.operations || {};
                var operation = operations[req.operation];
                var signer = new SignerClass(req.httpRequest, service.getSigningName(req), {
                  signatureCache: service.config.signatureCache,
                  operation,
                  signatureVersion: service.api.signatureVersion,
                });
                signer.setServiceClientId(service._clientId);
                delete req.httpRequest.headers['Authorization'];
                delete req.httpRequest.headers['Date'];
                delete req.httpRequest.headers['X-Amz-Date'];
                signer.addAuthorization(credentials, date);
                req.signedAt = date;
              } catch (e) {
                req.response.error = e;
              }
              done();
            });
          }
        });
        add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
          if (this.service.successfulResponse(resp, this)) {
            resp.data = {};
            resp.error = null;
          } else {
            resp.data = null;
            resp.error = AWS3.util.error(new Error(), { code: 'UnknownError', message: 'An unknown error occurred.' });
          }
        });
        add(
          'ERROR',
          'error',
          function ERROR(err, resp) {
            var awsQueryCompatible = resp.request.service.api.awsQueryCompatible;
            if (awsQueryCompatible) {
              var headers = resp.httpResponse.headers;
              var queryErrorCode = headers ? headers['x-amzn-query-error'] : void 0;
              if (queryErrorCode && queryErrorCode.includes(';')) {
                resp.error.code = queryErrorCode.split(';')[0];
              }
            }
          },
          true
        );
        addAsync('SEND', 'send', function SEND(resp, done) {
          resp.httpResponse._abortCallback = done;
          resp.error = null;
          resp.data = null;
          function callback(httpResp) {
            resp.httpResponse.stream = httpResp;
            var stream = resp.request.httpRequest.stream;
            var service = resp.request.service;
            var api = service.api;
            var operationName = resp.request.operation;
            var operation = api.operations[operationName] || {};
            httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {
              resp.request.emit('httpHeaders', [statusCode, headers, resp, statusMessage]);
              if (!resp.httpResponse.streaming) {
                if (AWS3.HttpClient.streamsApiVersion === 2) {
                  if (operation.hasEventOutput && service.successfulResponse(resp)) {
                    resp.request.emit('httpDone');
                    done();
                    return;
                  }
                  httpResp.on('readable', function onReadable() {
                    var data = httpResp.read();
                    if (data !== null) {
                      resp.request.emit('httpData', [data, resp]);
                    }
                  });
                } else {
                  httpResp.on('data', function onData(data) {
                    resp.request.emit('httpData', [data, resp]);
                  });
                }
              }
            });
            httpResp.on('end', function onEnd() {
              if (!stream || !stream.didCallback) {
                if (
                  AWS3.HttpClient.streamsApiVersion === 2 &&
                  operation.hasEventOutput &&
                  service.successfulResponse(resp)
                ) {
                  return;
                }
                resp.request.emit('httpDone');
                done();
              }
            });
          }
          function progress(httpResp) {
            httpResp.on('sendProgress', function onSendProgress(value) {
              resp.request.emit('httpUploadProgress', [value, resp]);
            });
            httpResp.on('receiveProgress', function onReceiveProgress(value) {
              resp.request.emit('httpDownloadProgress', [value, resp]);
            });
          }
          function error(err) {
            if (err.code !== 'RequestAbortedError') {
              var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';
              err = AWS3.util.error(err, {
                code: errCode,
                region: resp.request.httpRequest.region,
                hostname: resp.request.httpRequest.endpoint.hostname,
                retryable: true,
              });
            }
            resp.error = err;
            resp.request.emit('httpError', [resp.error, resp], function () {
              done();
            });
          }
          function executeSend() {
            var http = AWS3.HttpClient.getInstance();
            var httpOptions = resp.request.service.config.httpOptions || {};
            try {
              var stream = http.handleRequest(resp.request.httpRequest, httpOptions, callback, error);
              progress(stream);
            } catch (err) {
              error(err);
            }
          }
          var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1e3;
          if (timeDiff >= 60 * 10) {
            this.emit('sign', [this], function (err) {
              if (err) done(err);
              else executeSend();
            });
          } else {
            executeSend();
          }
        });
        add('HTTP_HEADERS', 'httpHeaders', function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
          resp.httpResponse.statusCode = statusCode;
          resp.httpResponse.statusMessage = statusMessage;
          resp.httpResponse.headers = headers;
          resp.httpResponse.body = AWS3.util.buffer.toBuffer('');
          resp.httpResponse.buffers = [];
          resp.httpResponse.numBytes = 0;
          var dateHeader = headers.date || headers.Date;
          var service = resp.request.service;
          if (dateHeader) {
            var serverTime = Date.parse(dateHeader);
            if (service.config.correctClockSkew && service.isClockSkewed(serverTime)) {
              service.applyClockOffset(serverTime);
            }
          }
        });
        add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
          if (chunk) {
            if (AWS3.util.isNode()) {
              resp.httpResponse.numBytes += chunk.length;
              var total = resp.httpResponse.headers['content-length'];
              var progress = { loaded: resp.httpResponse.numBytes, total };
              resp.request.emit('httpDownloadProgress', [progress, resp]);
            }
            resp.httpResponse.buffers.push(AWS3.util.buffer.toBuffer(chunk));
          }
        });
        add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
          if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
            var body = AWS3.util.buffer.concat(resp.httpResponse.buffers);
            resp.httpResponse.body = body;
          }
          delete resp.httpResponse.numBytes;
          delete resp.httpResponse.buffers;
        });
        add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
          if (resp.httpResponse.statusCode) {
            resp.error.statusCode = resp.httpResponse.statusCode;
            if (resp.error.retryable === void 0) {
              resp.error.retryable = this.service.retryableError(resp.error, this);
            }
          }
        });
        add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
          if (!resp.error) return;
          switch (resp.error.code) {
            case 'RequestExpired':
            case 'ExpiredTokenException':
            case 'ExpiredToken':
              resp.error.retryable = true;
              resp.request.service.config.credentials.expired = true;
          }
        });
        add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
          var err = resp.error;
          if (!err) return;
          if (typeof err.code === 'string' && typeof err.message === 'string') {
            if (err.code.match(/Signature/) && err.message.match(/expired/)) {
              resp.error.retryable = true;
            }
          }
        });
        add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
          if (!resp.error) return;
          if (this.service.clockSkewError(resp.error) && this.service.config.correctClockSkew) {
            resp.error.retryable = true;
          }
        });
        add('REDIRECT', 'retry', function REDIRECT(resp) {
          if (
            resp.error &&
            resp.error.statusCode >= 300 &&
            resp.error.statusCode < 400 &&
            resp.httpResponse.headers['location']
          ) {
            this.httpRequest.endpoint = new AWS3.Endpoint(resp.httpResponse.headers['location']);
            this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
            resp.error.redirect = true;
            resp.error.retryable = true;
          }
        });
        add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
          if (resp.error) {
            if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
              resp.error.retryDelay = 0;
            } else if (resp.retryCount < resp.maxRetries) {
              resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
            }
          }
        });
        addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
          var delay,
            willRetry = false;
          if (resp.error) {
            delay = resp.error.retryDelay || 0;
            if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
              resp.retryCount++;
              willRetry = true;
            } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
              resp.redirectCount++;
              willRetry = true;
            }
          }
          if (willRetry && delay >= 0) {
            resp.error = null;
            setTimeout(done, delay);
          } else {
            done();
          }
        });
      }),
      CorePost: new SequentialExecutor().addNamedListeners(function (add) {
        add('EXTRACT_REQUEST_ID', 'extractData', AWS3.util.extractRequestId);
        add('EXTRACT_REQUEST_ID', 'extractError', AWS3.util.extractRequestId);
        add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
          function isDNSError(err2) {
            return (
              err2.errno === 'ENOTFOUND' ||
              (typeof err2.errno === 'number' &&
                typeof AWS3.util.getSystemErrorName === 'function' &&
                ['EAI_NONAME', 'EAI_NODATA'].indexOf(AWS3.util.getSystemErrorName(err2.errno) >= 0))
            );
          }
          if (err.code === 'NetworkingError' && isDNSError(err)) {
            var message =
              'Inaccessible host: `' +
              err.hostname +
              "' at port `" +
              err.port +
              "'. This service may not be available in the `" +
              err.region +
              "' region.";
            this.response.error = AWS3.util.error(new Error(message), {
              code: 'UnknownEndpoint',
              region: err.region,
              hostname: err.hostname,
              retryable: true,
              originalError: err,
            });
          }
        });
      }),
      Logger: new SequentialExecutor().addNamedListeners(function (add) {
        add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
          var req = resp.request;
          var logger = req.service.config.logger;
          if (!logger) return;
          function filterSensitiveLog(inputShape, shape) {
            if (!shape) {
              return shape;
            }
            if (inputShape.isSensitive) {
              return '***SensitiveInformation***';
            }
            switch (inputShape.type) {
              case 'structure':
                var struct = {};
                AWS3.util.each(shape, function (subShapeName, subShape) {
                  if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                    struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
                  } else {
                    struct[subShapeName] = subShape;
                  }
                });
                return struct;
              case 'list':
                var list = [];
                AWS3.util.arrayEach(shape, function (subShape, index) {
                  list.push(filterSensitiveLog(inputShape.member, subShape));
                });
                return list;
              case 'map':
                var map = {};
                AWS3.util.each(shape, function (key, value) {
                  map[key] = filterSensitiveLog(inputShape.value, value);
                });
                return map;
              default:
                return shape;
            }
          }
          function buildMessage() {
            var time = resp.request.service.getSkewCorrectedDate().getTime();
            var delta = (time - req.startTime.getTime()) / 1e3;
            var ansi = logger.isTTY ? true : false;
            var status = resp.httpResponse.statusCode;
            var censoredParams = req.params;
            if (
              req.service.api.operations &&
              req.service.api.operations[req.operation] &&
              req.service.api.operations[req.operation].input
            ) {
              var inputShape = req.service.api.operations[req.operation].input;
              censoredParams = filterSensitiveLog(inputShape, req.params);
            }
            var params = require('util').inspect(censoredParams, true, null);
            var message = '';
            if (ansi) message += '\x1B[33m';
            message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
            message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
            if (ansi) message += '\x1B[0;1m';
            message += ' ' + AWS3.util.string.lowerFirst(req.operation);
            message += '(' + params + ')';
            if (ansi) message += '\x1B[0m';
            return message;
          }
          var line = buildMessage();
          if (typeof logger.log === 'function') {
            logger.log(line);
          } else if (typeof logger.write === 'function') {
            logger.write(line + '\n');
          }
        });
      }),
      Json: new SequentialExecutor().addNamedListeners(function (add) {
        var svc = require_json();
        add('BUILD', 'build', svc.buildRequest);
        add('EXTRACT_DATA', 'extractData', svc.extractData);
        add('EXTRACT_ERROR', 'extractError', svc.extractError);
      }),
      Rest: new SequentialExecutor().addNamedListeners(function (add) {
        var svc = require_rest();
        add('BUILD', 'build', svc.buildRequest);
        add('EXTRACT_DATA', 'extractData', svc.extractData);
        add('EXTRACT_ERROR', 'extractError', svc.extractError);
      }),
      RestJson: new SequentialExecutor().addNamedListeners(function (add) {
        var svc = require_rest_json();
        add('BUILD', 'build', svc.buildRequest);
        add('EXTRACT_DATA', 'extractData', svc.extractData);
        add('EXTRACT_ERROR', 'extractError', svc.extractError);
        add('UNSET_CONTENT_LENGTH', 'afterBuild', svc.unsetContentLength);
      }),
      RestXml: new SequentialExecutor().addNamedListeners(function (add) {
        var svc = require_rest_xml();
        add('BUILD', 'build', svc.buildRequest);
        add('EXTRACT_DATA', 'extractData', svc.extractData);
        add('EXTRACT_ERROR', 'extractError', svc.extractError);
      }),
      Query: new SequentialExecutor().addNamedListeners(function (add) {
        var svc = require_query();
        add('BUILD', 'build', svc.buildRequest);
        add('EXTRACT_DATA', 'extractData', svc.extractData);
        add('EXTRACT_ERROR', 'extractError', svc.extractError);
      }),
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/state_machine.js
var require_state_machine = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/state_machine.js'(exports, module2) {
    function AcceptorStateMachine(states, state) {
      this.currentState = state || null;
      this.states = states || {};
    }
    AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
      if (typeof finalState === 'function') {
        inputError = bindObject;
        bindObject = done;
        done = finalState;
        finalState = null;
      }
      var self = this;
      var state = self.states[self.currentState];
      state.fn.call(bindObject || self, inputError, function (err) {
        if (err) {
          if (state.fail) self.currentState = state.fail;
          else return done ? done.call(bindObject, err) : null;
        } else {
          if (state.accept) self.currentState = state.accept;
          else return done ? done.call(bindObject) : null;
        }
        if (self.currentState === finalState) {
          return done ? done.call(bindObject, err) : null;
        }
        self.runTo(finalState, done, bindObject, err);
      });
    };
    AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
      if (typeof acceptState === 'function') {
        fn = acceptState;
        acceptState = null;
        failState = null;
      } else if (typeof failState === 'function') {
        fn = failState;
        failState = null;
      }
      if (!this.currentState) this.currentState = name;
      this.states[name] = { accept: acceptState, fail: failState, fn };
      return this;
    };
    module2.exports = AcceptorStateMachine;
  },
});

// node_modules/.pnpm/jmespath@0.16.0/node_modules/jmespath/jmespath.js
var require_jmespath = __commonJS({
  'node_modules/.pnpm/jmespath@0.16.0/node_modules/jmespath/jmespath.js'(exports) {
    (function (exports2) {
      'use strict';
      function isArray(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === '[object Array]';
        } else {
          return false;
        }
      }
      function isObject(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === '[object Object]';
        } else {
          return false;
        }
      }
      function strictDeepEqual(first, second) {
        if (first === second) {
          return true;
        }
        var firstType = Object.prototype.toString.call(first);
        if (firstType !== Object.prototype.toString.call(second)) {
          return false;
        }
        if (isArray(first) === true) {
          if (first.length !== second.length) {
            return false;
          }
          for (var i = 0; i < first.length; i++) {
            if (strictDeepEqual(first[i], second[i]) === false) {
              return false;
            }
          }
          return true;
        }
        if (isObject(first) === true) {
          var keysSeen = {};
          for (var key in first) {
            if (hasOwnProperty.call(first, key)) {
              if (strictDeepEqual(first[key], second[key]) === false) {
                return false;
              }
              keysSeen[key] = true;
            }
          }
          for (var key2 in second) {
            if (hasOwnProperty.call(second, key2)) {
              if (keysSeen[key2] !== true) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      function isFalse(obj) {
        if (obj === '' || obj === false || obj === null) {
          return true;
        } else if (isArray(obj) && obj.length === 0) {
          return true;
        } else if (isObject(obj)) {
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
      function objValues(obj) {
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
          values.push(obj[keys[i]]);
        }
        return values;
      }
      function merge(a, b) {
        var merged = {};
        for (var key in a) {
          merged[key] = a[key];
        }
        for (var key2 in b) {
          merged[key2] = b[key2];
        }
        return merged;
      }
      var trimLeft;
      if (typeof String.prototype.trimLeft === 'function') {
        trimLeft = function (str) {
          return str.trimLeft();
        };
      } else {
        trimLeft = function (str) {
          return str.match(/^\s*(.*)/)[1];
        };
      }
      var TYPE_NUMBER = 0;
      var TYPE_ANY = 1;
      var TYPE_STRING = 2;
      var TYPE_ARRAY = 3;
      var TYPE_OBJECT = 4;
      var TYPE_BOOLEAN = 5;
      var TYPE_EXPREF = 6;
      var TYPE_NULL = 7;
      var TYPE_ARRAY_NUMBER = 8;
      var TYPE_ARRAY_STRING = 9;
      var TYPE_NAME_TABLE = {
        0: 'number',
        1: 'any',
        2: 'string',
        3: 'array',
        4: 'object',
        5: 'boolean',
        6: 'expression',
        7: 'null',
        8: 'Array<number>',
        9: 'Array<string>',
      };
      var TOK_EOF = 'EOF';
      var TOK_UNQUOTEDIDENTIFIER = 'UnquotedIdentifier';
      var TOK_QUOTEDIDENTIFIER = 'QuotedIdentifier';
      var TOK_RBRACKET = 'Rbracket';
      var TOK_RPAREN = 'Rparen';
      var TOK_COMMA = 'Comma';
      var TOK_COLON = 'Colon';
      var TOK_RBRACE = 'Rbrace';
      var TOK_NUMBER = 'Number';
      var TOK_CURRENT = 'Current';
      var TOK_EXPREF = 'Expref';
      var TOK_PIPE = 'Pipe';
      var TOK_OR = 'Or';
      var TOK_AND = 'And';
      var TOK_EQ = 'EQ';
      var TOK_GT = 'GT';
      var TOK_LT = 'LT';
      var TOK_GTE = 'GTE';
      var TOK_LTE = 'LTE';
      var TOK_NE = 'NE';
      var TOK_FLATTEN = 'Flatten';
      var TOK_STAR = 'Star';
      var TOK_FILTER = 'Filter';
      var TOK_DOT = 'Dot';
      var TOK_NOT = 'Not';
      var TOK_LBRACE = 'Lbrace';
      var TOK_LBRACKET = 'Lbracket';
      var TOK_LPAREN = 'Lparen';
      var TOK_LITERAL = 'Literal';
      var basicTokens = {
        '.': TOK_DOT,
        '*': TOK_STAR,
        ',': TOK_COMMA,
        ':': TOK_COLON,
        '{': TOK_LBRACE,
        '}': TOK_RBRACE,
        ']': TOK_RBRACKET,
        '(': TOK_LPAREN,
        ')': TOK_RPAREN,
        '@': TOK_CURRENT,
      };
      var operatorStartToken = {
        '<': true,
        '>': true,
        '=': true,
        '!': true,
      };
      var skipChars = {
        ' ': true,
        '	': true,
        '\n': true,
      };
      function isAlpha(ch) {
        return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_';
      }
      function isNum(ch) {
        return (ch >= '0' && ch <= '9') || ch === '-';
      }
      function isAlphaNum(ch) {
        return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch === '_';
      }
      function Lexer() {}
      Lexer.prototype = {
        tokenize: function (stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
            if (isAlpha(stream[this._current])) {
              start = this._current;
              identifier = this._consumeUnquotedIdentifier(stream);
              tokens.push({
                type: TOK_UNQUOTEDIDENTIFIER,
                value: identifier,
                start,
              });
            } else if (basicTokens[stream[this._current]] !== void 0) {
              tokens.push({
                type: basicTokens[stream[this._current]],
                value: stream[this._current],
                start: this._current,
              });
              this._current++;
            } else if (isNum(stream[this._current])) {
              token = this._consumeNumber(stream);
              tokens.push(token);
            } else if (stream[this._current] === '[') {
              token = this._consumeLBracket(stream);
              tokens.push(token);
            } else if (stream[this._current] === '"') {
              start = this._current;
              identifier = this._consumeQuotedIdentifier(stream);
              tokens.push({
                type: TOK_QUOTEDIDENTIFIER,
                value: identifier,
                start,
              });
            } else if (stream[this._current] === "'") {
              start = this._current;
              identifier = this._consumeRawStringLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: identifier,
                start,
              });
            } else if (stream[this._current] === '`') {
              start = this._current;
              var literal = this._consumeLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: literal,
                start,
              });
            } else if (operatorStartToken[stream[this._current]] !== void 0) {
              tokens.push(this._consumeOperator(stream));
            } else if (skipChars[stream[this._current]] !== void 0) {
              this._current++;
            } else if (stream[this._current] === '&') {
              start = this._current;
              this._current++;
              if (stream[this._current] === '&') {
                this._current++;
                tokens.push({ type: TOK_AND, value: '&&', start });
              } else {
                tokens.push({ type: TOK_EXPREF, value: '&', start });
              }
            } else if (stream[this._current] === '|') {
              start = this._current;
              this._current++;
              if (stream[this._current] === '|') {
                this._current++;
                tokens.push({ type: TOK_OR, value: '||', start });
              } else {
                tokens.push({ type: TOK_PIPE, value: '|', start });
              }
            } else {
              var error = new Error('Unknown character:' + stream[this._current]);
              error.name = 'LexerError';
              throw error;
            }
          }
          return tokens;
        },
        _consumeUnquotedIdentifier: function (stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
            this._current++;
          }
          return stream.slice(start, this._current);
        },
        _consumeQuotedIdentifier: function (stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== '"' && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === '\\' && (stream[current + 1] === '\\' || stream[current + 1] === '"')) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
        },
        _consumeRawStringLiteral: function (stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === '\\' && (stream[current + 1] === '\\' || stream[current + 1] === "'")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
        },
        _consumeNumber: function (stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
            this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return { type: TOK_NUMBER, value, start };
        },
        _consumeLBracket: function (stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === '?') {
            this._current++;
            return { type: TOK_FILTER, value: '[?', start };
          } else if (stream[this._current] === ']') {
            this._current++;
            return { type: TOK_FLATTEN, value: '[]', start };
          } else {
            return { type: TOK_LBRACKET, value: '[', start };
          }
        },
        _consumeOperator: function (stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === '!') {
            if (stream[this._current] === '=') {
              this._current++;
              return { type: TOK_NE, value: '!=', start };
            } else {
              return { type: TOK_NOT, value: '!', start };
            }
          } else if (startingChar === '<') {
            if (stream[this._current] === '=') {
              this._current++;
              return { type: TOK_LTE, value: '<=', start };
            } else {
              return { type: TOK_LT, value: '<', start };
            }
          } else if (startingChar === '>') {
            if (stream[this._current] === '=') {
              this._current++;
              return { type: TOK_GTE, value: '>=', start };
            } else {
              return { type: TOK_GT, value: '>', start };
            }
          } else if (startingChar === '=') {
            if (stream[this._current] === '=') {
              this._current++;
              return { type: TOK_EQ, value: '==', start };
            }
          }
        },
        _consumeLiteral: function (stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while (stream[this._current] !== '`' && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === '\\' && (stream[current + 1] === '\\' || stream[current + 1] === '`')) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace('\\`', '`');
          if (this._looksLikeJSON(literalString)) {
            literal = JSON.parse(literalString);
          } else {
            literal = JSON.parse('"' + literalString + '"');
          }
          this._current++;
          return literal;
        },
        _looksLikeJSON: function (literalString) {
          var startingChars = '[{"';
          var jsonLiterals = ['true', 'false', 'null'];
          var numberLooking = '-0123456789';
          if (literalString === '') {
            return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
            return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
            return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
            try {
              JSON.parse(literalString);
              return true;
            } catch (ex) {
              return false;
            }
          } else {
            return false;
          }
        },
      };
      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;
      function Parser() {}
      Parser.prototype = {
        parse: function (expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
            var t = this._lookaheadToken(0);
            var error = new Error('Unexpected token type: ' + t.type + ', value: ' + t.value);
            error.name = 'ParserError';
            throw error;
          }
          return ast;
        },
        _loadTokens: function (expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({ type: TOK_EOF, value: '', start: expression.length });
          this.tokens = tokens;
        },
        expression: function (rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
            this._advance();
            left = this.led(currentToken, left);
            currentToken = this._lookahead(0);
          }
          return left;
        },
        _lookahead: function (number) {
          return this.tokens[this.index + number].type;
        },
        _lookaheadToken: function (number) {
          return this.tokens[this.index + number];
        },
        _advance: function () {
          this.index++;
        },
        nud: function (token) {
          var left;
          var right;
          var expression;
          switch (token.type) {
            case TOK_LITERAL:
              return { type: 'Literal', value: token.value };
            case TOK_UNQUOTEDIDENTIFIER:
              return { type: 'Field', name: token.value };
            case TOK_QUOTEDIDENTIFIER:
              var node = { type: 'Field', name: token.value };
              if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error('Quoted identifier not allowed for function names.');
              }
              return node;
            case TOK_NOT:
              right = this.expression(bindingPower.Not);
              return { type: 'NotExpression', children: [right] };
            case TOK_STAR:
              left = { type: 'Identity' };
              right = null;
              if (this._lookahead(0) === TOK_RBRACKET) {
                right = { type: 'Identity' };
              } else {
                right = this._parseProjectionRHS(bindingPower.Star);
              }
              return { type: 'ValueProjection', children: [left, right] };
            case TOK_FILTER:
              return this.led(token.type, { type: 'Identity' });
            case TOK_LBRACE:
              return this._parseMultiselectHash();
            case TOK_FLATTEN:
              left = { type: TOK_FLATTEN, children: [{ type: 'Identity' }] };
              right = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: 'Projection', children: [left, right] };
            case TOK_LBRACKET:
              if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({ type: 'Identity' }, right);
              } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {
                  type: 'Projection',
                  children: [{ type: 'Identity' }, right],
                };
              }
              return this._parseMultiselectList();
            case TOK_CURRENT:
              return { type: TOK_CURRENT };
            case TOK_EXPREF:
              expression = this.expression(bindingPower.Expref);
              return { type: 'ExpressionReference', children: [expression] };
            case TOK_LPAREN:
              var args = [];
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              return args[0];
            default:
              this._errorToken(token);
          }
        },
        led: function (tokenName, left) {
          var right;
          switch (tokenName) {
            case TOK_DOT:
              var rbp = bindingPower.Dot;
              if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return { type: 'Subexpression', children: [left, right] };
              }
              this._advance();
              right = this._parseProjectionRHS(rbp);
              return { type: 'ValueProjection', children: [left, right] };
            case TOK_PIPE:
              right = this.expression(bindingPower.Pipe);
              return { type: TOK_PIPE, children: [left, right] };
            case TOK_OR:
              right = this.expression(bindingPower.Or);
              return { type: 'OrExpression', children: [left, right] };
            case TOK_AND:
              right = this.expression(bindingPower.And);
              return { type: 'AndExpression', children: [left, right] };
            case TOK_LPAREN:
              var name = left.name;
              var args = [];
              var expression, node;
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              node = { type: 'Function', name, children: args };
              return node;
            case TOK_FILTER:
              var condition = this.expression(0);
              this._match(TOK_RBRACKET);
              if (this._lookahead(0) === TOK_FLATTEN) {
                right = { type: 'Identity' };
              } else {
                right = this._parseProjectionRHS(bindingPower.Filter);
              }
              return { type: 'FilterProjection', children: [left, right, condition] };
            case TOK_FLATTEN:
              var leftNode = { type: TOK_FLATTEN, children: [left] };
              var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: 'Projection', children: [leftNode, rightNode] };
            case TOK_EQ:
            case TOK_NE:
            case TOK_GT:
            case TOK_GTE:
            case TOK_LT:
            case TOK_LTE:
              return this._parseComparator(left, tokenName);
            case TOK_LBRACKET:
              var token = this._lookaheadToken(0);
              if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
              }
              this._match(TOK_STAR);
              this._match(TOK_RBRACKET);
              right = this._parseProjectionRHS(bindingPower.Star);
              return { type: 'Projection', children: [left, right] };
            default:
              this._errorToken(this._lookaheadToken(0));
          }
        },
        _match: function (tokenType) {
          if (this._lookahead(0) === tokenType) {
            this._advance();
          } else {
            var t = this._lookaheadToken(0);
            var error = new Error('Expected ' + tokenType + ', got: ' + t.type);
            error.name = 'ParserError';
            throw error;
          }
        },
        _errorToken: function (token) {
          var error = new Error('Invalid token (' + token.type + '): "' + token.value + '"');
          error.name = 'ParserError';
          throw error;
        },
        _parseIndexExpression: function () {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
            return this._parseSliceExpression();
          } else {
            var node = {
              type: 'Index',
              value: this._lookaheadToken(0).value,
            };
            this._advance();
            this._match(TOK_RBRACKET);
            return node;
          }
        },
        _projectIfSlice: function (left, right) {
          var indexExpr = { type: 'IndexExpression', children: [left, right] };
          if (right.type === 'Slice') {
            return {
              type: 'Projection',
              children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)],
            };
          } else {
            return indexExpr;
          }
        },
        _parseSliceExpression: function () {
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
            if (currentToken === TOK_COLON) {
              index++;
              this._advance();
            } else if (currentToken === TOK_NUMBER) {
              parts[index] = this._lookaheadToken(0).value;
              this._advance();
            } else {
              var t = this._lookahead(0);
              var error = new Error('Syntax error, unexpected token: ' + t.value + '(' + t.type + ')');
              error.name = 'Parsererror';
              throw error;
            }
            currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
            type: 'Slice',
            children: parts,
          };
        },
        _parseComparator: function (left, comparator) {
          var right = this.expression(bindingPower[comparator]);
          return { type: 'Comparator', name: comparator, children: [left, right] };
        },
        _parseDotRHS: function (rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
            return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
            this._match(TOK_LBRACKET);
            return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
            this._match(TOK_LBRACE);
            return this._parseMultiselectHash();
          }
        },
        _parseProjectionRHS: function (rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
            right = { type: 'Identity' };
          } else if (this._lookahead(0) === TOK_LBRACKET) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
            this._match(TOK_DOT);
            right = this._parseDotRHS(rbp);
          } else {
            var t = this._lookaheadToken(0);
            var error = new Error('Sytanx error, unexpected token: ' + t.value + '(' + t.type + ')');
            error.name = 'ParserError';
            throw error;
          }
          return right;
        },
        _parseMultiselectList: function () {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
            var expression = this.expression(0);
            expressions.push(expression);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
              if (this._lookahead(0) === TOK_RBRACKET) {
                throw new Error('Unexpected token Rbracket');
              }
            }
          }
          this._match(TOK_RBRACKET);
          return { type: 'MultiSelectList', children: expressions };
        },
        _parseMultiselectHash: function () {
          var pairs = [];
          var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
          var keyToken, keyName, value, node;
          for (;;) {
            keyToken = this._lookaheadToken(0);
            if (identifierTypes.indexOf(keyToken.type) < 0) {
              throw new Error('Expecting an identifier token, got: ' + keyToken.type);
            }
            keyName = keyToken.value;
            this._advance();
            this._match(TOK_COLON);
            value = this.expression(0);
            node = { type: 'KeyValuePair', name: keyName, value };
            pairs.push(node);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
            } else if (this._lookahead(0) === TOK_RBRACE) {
              this._match(TOK_RBRACE);
              break;
            }
          }
          return { type: 'MultiSelectHash', children: pairs };
        },
      };
      function TreeInterpreter(runtime) {
        this.runtime = runtime;
      }
      TreeInterpreter.prototype = {
        search: function (node, value) {
          return this.visit(node, value);
        },
        visit: function (node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case 'Field':
              if (value !== null && isObject(value)) {
                field = value[node.name];
                if (field === void 0) {
                  return null;
                } else {
                  return field;
                }
              }
              return null;
            case 'Subexpression':
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                result = this.visit(node.children[1], result);
                if (result === null) {
                  return null;
                }
              }
              return result;
            case 'IndexExpression':
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case 'Index':
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === void 0) {
                result = null;
              }
              return result;
            case 'Slice':
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                for (i = start; i < stop; i += step) {
                  result.push(value[i]);
                }
              } else {
                for (i = start; i > stop; i += step) {
                  result.push(value[i]);
                }
              }
              return result;
            case 'Projection':
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case 'ValueProjection':
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case 'FilterProjection':
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case 'Comparator':
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch (node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error('Unknown comparator: ' + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case 'Identity':
              return value;
            case 'MultiSelectList':
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case 'MultiSelectHash':
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case 'OrExpression':
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                matched = this.visit(node.children[1], value);
              }
              return matched;
            case 'AndExpression':
              first = this.visit(node.children[0], value);
              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case 'NotExpression':
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case 'Literal':
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case 'Function':
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case 'ExpressionReference':
              var refNode = node.children[0];
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error('Unknown node type: ' + node.type);
          }
        },
        computeSliceParams: function (arrayLength, sliceParams) {
          var start = sliceParams[0];
          var stop = sliceParams[1];
          var step = sliceParams[2];
          var computed = [null, null, null];
          if (step === null) {
            step = 1;
          } else if (step === 0) {
            var error = new Error('Invalid slice, step cannot be 0');
            error.name = 'RuntimeError';
            throw error;
          }
          var stepValueNegative = step < 0 ? true : false;
          if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
          } else {
            start = this.capSliceRange(arrayLength, start, step);
          }
          if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
          } else {
            stop = this.capSliceRange(arrayLength, stop, step);
          }
          computed[0] = start;
          computed[1] = stop;
          computed[2] = step;
          return computed;
        },
        capSliceRange: function (arrayLength, actualValue, step) {
          if (actualValue < 0) {
            actualValue += arrayLength;
            if (actualValue < 0) {
              actualValue = step < 0 ? -1 : 0;
            }
          } else if (actualValue >= arrayLength) {
            actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
        },
      };
      function Runtime(interpreter) {
        this._interpreter = interpreter;
        this.functionTable = {
          abs: { _func: this._functionAbs, _signature: [{ types: [TYPE_NUMBER] }] },
          avg: { _func: this._functionAvg, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          ceil: { _func: this._functionCeil, _signature: [{ types: [TYPE_NUMBER] }] },
          contains: {
            _func: this._functionContains,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }, { types: [TYPE_ANY] }],
          },
          ends_with: {
            _func: this._functionEndsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],
          },
          floor: { _func: this._functionFloor, _signature: [{ types: [TYPE_NUMBER] }] },
          length: {
            _func: this._functionLength,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }],
          },
          map: {
            _func: this._functionMap,
            _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }],
          },
          max: {
            _func: this._functionMax,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }],
          },
          merge: {
            _func: this._functionMerge,
            _signature: [{ types: [TYPE_OBJECT], variadic: true }],
          },
          max_by: {
            _func: this._functionMaxBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],
          },
          sum: { _func: this._functionSum, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          starts_with: {
            _func: this._functionStartsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],
          },
          min: {
            _func: this._functionMin,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }],
          },
          min_by: {
            _func: this._functionMinBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],
          },
          type: { _func: this._functionType, _signature: [{ types: [TYPE_ANY] }] },
          keys: { _func: this._functionKeys, _signature: [{ types: [TYPE_OBJECT] }] },
          values: { _func: this._functionValues, _signature: [{ types: [TYPE_OBJECT] }] },
          sort: { _func: this._functionSort, _signature: [{ types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }] },
          sort_by: {
            _func: this._functionSortBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],
          },
          join: {
            _func: this._functionJoin,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_ARRAY_STRING] }],
          },
          reverse: {
            _func: this._functionReverse,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }],
          },
          to_array: { _func: this._functionToArray, _signature: [{ types: [TYPE_ANY] }] },
          to_string: { _func: this._functionToString, _signature: [{ types: [TYPE_ANY] }] },
          to_number: { _func: this._functionToNumber, _signature: [{ types: [TYPE_ANY] }] },
          not_null: {
            _func: this._functionNotNull,
            _signature: [{ types: [TYPE_ANY], variadic: true }],
          },
        };
      }
      Runtime.prototype = {
        callFunction: function (name, resolvedArgs) {
          var functionEntry = this.functionTable[name];
          if (functionEntry === void 0) {
            throw new Error('Unknown function: ' + name + '()');
          }
          this._validateArgs(name, resolvedArgs, functionEntry._signature);
          return functionEntry._func.call(this, resolvedArgs);
        },
        _validateArgs: function (name, args, signature) {
          var pluralized;
          if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
              pluralized = signature.length === 1 ? ' argument' : ' arguments';
              throw new Error(
                'ArgumentError: ' +
                  name +
                  '() takes at least' +
                  signature.length +
                  pluralized +
                  ' but received ' +
                  args.length
              );
            }
          } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? ' argument' : ' arguments';
            throw new Error(
              'ArgumentError: ' + name + '() takes ' + signature.length + pluralized + ' but received ' + args.length
            );
          }
          var currentSpec;
          var actualType;
          var typeMatched;
          for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
              if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                typeMatched = true;
                break;
              }
            }
            if (!typeMatched) {
              var expected = currentSpec
                .map(function (typeIdentifier) {
                  return TYPE_NAME_TABLE[typeIdentifier];
                })
                .join(',');
              throw new Error(
                'TypeError: ' +
                  name +
                  '() expected argument ' +
                  (i + 1) +
                  ' to be type ' +
                  expected +
                  ' but received type ' +
                  TYPE_NAME_TABLE[actualType] +
                  ' instead.'
              );
            }
          }
        },
        _typeMatches: function (actual, expected, argValue) {
          if (expected === TYPE_ANY) {
            return true;
          }
          if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
            if (expected === TYPE_ARRAY) {
              return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
              var subtype;
              if (expected === TYPE_ARRAY_NUMBER) {
                subtype = TYPE_NUMBER;
              } else if (expected === TYPE_ARRAY_STRING) {
                subtype = TYPE_STRING;
              }
              for (var i = 0; i < argValue.length; i++) {
                if (!this._typeMatches(this._getTypeName(argValue[i]), subtype, argValue[i])) {
                  return false;
                }
              }
              return true;
            }
          } else {
            return actual === expected;
          }
        },
        _getTypeName: function (obj) {
          switch (Object.prototype.toString.call(obj)) {
            case '[object String]':
              return TYPE_STRING;
            case '[object Number]':
              return TYPE_NUMBER;
            case '[object Array]':
              return TYPE_ARRAY;
            case '[object Boolean]':
              return TYPE_BOOLEAN;
            case '[object Null]':
              return TYPE_NULL;
            case '[object Object]':
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
          }
        },
        _functionStartsWith: function (resolvedArgs) {
          return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
        },
        _functionEndsWith: function (resolvedArgs) {
          var searchStr = resolvedArgs[0];
          var suffix = resolvedArgs[1];
          return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
        },
        _functionReverse: function (resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);
          if (typeName === TYPE_STRING) {
            var originalStr = resolvedArgs[0];
            var reversedStr = '';
            for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
            }
            return reversedStr;
          } else {
            var reversedArray = resolvedArgs[0].slice(0);
            reversedArray.reverse();
            return reversedArray;
          }
        },
        _functionAbs: function (resolvedArgs) {
          return Math.abs(resolvedArgs[0]);
        },
        _functionCeil: function (resolvedArgs) {
          return Math.ceil(resolvedArgs[0]);
        },
        _functionAvg: function (resolvedArgs) {
          var sum = 0;
          var inputArray = resolvedArgs[0];
          for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
          }
          return sum / inputArray.length;
        },
        _functionContains: function (resolvedArgs) {
          return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
        },
        _functionFloor: function (resolvedArgs) {
          return Math.floor(resolvedArgs[0]);
        },
        _functionLength: function (resolvedArgs) {
          if (!isObject(resolvedArgs[0])) {
            return resolvedArgs[0].length;
          } else {
            return Object.keys(resolvedArgs[0]).length;
          }
        },
        _functionMap: function (resolvedArgs) {
          var mapped = [];
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[0];
          var elements = resolvedArgs[1];
          for (var i = 0; i < elements.length; i++) {
            mapped.push(interpreter.visit(exprefNode, elements[i]));
          }
          return mapped;
        },
        _functionMerge: function (resolvedArgs) {
          var merged = {};
          for (var i = 0; i < resolvedArgs.length; i++) {
            var current = resolvedArgs[i];
            for (var key in current) {
              merged[key] = current[key];
            }
          }
          return merged;
        },
        _functionMax: function (resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);
            if (typeName === TYPE_NUMBER) {
              return Math.max.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var maxElement = elements[0];
              for (var i = 1; i < elements.length; i++) {
                if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
                }
              }
              return maxElement;
            }
          } else {
            return null;
          }
        },
        _functionMin: function (resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);
            if (typeName === TYPE_NUMBER) {
              return Math.min.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var minElement = elements[0];
              for (var i = 1; i < elements.length; i++) {
                if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
                }
              }
              return minElement;
            }
          } else {
            return null;
          }
        },
        _functionSum: function (resolvedArgs) {
          var sum = 0;
          var listToSum = resolvedArgs[0];
          for (var i = 0; i < listToSum.length; i++) {
            sum += listToSum[i];
          }
          return sum;
        },
        _functionType: function (resolvedArgs) {
          switch (this._getTypeName(resolvedArgs[0])) {
            case TYPE_NUMBER:
              return 'number';
            case TYPE_STRING:
              return 'string';
            case TYPE_ARRAY:
              return 'array';
            case TYPE_OBJECT:
              return 'object';
            case TYPE_BOOLEAN:
              return 'boolean';
            case TYPE_EXPREF:
              return 'expref';
            case TYPE_NULL:
              return 'null';
          }
        },
        _functionKeys: function (resolvedArgs) {
          return Object.keys(resolvedArgs[0]);
        },
        _functionValues: function (resolvedArgs) {
          var obj = resolvedArgs[0];
          var keys = Object.keys(obj);
          var values = [];
          for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
          }
          return values;
        },
        _functionJoin: function (resolvedArgs) {
          var joinChar = resolvedArgs[0];
          var listJoin = resolvedArgs[1];
          return listJoin.join(joinChar);
        },
        _functionToArray: function (resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
          } else {
            return [resolvedArgs[0]];
          }
        },
        _functionToString: function (resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
          } else {
            return JSON.stringify(resolvedArgs[0]);
          }
        },
        _functionToNumber: function (resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);
          var convertedValue;
          if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
          } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
              return convertedValue;
            }
          }
          return null;
        },
        _functionNotNull: function (resolvedArgs) {
          for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
              return resolvedArgs[i];
            }
          }
          return null;
        },
        _functionSort: function (resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          sortedArray.sort();
          return sortedArray;
        },
        _functionSortBy: function (resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          if (sortedArray.length === 0) {
            return sortedArray;
          }
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[1];
          var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));
          if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error('TypeError');
          }
          var that = this;
          var decorated = [];
          for (var i = 0; i < sortedArray.length; i++) {
            decorated.push([i, sortedArray[i]]);
          }
          decorated.sort(function (a, b) {
            var exprA = interpreter.visit(exprefNode, a[1]);
            var exprB = interpreter.visit(exprefNode, b[1]);
            if (that._getTypeName(exprA) !== requiredType) {
              throw new Error('TypeError: expected ' + requiredType + ', received ' + that._getTypeName(exprA));
            } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error('TypeError: expected ' + requiredType + ', received ' + that._getTypeName(exprB));
            }
            if (exprA > exprB) {
              return 1;
            } else if (exprA < exprB) {
              return -1;
            } else {
              return a[0] - b[0];
            }
          });
          for (var j = 0; j < decorated.length; j++) {
            sortedArray[j] = decorated[j][1];
          }
          return sortedArray;
        },
        _functionMaxBy: function (resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var maxNumber = -Infinity;
          var maxRecord;
          var current;
          for (var i = 0; i < resolvedArray.length; i++) {
            current = keyFunction(resolvedArray[i]);
            if (current > maxNumber) {
              maxNumber = current;
              maxRecord = resolvedArray[i];
            }
          }
          return maxRecord;
        },
        _functionMinBy: function (resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var minNumber = Infinity;
          var minRecord;
          var current;
          for (var i = 0; i < resolvedArray.length; i++) {
            current = keyFunction(resolvedArray[i]);
            if (current < minNumber) {
              minNumber = current;
              minRecord = resolvedArray[i];
            }
          }
          return minRecord;
        },
        createKeyFunction: function (exprefNode, allowedTypes) {
          var that = this;
          var interpreter = this._interpreter;
          var keyFunc = function (x) {
            var current = interpreter.visit(exprefNode, x);
            if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
              var msg = 'TypeError: expected one of ' + allowedTypes + ', received ' + that._getTypeName(current);
              throw new Error(msg);
            }
            return current;
          };
          return keyFunc;
        },
      };
      function compile(stream) {
        var parser = new Parser();
        var ast = parser.parse(stream);
        return ast;
      }
      function tokenize(stream) {
        var lexer = new Lexer();
        return lexer.tokenize(stream);
      }
      function search(data, expression) {
        var parser = new Parser();
        var runtime = new Runtime();
        var interpreter = new TreeInterpreter(runtime);
        runtime._interpreter = interpreter;
        var node = parser.parse(expression);
        return interpreter.search(node, data);
      }
      exports2.tokenize = tokenize;
      exports2.compile = compile;
      exports2.search = search;
      exports2.strictDeepEqual = strictDeepEqual;
    })(typeof exports === 'undefined' ? (exports.jmespath = {}) : exports);
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/request.js
var require_request = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/request.js'() {
    var AWS3 = require_core();
    var AcceptorStateMachine = require_state_machine();
    var inherit = AWS3.util.inherit;
    var domain = AWS3.util.domain;
    var jmespath = require_jmespath();
    var hardErrorStates = { success: 1, error: 1, complete: 1 };
    function isTerminalState(machine) {
      return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
    }
    var fsm = new AcceptorStateMachine();
    fsm.setupStates = function () {
      var transition = function (_, done) {
        var self = this;
        self._haltHandlersOnError = false;
        self.emit(self._asm.currentState, function (err) {
          if (err) {
            if (isTerminalState(self)) {
              if (domain && self.domain instanceof domain.Domain) {
                err.domainEmitter = self;
                err.domain = self.domain;
                err.domainThrown = false;
                self.domain.emit('error', err);
              } else {
                throw err;
              }
            } else {
              self.response.error = err;
              done(err);
            }
          } else {
            done(self.response.error);
          }
        });
      };
      this.addState('validate', 'build', 'error', transition);
      this.addState('build', 'afterBuild', 'restart', transition);
      this.addState('afterBuild', 'sign', 'restart', transition);
      this.addState('sign', 'send', 'retry', transition);
      this.addState('retry', 'afterRetry', 'afterRetry', transition);
      this.addState('afterRetry', 'sign', 'error', transition);
      this.addState('send', 'validateResponse', 'retry', transition);
      this.addState('validateResponse', 'extractData', 'extractError', transition);
      this.addState('extractError', 'extractData', 'retry', transition);
      this.addState('extractData', 'success', 'retry', transition);
      this.addState('restart', 'build', 'error', transition);
      this.addState('success', 'complete', 'complete', transition);
      this.addState('error', 'complete', 'complete', transition);
      this.addState('complete', null, null, transition);
    };
    fsm.setupStates();
    AWS3.Request = inherit({
      constructor: function Request(service, operation, params) {
        var endpoint = service.endpoint;
        var region = service.config.region;
        var customUserAgent = service.config.customUserAgent;
        if (service.signingRegion) {
          region = service.signingRegion;
        } else if (service.isGlobalEndpoint) {
          region = 'us-east-1';
        }
        this.domain = domain && domain.active;
        this.service = service;
        this.operation = operation;
        this.params = params || {};
        this.httpRequest = new AWS3.HttpRequest(endpoint, region);
        this.httpRequest.appendToUserAgent(customUserAgent);
        this.startTime = service.getSkewCorrectedDate();
        this.response = new AWS3.Response(this);
        this._asm = new AcceptorStateMachine(fsm.states, 'validate');
        this._haltHandlersOnError = false;
        AWS3.SequentialExecutor.call(this);
        this.emit = this.emitEvent;
      },
      send: function send(callback) {
        if (callback) {
          this.httpRequest.appendToUserAgent('callback');
          this.on('complete', function (resp) {
            callback.call(resp, resp.error, resp.data);
          });
        }
        this.runTo();
        return this.response;
      },
      build: function build(callback) {
        return this.runTo('send', callback);
      },
      runTo: function runTo(state, done) {
        this._asm.runTo(state, done, this);
        return this;
      },
      abort: function abort() {
        this.removeAllListeners('validateResponse');
        this.removeAllListeners('extractError');
        this.on('validateResponse', function addAbortedError(resp) {
          resp.error = AWS3.util.error(new Error('Request aborted by user'), {
            code: 'RequestAbortedError',
            retryable: false,
          });
        });
        if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) {
          this.httpRequest.stream.abort();
          if (this.httpRequest._abortCallback) {
            this.httpRequest._abortCallback();
          } else {
            this.removeAllListeners('send');
          }
        }
        return this;
      },
      eachPage: function eachPage(callback) {
        callback = AWS3.util.fn.makeAsync(callback, 3);
        function wrappedCallback(response) {
          callback.call(response, response.error, response.data, function (result) {
            if (result === false) return;
            if (response.hasNextPage()) {
              response.nextPage().on('complete', wrappedCallback).send();
            } else {
              callback.call(response, null, null, AWS3.util.fn.noop);
            }
          });
        }
        this.on('complete', wrappedCallback).send();
      },
      eachItem: function eachItem(callback) {
        var self = this;
        function wrappedCallback(err, data) {
          if (err) return callback(err, null);
          if (data === null) return callback(null, null);
          var config = self.service.paginationConfig(self.operation);
          var resultKey = config.resultKey;
          if (Array.isArray(resultKey)) resultKey = resultKey[0];
          var items = jmespath.search(data, resultKey);
          var continueIteration = true;
          AWS3.util.arrayEach(items, function (item) {
            continueIteration = callback(null, item);
            if (continueIteration === false) {
              return AWS3.util.abort;
            }
          });
          return continueIteration;
        }
        this.eachPage(wrappedCallback);
      },
      isPageable: function isPageable() {
        return this.service.paginationConfig(this.operation) ? true : false;
      },
      createReadStream: function createReadStream() {
        var streams = AWS3.util.stream;
        var req = this;
        var stream = null;
        if (AWS3.HttpClient.streamsApiVersion === 2) {
          stream = new streams.PassThrough();
          process.nextTick(function () {
            req.send();
          });
        } else {
          stream = new streams.Stream();
          stream.readable = true;
          stream.sent = false;
          stream.on('newListener', function (event) {
            if (!stream.sent && event === 'data') {
              stream.sent = true;
              process.nextTick(function () {
                req.send();
              });
            }
          });
        }
        this.on('error', function (err) {
          stream.emit('error', err);
        });
        this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
          if (statusCode < 300) {
            req.removeListener('httpData', AWS3.EventListeners.Core.HTTP_DATA);
            req.removeListener('httpError', AWS3.EventListeners.Core.HTTP_ERROR);
            req.on('httpError', function streamHttpError(error) {
              resp.error = error;
              resp.error.retryable = false;
            });
            var shouldCheckContentLength = false;
            var expectedLen;
            if (req.httpRequest.method !== 'HEAD') {
              expectedLen = parseInt(headers['content-length'], 10);
            }
            if (expectedLen !== void 0 && !isNaN(expectedLen) && expectedLen >= 0) {
              shouldCheckContentLength = true;
              var receivedLen = 0;
            }
            var checkContentLengthAndEmit = function checkContentLengthAndEmit2() {
              if (shouldCheckContentLength && receivedLen !== expectedLen) {
                stream.emit(
                  'error',
                  AWS3.util.error(
                    new Error(
                      'Stream content length mismatch. Received ' + receivedLen + ' of ' + expectedLen + ' bytes.'
                    ),
                    { code: 'StreamContentLengthMismatch' }
                  )
                );
              } else if (AWS3.HttpClient.streamsApiVersion === 2) {
                stream.end();
              } else {
                stream.emit('end');
              }
            };
            var httpStream = resp.httpResponse.createUnbufferedStream();
            if (AWS3.HttpClient.streamsApiVersion === 2) {
              if (shouldCheckContentLength) {
                var lengthAccumulator = new streams.PassThrough();
                lengthAccumulator._write = function (chunk) {
                  if (chunk && chunk.length) {
                    receivedLen += chunk.length;
                  }
                  return streams.PassThrough.prototype._write.apply(this, arguments);
                };
                lengthAccumulator.on('end', checkContentLengthAndEmit);
                stream.on('error', function (err) {
                  shouldCheckContentLength = false;
                  httpStream.unpipe(lengthAccumulator);
                  lengthAccumulator.emit('end');
                  lengthAccumulator.end();
                });
                httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
              } else {
                httpStream.pipe(stream);
              }
            } else {
              if (shouldCheckContentLength) {
                httpStream.on('data', function (arg) {
                  if (arg && arg.length) {
                    receivedLen += arg.length;
                  }
                });
              }
              httpStream.on('data', function (arg) {
                stream.emit('data', arg);
              });
              httpStream.on('end', checkContentLengthAndEmit);
            }
            httpStream.on('error', function (err) {
              shouldCheckContentLength = false;
              stream.emit('error', err);
            });
          }
        });
        return stream;
      },
      emitEvent: function emit(eventName, args, done) {
        if (typeof args === 'function') {
          done = args;
          args = null;
        }
        if (!done) done = function () {};
        if (!args) args = this.eventParameters(eventName, this.response);
        var origEmit = AWS3.SequentialExecutor.prototype.emit;
        origEmit.call(this, eventName, args, function (err) {
          if (err) this.response.error = err;
          done.call(this, err);
        });
      },
      eventParameters: function eventParameters(eventName) {
        switch (eventName) {
          case 'restart':
          case 'validate':
          case 'sign':
          case 'build':
          case 'afterValidate':
          case 'afterBuild':
            return [this];
          case 'error':
            return [this.response.error, this.response];
          default:
            return [this.response];
        }
      },
      presign: function presign(expires, callback) {
        if (!callback && typeof expires === 'function') {
          callback = expires;
          expires = null;
        }
        return new AWS3.Signers.Presign().sign(this.toGet(), expires, callback);
      },
      isPresigned: function isPresigned() {
        return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
      },
      toUnauthenticated: function toUnauthenticated() {
        this._unAuthenticated = true;
        this.removeListener('validate', AWS3.EventListeners.Core.VALIDATE_CREDENTIALS);
        this.removeListener('sign', AWS3.EventListeners.Core.SIGN);
        return this;
      },
      toGet: function toGet() {
        if (this.service.api.protocol === 'query' || this.service.api.protocol === 'ec2') {
          this.removeListener('build', this.buildAsGet);
          this.addListener('build', this.buildAsGet);
        }
        return this;
      },
      buildAsGet: function buildAsGet(request) {
        request.httpRequest.method = 'GET';
        request.httpRequest.path = request.service.endpoint.path + '?' + request.httpRequest.body;
        request.httpRequest.body = '';
        delete request.httpRequest.headers['Content-Length'];
        delete request.httpRequest.headers['Content-Type'];
      },
      haltHandlersOnError: function haltHandlersOnError() {
        this._haltHandlersOnError = true;
      },
    });
    AWS3.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.promise = function promise() {
        var self = this;
        this.httpRequest.appendToUserAgent('promise');
        return new PromiseDependency(function (resolve, reject) {
          self.on('complete', function (resp) {
            if (resp.error) {
              reject(resp.error);
            } else {
              resolve(Object.defineProperty(resp.data || {}, '$response', { value: resp }));
            }
          });
          self.runTo();
        });
      };
    };
    AWS3.Request.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.promise;
    };
    AWS3.util.addPromises(AWS3.Request);
    AWS3.util.mixin(AWS3.Request, AWS3.SequentialExecutor);
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/response.js
var require_response = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/response.js'() {
    var AWS3 = require_core();
    var inherit = AWS3.util.inherit;
    var jmespath = require_jmespath();
    AWS3.Response = inherit({
      constructor: function Response(request) {
        this.request = request;
        this.data = null;
        this.error = null;
        this.retryCount = 0;
        this.redirectCount = 0;
        this.httpResponse = new AWS3.HttpResponse();
        if (request) {
          this.maxRetries = request.service.numRetries();
          this.maxRedirects = request.service.config.maxRedirects;
        }
      },
      nextPage: function nextPage(callback) {
        var config;
        var service = this.request.service;
        var operation = this.request.operation;
        try {
          config = service.paginationConfig(operation, true);
        } catch (e) {
          this.error = e;
        }
        if (!this.hasNextPage()) {
          if (callback) callback(this.error, null);
          else if (this.error) throw this.error;
          return null;
        }
        var params = AWS3.util.copy(this.request.params);
        if (!this.nextPageTokens) {
          return callback ? callback(null, null) : null;
        } else {
          var inputTokens = config.inputToken;
          if (typeof inputTokens === 'string') inputTokens = [inputTokens];
          for (var i = 0; i < inputTokens.length; i++) {
            params[inputTokens[i]] = this.nextPageTokens[i];
          }
          return service.makeRequest(this.request.operation, params, callback);
        }
      },
      hasNextPage: function hasNextPage() {
        this.cacheNextPageTokens();
        if (this.nextPageTokens) return true;
        if (this.nextPageTokens === void 0) return void 0;
        else return false;
      },
      cacheNextPageTokens: function cacheNextPageTokens() {
        if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
        this.nextPageTokens = void 0;
        var config = this.request.service.paginationConfig(this.request.operation);
        if (!config) return this.nextPageTokens;
        this.nextPageTokens = null;
        if (config.moreResults) {
          if (!jmespath.search(this.data, config.moreResults)) {
            return this.nextPageTokens;
          }
        }
        var exprs = config.outputToken;
        if (typeof exprs === 'string') exprs = [exprs];
        AWS3.util.arrayEach.call(this, exprs, function (expr) {
          var output = jmespath.search(this.data, expr);
          if (output) {
            this.nextPageTokens = this.nextPageTokens || [];
            this.nextPageTokens.push(output);
          }
        });
        return this.nextPageTokens;
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/resource_waiter.js
var require_resource_waiter2 = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/resource_waiter.js'() {
    var AWS3 = require_core();
    var inherit = AWS3.util.inherit;
    var jmespath = require_jmespath();
    function CHECK_ACCEPTORS(resp) {
      var waiter = resp.request._waiter;
      var acceptors = waiter.config.acceptors;
      var acceptorMatched = false;
      var state = 'retry';
      acceptors.forEach(function (acceptor) {
        if (!acceptorMatched) {
          var matcher = waiter.matchers[acceptor.matcher];
          if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
            acceptorMatched = true;
            state = acceptor.state;
          }
        }
      });
      if (!acceptorMatched && resp.error) state = 'failure';
      if (state === 'success') {
        waiter.setSuccess(resp);
      } else {
        waiter.setError(resp, state === 'retry');
      }
    }
    AWS3.ResourceWaiter = inherit({
      constructor: function constructor(service, state) {
        this.service = service;
        this.state = state;
        this.loadWaiterConfig(this.state);
      },
      service: null,
      state: null,
      config: null,
      matchers: {
        path: function (resp, expected, argument) {
          try {
            var result = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          return jmespath.strictDeepEqual(result, expected);
        },
        pathAll: function (resp, expected, argument) {
          try {
            var results = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          if (!Array.isArray(results)) results = [results];
          var numResults = results.length;
          if (!numResults) return false;
          for (var ind = 0; ind < numResults; ind++) {
            if (!jmespath.strictDeepEqual(results[ind], expected)) {
              return false;
            }
          }
          return true;
        },
        pathAny: function (resp, expected, argument) {
          try {
            var results = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          if (!Array.isArray(results)) results = [results];
          var numResults = results.length;
          for (var ind = 0; ind < numResults; ind++) {
            if (jmespath.strictDeepEqual(results[ind], expected)) {
              return true;
            }
          }
          return false;
        },
        status: function (resp, expected) {
          var statusCode = resp.httpResponse.statusCode;
          return typeof statusCode === 'number' && statusCode === expected;
        },
        error: function (resp, expected) {
          if (typeof expected === 'string' && resp.error) {
            return expected === resp.error.code;
          }
          return expected === !!resp.error;
        },
      },
      listeners: new AWS3.SequentialExecutor().addNamedListeners(function (add) {
        add('RETRY_CHECK', 'retry', function (resp) {
          var waiter = resp.request._waiter;
          if (resp.error && resp.error.code === 'ResourceNotReady') {
            resp.error.retryDelay = (waiter.config.delay || 0) * 1e3;
          }
        });
        add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);
        add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
      }),
      wait: function wait(params, callback) {
        if (typeof params === 'function') {
          callback = params;
          params = void 0;
        }
        if (params && params.$waiter) {
          params = AWS3.util.copy(params);
          if (typeof params.$waiter.delay === 'number') {
            this.config.delay = params.$waiter.delay;
          }
          if (typeof params.$waiter.maxAttempts === 'number') {
            this.config.maxAttempts = params.$waiter.maxAttempts;
          }
          delete params.$waiter;
        }
        var request = this.service.makeRequest(this.config.operation, params);
        request._waiter = this;
        request.response.maxRetries = this.config.maxAttempts;
        request.addListeners(this.listeners);
        if (callback) request.send(callback);
        return request;
      },
      setSuccess: function setSuccess(resp) {
        resp.error = null;
        resp.data = resp.data || {};
        resp.request.removeAllListeners('extractData');
      },
      setError: function setError(resp, retryable) {
        resp.data = null;
        resp.error = AWS3.util.error(resp.error || new Error(), {
          code: 'ResourceNotReady',
          message: 'Resource is not in the state ' + this.state,
          retryable,
        });
      },
      loadWaiterConfig: function loadWaiterConfig(state) {
        if (!this.service.api.waiters[state]) {
          throw new AWS3.util.error(new Error(), {
            code: 'StateNotFoundError',
            message: 'State ' + state + ' not found.',
          });
        }
        this.config = AWS3.util.copy(this.service.api.waiters[state]);
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/v2.js
var require_v2 = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/v2.js'(exports, module2) {
    var AWS3 = require_core();
    var inherit = AWS3.util.inherit;
    AWS3.Signers.V2 = inherit(AWS3.Signers.RequestSigner, {
      addAuthorization: function addAuthorization(credentials, date) {
        if (!date) date = AWS3.util.date.getDate();
        var r = this.request;
        r.params.Timestamp = AWS3.util.date.iso8601(date);
        r.params.SignatureVersion = '2';
        r.params.SignatureMethod = 'HmacSHA256';
        r.params.AWSAccessKeyId = credentials.accessKeyId;
        if (credentials.sessionToken) {
          r.params.SecurityToken = credentials.sessionToken;
        }
        delete r.params.Signature;
        r.params.Signature = this.signature(credentials);
        r.body = AWS3.util.queryParamsToString(r.params);
        r.headers['Content-Length'] = r.body.length;
      },
      signature: function signature(credentials) {
        return AWS3.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
      },
      stringToSign: function stringToSign() {
        var parts = [];
        parts.push(this.request.method);
        parts.push(this.request.endpoint.host.toLowerCase());
        parts.push(this.request.pathname());
        parts.push(AWS3.util.queryParamsToString(this.request.params));
        return parts.join('\n');
      },
    });
    module2.exports = AWS3.Signers.V2;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/v3.js
var require_v3 = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/v3.js'(exports, module2) {
    var AWS3 = require_core();
    var inherit = AWS3.util.inherit;
    AWS3.Signers.V3 = inherit(AWS3.Signers.RequestSigner, {
      addAuthorization: function addAuthorization(credentials, date) {
        var datetime = AWS3.util.date.rfc822(date);
        this.request.headers['X-Amz-Date'] = datetime;
        if (credentials.sessionToken) {
          this.request.headers['x-amz-security-token'] = credentials.sessionToken;
        }
        this.request.headers['X-Amzn-Authorization'] = this.authorization(credentials, datetime);
      },
      authorization: function authorization(credentials) {
        return (
          'AWS3 AWSAccessKeyId=' +
          credentials.accessKeyId +
          ',Algorithm=HmacSHA256,SignedHeaders=' +
          this.signedHeaders() +
          ',Signature=' +
          this.signature(credentials)
        );
      },
      signedHeaders: function signedHeaders() {
        var headers = [];
        AWS3.util.arrayEach(this.headersToSign(), function iterator(h) {
          headers.push(h.toLowerCase());
        });
        return headers.sort().join(';');
      },
      canonicalHeaders: function canonicalHeaders() {
        var headers = this.request.headers;
        var parts = [];
        AWS3.util.arrayEach(this.headersToSign(), function iterator(h) {
          parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
        });
        return parts.sort().join('\n') + '\n';
      },
      headersToSign: function headersToSign() {
        var headers = [];
        AWS3.util.each(this.request.headers, function iterator(k) {
          if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
            headers.push(k);
          }
        });
        return headers;
      },
      signature: function signature(credentials) {
        return AWS3.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
      },
      stringToSign: function stringToSign() {
        var parts = [];
        parts.push(this.request.method);
        parts.push('/');
        parts.push('');
        parts.push(this.canonicalHeaders());
        parts.push(this.request.body);
        return AWS3.util.crypto.sha256(parts.join('\n'));
      },
    });
    module2.exports = AWS3.Signers.V3;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/v3https.js
var require_v3https = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/v3https.js'(exports, module2) {
    var AWS3 = require_core();
    var inherit = AWS3.util.inherit;
    require_v3();
    AWS3.Signers.V3Https = inherit(AWS3.Signers.V3, {
      authorization: function authorization(credentials) {
        return (
          'AWS3-HTTPS AWSAccessKeyId=' +
          credentials.accessKeyId +
          ',Algorithm=HmacSHA256,Signature=' +
          this.signature(credentials)
        );
      },
      stringToSign: function stringToSign() {
        return this.request.headers['X-Amz-Date'];
      },
    });
    module2.exports = AWS3.Signers.V3Https;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/v4_credentials.js
var require_v4_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/v4_credentials.js'(exports, module2) {
    var AWS3 = require_core();
    var cachedSecret = {};
    var cacheQueue = [];
    var maxCacheEntries = 50;
    var v4Identifier = 'aws4_request';
    module2.exports = {
      createScope: function createScope(date, region, serviceName) {
        return [date.substr(0, 8), region, serviceName, v4Identifier].join('/');
      },
      getSigningKey: function getSigningKey(credentials, date, region, service, shouldCache) {
        var credsIdentifier = AWS3.util.crypto.hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');
        var cacheKey = [credsIdentifier, date, region, service].join('_');
        shouldCache = shouldCache !== false;
        if (shouldCache && cacheKey in cachedSecret) {
          return cachedSecret[cacheKey];
        }
        var kDate = AWS3.util.crypto.hmac('AWS4' + credentials.secretAccessKey, date, 'buffer');
        var kRegion = AWS3.util.crypto.hmac(kDate, region, 'buffer');
        var kService = AWS3.util.crypto.hmac(kRegion, service, 'buffer');
        var signingKey = AWS3.util.crypto.hmac(kService, v4Identifier, 'buffer');
        if (shouldCache) {
          cachedSecret[cacheKey] = signingKey;
          cacheQueue.push(cacheKey);
          if (cacheQueue.length > maxCacheEntries) {
            delete cachedSecret[cacheQueue.shift()];
          }
        }
        return signingKey;
      },
      emptyCache: function emptyCache() {
        cachedSecret = {};
        cacheQueue = [];
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/v4.js
var require_v4 = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/v4.js'(exports, module2) {
    var AWS3 = require_core();
    var v4Credentials = require_v4_credentials();
    var inherit = AWS3.util.inherit;
    var expiresHeader = 'presigned-expires';
    AWS3.Signers.V4 = inherit(AWS3.Signers.RequestSigner, {
      constructor: function V4(request, serviceName, options) {
        AWS3.Signers.RequestSigner.call(this, request);
        this.serviceName = serviceName;
        options = options || {};
        this.signatureCache = typeof options.signatureCache === 'boolean' ? options.signatureCache : true;
        this.operation = options.operation;
        this.signatureVersion = options.signatureVersion;
      },
      algorithm: 'AWS4-HMAC-SHA256',
      addAuthorization: function addAuthorization(credentials, date) {
        var datetime = AWS3.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');
        if (this.isPresigned()) {
          this.updateForPresigned(credentials, datetime);
        } else {
          this.addHeaders(credentials, datetime);
        }
        this.request.headers['Authorization'] = this.authorization(credentials, datetime);
      },
      addHeaders: function addHeaders(credentials, datetime) {
        this.request.headers['X-Amz-Date'] = datetime;
        if (credentials.sessionToken) {
          this.request.headers['x-amz-security-token'] = credentials.sessionToken;
        }
      },
      updateForPresigned: function updateForPresigned(credentials, datetime) {
        var credString = this.credentialString(datetime);
        var qs = {
          'X-Amz-Date': datetime,
          'X-Amz-Algorithm': this.algorithm,
          'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
          'X-Amz-Expires': this.request.headers[expiresHeader],
          'X-Amz-SignedHeaders': this.signedHeaders(),
        };
        if (credentials.sessionToken) {
          qs['X-Amz-Security-Token'] = credentials.sessionToken;
        }
        if (this.request.headers['Content-Type']) {
          qs['Content-Type'] = this.request.headers['Content-Type'];
        }
        if (this.request.headers['Content-MD5']) {
          qs['Content-MD5'] = this.request.headers['Content-MD5'];
        }
        if (this.request.headers['Cache-Control']) {
          qs['Cache-Control'] = this.request.headers['Cache-Control'];
        }
        AWS3.util.each.call(this, this.request.headers, function (key, value) {
          if (key === expiresHeader) return;
          if (this.isSignableHeader(key)) {
            var lowerKey = key.toLowerCase();
            if (lowerKey.indexOf('x-amz-meta-') === 0) {
              qs[lowerKey] = value;
            } else if (lowerKey.indexOf('x-amz-') === 0) {
              qs[key] = value;
            }
          }
        });
        var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
        this.request.path += sep + AWS3.util.queryParamsToString(qs);
      },
      authorization: function authorization(credentials, datetime) {
        var parts = [];
        var credString = this.credentialString(datetime);
        parts.push(this.algorithm + ' Credential=' + credentials.accessKeyId + '/' + credString);
        parts.push('SignedHeaders=' + this.signedHeaders());
        parts.push('Signature=' + this.signature(credentials, datetime));
        return parts.join(', ');
      },
      signature: function signature(credentials, datetime) {
        var signingKey = v4Credentials.getSigningKey(
          credentials,
          datetime.substr(0, 8),
          this.request.region,
          this.serviceName,
          this.signatureCache
        );
        return AWS3.util.crypto.hmac(signingKey, this.stringToSign(datetime), 'hex');
      },
      stringToSign: function stringToSign(datetime) {
        var parts = [];
        parts.push('AWS4-HMAC-SHA256');
        parts.push(datetime);
        parts.push(this.credentialString(datetime));
        parts.push(this.hexEncodedHash(this.canonicalString()));
        return parts.join('\n');
      },
      canonicalString: function canonicalString() {
        var parts = [],
          pathname = this.request.pathname();
        if (this.serviceName !== 's3' && this.signatureVersion !== 's3v4') pathname = AWS3.util.uriEscapePath(pathname);
        parts.push(this.request.method);
        parts.push(pathname);
        parts.push(this.request.search());
        parts.push(this.canonicalHeaders() + '\n');
        parts.push(this.signedHeaders());
        parts.push(this.hexEncodedBodyHash());
        return parts.join('\n');
      },
      canonicalHeaders: function canonicalHeaders() {
        var headers = [];
        AWS3.util.each.call(this, this.request.headers, function (key, item) {
          headers.push([key, item]);
        });
        headers.sort(function (a, b) {
          return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
        });
        var parts = [];
        AWS3.util.arrayEach.call(this, headers, function (item) {
          var key = item[0].toLowerCase();
          if (this.isSignableHeader(key)) {
            var value = item[1];
            if (typeof value === 'undefined' || value === null || typeof value.toString !== 'function') {
              throw AWS3.util.error(new Error('Header ' + key + ' contains invalid value'), {
                code: 'InvalidHeader',
              });
            }
            parts.push(key + ':' + this.canonicalHeaderValues(value.toString()));
          }
        });
        return parts.join('\n');
      },
      canonicalHeaderValues: function canonicalHeaderValues(values) {
        return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
      },
      signedHeaders: function signedHeaders() {
        var keys = [];
        AWS3.util.each.call(this, this.request.headers, function (key) {
          key = key.toLowerCase();
          if (this.isSignableHeader(key)) keys.push(key);
        });
        return keys.sort().join(';');
      },
      credentialString: function credentialString(datetime) {
        return v4Credentials.createScope(datetime.substr(0, 8), this.request.region, this.serviceName);
      },
      hexEncodedHash: function hash(string) {
        return AWS3.util.crypto.sha256(string, 'hex');
      },
      hexEncodedBodyHash: function hexEncodedBodyHash() {
        var request = this.request;
        if (this.isPresigned() && ['s3', 's3-object-lambda'].indexOf(this.serviceName) > -1 && !request.body) {
          return 'UNSIGNED-PAYLOAD';
        } else if (request.headers['X-Amz-Content-Sha256']) {
          return request.headers['X-Amz-Content-Sha256'];
        } else {
          return this.hexEncodedHash(this.request.body || '');
        }
      },
      unsignableHeaders: [
        'authorization',
        'content-type',
        'content-length',
        'user-agent',
        expiresHeader,
        'expect',
        'x-amzn-trace-id',
      ],
      isSignableHeader: function isSignableHeader(key) {
        if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
        return this.unsignableHeaders.indexOf(key) < 0;
      },
      isPresigned: function isPresigned() {
        return this.request.headers[expiresHeader] ? true : false;
      },
    });
    module2.exports = AWS3.Signers.V4;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/s3.js
var require_s3 = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/s3.js'(exports, module2) {
    var AWS3 = require_core();
    var inherit = AWS3.util.inherit;
    AWS3.Signers.S3 = inherit(AWS3.Signers.RequestSigner, {
      subResources: {
        acl: 1,
        accelerate: 1,
        analytics: 1,
        cors: 1,
        lifecycle: 1,
        delete: 1,
        inventory: 1,
        location: 1,
        logging: 1,
        metrics: 1,
        notification: 1,
        partNumber: 1,
        policy: 1,
        requestPayment: 1,
        replication: 1,
        restore: 1,
        tagging: 1,
        torrent: 1,
        uploadId: 1,
        uploads: 1,
        versionId: 1,
        versioning: 1,
        versions: 1,
        website: 1,
      },
      responseHeaders: {
        'response-content-type': 1,
        'response-content-language': 1,
        'response-expires': 1,
        'response-cache-control': 1,
        'response-content-disposition': 1,
        'response-content-encoding': 1,
      },
      addAuthorization: function addAuthorization(credentials, date) {
        if (!this.request.headers['presigned-expires']) {
          this.request.headers['X-Amz-Date'] = AWS3.util.date.rfc822(date);
        }
        if (credentials.sessionToken) {
          this.request.headers['x-amz-security-token'] = credentials.sessionToken;
        }
        var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
        var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;
        this.request.headers['Authorization'] = auth;
      },
      stringToSign: function stringToSign() {
        var r = this.request;
        var parts = [];
        parts.push(r.method);
        parts.push(r.headers['Content-MD5'] || '');
        parts.push(r.headers['Content-Type'] || '');
        parts.push(r.headers['presigned-expires'] || '');
        var headers = this.canonicalizedAmzHeaders();
        if (headers) parts.push(headers);
        parts.push(this.canonicalizedResource());
        return parts.join('\n');
      },
      canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {
        var amzHeaders = [];
        AWS3.util.each(this.request.headers, function (name) {
          if (name.match(/^x-amz-/i)) amzHeaders.push(name);
        });
        amzHeaders.sort(function (a, b) {
          return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
        });
        var parts = [];
        AWS3.util.arrayEach.call(this, amzHeaders, function (name) {
          parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
        });
        return parts.join('\n');
      },
      canonicalizedResource: function canonicalizedResource() {
        var r = this.request;
        var parts = r.path.split('?');
        var path = parts[0];
        var querystring = parts[1];
        var resource = '';
        if (r.virtualHostedBucket) resource += '/' + r.virtualHostedBucket;
        resource += path;
        if (querystring) {
          var resources = [];
          AWS3.util.arrayEach.call(this, querystring.split('&'), function (param) {
            var name = param.split('=')[0];
            var value = param.split('=')[1];
            if (this.subResources[name] || this.responseHeaders[name]) {
              var subresource = { name };
              if (value !== void 0) {
                if (this.subResources[name]) {
                  subresource.value = value;
                } else {
                  subresource.value = decodeURIComponent(value);
                }
              }
              resources.push(subresource);
            }
          });
          resources.sort(function (a, b) {
            return a.name < b.name ? -1 : 1;
          });
          if (resources.length) {
            querystring = [];
            AWS3.util.arrayEach(resources, function (res) {
              if (res.value === void 0) {
                querystring.push(res.name);
              } else {
                querystring.push(res.name + '=' + res.value);
              }
            });
            resource += '?' + querystring.join('&');
          }
        }
        return resource;
      },
      sign: function sign(secret, string) {
        return AWS3.util.crypto.hmac(secret, string, 'base64', 'sha1');
      },
    });
    module2.exports = AWS3.Signers.S3;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/presign.js
var require_presign = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/presign.js'(exports, module2) {
    var AWS3 = require_core();
    var inherit = AWS3.util.inherit;
    var expiresHeader = 'presigned-expires';
    function signedUrlBuilder(request) {
      var expires = request.httpRequest.headers[expiresHeader];
      var signerClass = request.service.getSignerClass(request);
      delete request.httpRequest.headers['User-Agent'];
      delete request.httpRequest.headers['X-Amz-User-Agent'];
      if (signerClass === AWS3.Signers.V4) {
        if (expires > 604800) {
          var message = 'Presigning does not support expiry time greater than a week with SigV4 signing.';
          throw AWS3.util.error(new Error(), {
            code: 'InvalidExpiryTime',
            message,
            retryable: false,
          });
        }
        request.httpRequest.headers[expiresHeader] = expires;
      } else if (signerClass === AWS3.Signers.S3) {
        var now = request.service ? request.service.getSkewCorrectedDate() : AWS3.util.date.getDate();
        request.httpRequest.headers[expiresHeader] = parseInt(
          AWS3.util.date.unixTimestamp(now) + expires,
          10
        ).toString();
      } else {
        throw AWS3.util.error(new Error(), {
          message: 'Presigning only supports S3 or SigV4 signing.',
          code: 'UnsupportedSigner',
          retryable: false,
        });
      }
    }
    function signedUrlSigner(request) {
      var endpoint = request.httpRequest.endpoint;
      var parsedUrl = AWS3.util.urlParse(request.httpRequest.path);
      var queryParams = {};
      if (parsedUrl.search) {
        queryParams = AWS3.util.queryStringParse(parsedUrl.search.substr(1));
      }
      var auth = request.httpRequest.headers['Authorization'].split(' ');
      if (auth[0] === 'AWS') {
        auth = auth[1].split(':');
        queryParams['Signature'] = auth.pop();
        queryParams['AWSAccessKeyId'] = auth.join(':');
        AWS3.util.each(request.httpRequest.headers, function (key, value) {
          if (key === expiresHeader) key = 'Expires';
          if (key.indexOf('x-amz-meta-') === 0) {
            delete queryParams[key];
            key = key.toLowerCase();
          }
          queryParams[key] = value;
        });
        delete request.httpRequest.headers[expiresHeader];
        delete queryParams['Authorization'];
        delete queryParams['Host'];
      } else if (auth[0] === 'AWS4-HMAC-SHA256') {
        auth.shift();
        var rest = auth.join(' ');
        var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
        queryParams['X-Amz-Signature'] = signature;
        delete queryParams['Expires'];
      }
      endpoint.pathname = parsedUrl.pathname;
      endpoint.search = AWS3.util.queryParamsToString(queryParams);
    }
    AWS3.Signers.Presign = inherit({
      sign: function sign(request, expireTime, callback) {
        request.httpRequest.headers[expiresHeader] = expireTime || 3600;
        request.on('build', signedUrlBuilder);
        request.on('sign', signedUrlSigner);
        request.removeListener('afterBuild', AWS3.EventListeners.Core.SET_CONTENT_LENGTH);
        request.removeListener('afterBuild', AWS3.EventListeners.Core.COMPUTE_SHA256);
        request.emit('beforePresign', [request]);
        if (callback) {
          request.build(function () {
            if (this.response.error) callback(this.response.error);
            else {
              callback(null, AWS3.util.urlFormat(request.httpRequest.endpoint));
            }
          });
        } else {
          request.build();
          if (request.response.error) throw request.response.error;
          return AWS3.util.urlFormat(request.httpRequest.endpoint);
        }
      },
    });
    module2.exports = AWS3.Signers.Presign;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/bearer.js
var require_bearer = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/bearer.js'() {
    var AWS3 = require_core();
    AWS3.Signers.Bearer = AWS3.util.inherit(AWS3.Signers.RequestSigner, {
      constructor: function Bearer(request) {
        AWS3.Signers.RequestSigner.call(this, request);
      },
      addAuthorization: function addAuthorization(token) {
        this.request.headers['Authorization'] = 'Bearer ' + token.token;
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/request_signer.js
var require_request_signer = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/signers/request_signer.js'() {
    var AWS3 = require_core();
    var inherit = AWS3.util.inherit;
    AWS3.Signers.RequestSigner = inherit({
      constructor: function RequestSigner(request) {
        this.request = request;
      },
      setServiceClientId: function setServiceClientId(id) {
        this.serviceClientId = id;
      },
      getServiceClientId: function getServiceClientId() {
        return this.serviceClientId;
      },
    });
    AWS3.Signers.RequestSigner.getVersion = function getVersion(version) {
      switch (version) {
        case 'v2':
          return AWS3.Signers.V2;
        case 'v3':
          return AWS3.Signers.V3;
        case 's3v4':
          return AWS3.Signers.V4;
        case 'v4':
          return AWS3.Signers.V4;
        case 's3':
          return AWS3.Signers.S3;
        case 'v3https':
          return AWS3.Signers.V3Https;
        case 'bearer':
          return AWS3.Signers.Bearer;
      }
      throw new Error('Unknown signing version ' + version);
    };
    require_v2();
    require_v3();
    require_v3https();
    require_v4();
    require_s3();
    require_presign();
    require_bearer();
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/param_validator.js
var require_param_validator = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/param_validator.js'() {
    var AWS3 = require_core();
    AWS3.ParamValidator = AWS3.util.inherit({
      constructor: function ParamValidator(validation) {
        if (validation === true || validation === void 0) {
          validation = { min: true };
        }
        this.validation = validation;
      },
      validate: function validate(shape, params, context) {
        this.errors = [];
        this.validateMember(shape, params || {}, context || 'params');
        if (this.errors.length > 1) {
          var msg = this.errors.join('\n* ');
          msg = 'There were ' + this.errors.length + ' validation errors:\n* ' + msg;
          throw AWS3.util.error(new Error(msg), { code: 'MultipleValidationErrors', errors: this.errors });
        } else if (this.errors.length === 1) {
          throw this.errors[0];
        } else {
          return true;
        }
      },
      fail: function fail(code, message) {
        this.errors.push(AWS3.util.error(new Error(message), { code }));
      },
      validateStructure: function validateStructure(shape, params, context) {
        if (shape.isDocument) return true;
        this.validateType(params, context, ['object'], 'structure');
        var paramName;
        for (var i = 0; shape.required && i < shape.required.length; i++) {
          paramName = shape.required[i];
          var value = params[paramName];
          if (value === void 0 || value === null) {
            this.fail('MissingRequiredParameter', "Missing required key '" + paramName + "' in " + context);
          }
        }
        for (paramName in params) {
          if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;
          var paramValue = params[paramName],
            memberShape = shape.members[paramName];
          if (memberShape !== void 0) {
            var memberContext = [context, paramName].join('.');
            this.validateMember(memberShape, paramValue, memberContext);
          } else if (paramValue !== void 0 && paramValue !== null) {
            this.fail('UnexpectedParameter', "Unexpected key '" + paramName + "' found in " + context);
          }
        }
        return true;
      },
      validateMember: function validateMember(shape, param, context) {
        switch (shape.type) {
          case 'structure':
            return this.validateStructure(shape, param, context);
          case 'list':
            return this.validateList(shape, param, context);
          case 'map':
            return this.validateMap(shape, param, context);
          default:
            return this.validateScalar(shape, param, context);
        }
      },
      validateList: function validateList(shape, params, context) {
        if (this.validateType(params, context, [Array])) {
          this.validateRange(shape, params.length, context, 'list member count');
          for (var i = 0; i < params.length; i++) {
            this.validateMember(shape.member, params[i], context + '[' + i + ']');
          }
        }
      },
      validateMap: function validateMap(shape, params, context) {
        if (this.validateType(params, context, ['object'], 'map')) {
          var mapCount = 0;
          for (var param in params) {
            if (!Object.prototype.hasOwnProperty.call(params, param)) continue;
            this.validateMember(shape.key, param, context + "[key='" + param + "']");
            this.validateMember(shape.value, params[param], context + "['" + param + "']");
            mapCount++;
          }
          this.validateRange(shape, mapCount, context, 'map member count');
        }
      },
      validateScalar: function validateScalar(shape, value, context) {
        switch (shape.type) {
          case null:
          case void 0:
          case 'string':
            return this.validateString(shape, value, context);
          case 'base64':
          case 'binary':
            return this.validatePayload(value, context);
          case 'integer':
          case 'float':
            return this.validateNumber(shape, value, context);
          case 'boolean':
            return this.validateType(value, context, ['boolean']);
          case 'timestamp':
            return this.validateType(
              value,
              context,
              [Date, /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],
              'Date object, ISO-8601 string, or a UNIX timestamp'
            );
          default:
            return this.fail('UnkownType', 'Unhandled type ' + shape.type + ' for ' + context);
        }
      },
      validateString: function validateString(shape, value, context) {
        var validTypes = ['string'];
        if (shape.isJsonValue) {
          validTypes = validTypes.concat(['number', 'object', 'boolean']);
        }
        if (value !== null && this.validateType(value, context, validTypes)) {
          this.validateEnum(shape, value, context);
          this.validateRange(shape, value.length, context, 'string length');
          this.validatePattern(shape, value, context);
          this.validateUri(shape, value, context);
        }
      },
      validateUri: function validateUri(shape, value, context) {
        if (shape['location'] === 'uri') {
          if (value.length === 0) {
            this.fail(
              'UriParameterError',
              'Expected uri parameter to have length >= 1, but found "' + value + '" for ' + context
            );
          }
        }
      },
      validatePattern: function validatePattern(shape, value, context) {
        if (this.validation['pattern'] && shape['pattern'] !== void 0) {
          if (!new RegExp(shape['pattern']).test(value)) {
            this.fail(
              'PatternMatchError',
              'Provided value "' + value + '" does not match regex pattern /' + shape['pattern'] + '/ for ' + context
            );
          }
        }
      },
      validateRange: function validateRange(shape, value, context, descriptor) {
        if (this.validation['min']) {
          if (shape['min'] !== void 0 && value < shape['min']) {
            this.fail(
              'MinRangeError',
              'Expected ' + descriptor + ' >= ' + shape['min'] + ', but found ' + value + ' for ' + context
            );
          }
        }
        if (this.validation['max']) {
          if (shape['max'] !== void 0 && value > shape['max']) {
            this.fail(
              'MaxRangeError',
              'Expected ' + descriptor + ' <= ' + shape['max'] + ', but found ' + value + ' for ' + context
            );
          }
        }
      },
      validateEnum: function validateRange(shape, value, context) {
        if (this.validation['enum'] && shape['enum'] !== void 0) {
          if (shape['enum'].indexOf(value) === -1) {
            this.fail(
              'EnumError',
              'Found string value of ' + value + ', but expected ' + shape['enum'].join('|') + ' for ' + context
            );
          }
        }
      },
      validateType: function validateType(value, context, acceptedTypes, type) {
        if (value === null || value === void 0) return false;
        var foundInvalidType = false;
        for (var i = 0; i < acceptedTypes.length; i++) {
          if (typeof acceptedTypes[i] === 'string') {
            if (typeof value === acceptedTypes[i]) return true;
          } else if (acceptedTypes[i] instanceof RegExp) {
            if ((value || '').toString().match(acceptedTypes[i])) return true;
          } else {
            if (value instanceof acceptedTypes[i]) return true;
            if (AWS3.util.isType(value, acceptedTypes[i])) return true;
            if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
            acceptedTypes[i] = AWS3.util.typeName(acceptedTypes[i]);
          }
          foundInvalidType = true;
        }
        var acceptedType = type;
        if (!acceptedType) {
          acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
        }
        var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
        this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' + vowel + ' ' + acceptedType);
        return false;
      },
      validateNumber: function validateNumber(shape, value, context) {
        if (value === null || value === void 0) return;
        if (typeof value === 'string') {
          var castedValue = parseFloat(value);
          if (castedValue.toString() === value) value = castedValue;
        }
        if (this.validateType(value, context, ['number'])) {
          this.validateRange(shape, value, context, 'numeric value');
        }
      },
      validatePayload: function validatePayload(value, context) {
        if (value === null || value === void 0) return;
        if (typeof value === 'string') return;
        if (value && typeof value.byteLength === 'number') return;
        if (AWS3.util.isNode()) {
          var Stream = AWS3.util.stream.Stream;
          if (AWS3.util.Buffer.isBuffer(value) || value instanceof Stream) return;
        } else {
          if (typeof Blob !== void 0 && value instanceof Blob) return;
        }
        var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];
        if (value) {
          for (var i = 0; i < types.length; i++) {
            if (AWS3.util.isType(value, types[i])) return;
            if (AWS3.util.typeName(value.constructor) === types[i]) return;
          }
        }
        this.fail(
          'InvalidParameterType',
          'Expected ' + context + ' to be a string, Buffer, Stream, Blob, or typed array object'
        );
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/maintenance_mode_message.js
var require_maintenance_mode_message = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/maintenance_mode_message.js'(exports, module2) {
    var warning = [
      'We are formalizing our plans to enter AWS SDK for JavaScript (v2) into maintenance mode in 2023.\n',
      'Please migrate your code to use AWS SDK for JavaScript (v3).',
      'For more information, check the migration guide at https://a.co/7PzMCcy',
    ].join('\n');
    module2.exports = {
      suppress: false,
    };
    function emitWarning() {
      if (typeof process === 'undefined') return;
      if (
        typeof process.env === 'object' &&
        typeof process.env.AWS_EXECUTION_ENV !== 'undefined' &&
        process.env.AWS_EXECUTION_ENV.indexOf('AWS_Lambda_') === 0
      ) {
        return;
      }
      if (
        typeof process.env === 'object' &&
        typeof process.env.AWS_SDK_JS_SUPPRESS_MAINTENANCE_MODE_MESSAGE !== 'undefined'
      ) {
        return;
      }
      if (typeof process.emitWarning === 'function') {
        process.emitWarning(warning, {
          type: 'NOTE',
        });
      }
    }
    setTimeout(function () {
      if (!module2.exports.suppress) {
        emitWarning();
      }
    }, 0);
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/core.js
var require_core = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/core.js'(exports, module2) {
    var AWS3 = { util: require_util() };
    var _hidden = {};
    _hidden.toString();
    module2.exports = AWS3;
    AWS3.util.update(AWS3, {
      VERSION: '2.1483.0',
      Signers: {},
      Protocol: {
        Json: require_json(),
        Query: require_query(),
        Rest: require_rest(),
        RestJson: require_rest_json(),
        RestXml: require_rest_xml(),
      },
      XML: {
        Builder: require_builder2(),
        Parser: null,
      },
      JSON: {
        Builder: require_builder(),
        Parser: require_parser(),
      },
      Model: {
        Api: require_api(),
        Operation: require_operation(),
        Shape: require_shape(),
        Paginator: require_paginator(),
        ResourceWaiter: require_resource_waiter(),
      },
      apiLoader: require_api_loader(),
      EndpointCache: require_endpoint_cache().EndpointCache,
    });
    require_sequential_executor();
    require_service();
    require_config();
    require_http();
    require_event_listeners();
    require_request();
    require_response();
    require_resource_waiter2();
    require_request_signer();
    require_param_validator();
    require_maintenance_mode_message();
    AWS3.events = new AWS3.SequentialExecutor();
    AWS3.util.memoizedProperty(
      AWS3,
      'endpointCache',
      function () {
        return new AWS3.EndpointCache(AWS3.config.endpointCacheSize);
      },
      true
    );
  },
});

// node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/rng.js
var require_rng = __commonJS({
  'node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/rng.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = rng;
    var _crypto = _interopRequireDefault(require('crypto'));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function rng() {
      return _crypto.default.randomBytes(16);
    }
  },
});

// node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  'node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/bytesToUuid.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        '-',
        bth[buf[i2++]],
        bth[buf[i2++]],
        '-',
        bth[buf[i2++]],
        bth[buf[i2++]],
        '-',
        bth[buf[i2++]],
        bth[buf[i2++]],
        '-',
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
      ].join('');
    }
    var _default = bytesToUuid;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  'node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/v1.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = (buf && offset) || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = ((seedBytes[6] << 8) | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = (clockseq + 1) & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = (tl >>> 24) & 255;
      b[i++] = (tl >>> 16) & 255;
      b[i++] = (tl >>> 8) & 255;
      b[i++] = tl & 255;
      var tmh = ((msecs / 4294967296) * 1e4) & 268435455;
      b[i++] = (tmh >>> 8) & 255;
      b[i++] = tmh & 255;
      b[i++] = ((tmh >>> 24) & 15) | 16;
      b[i++] = (tmh >>> 16) & 255;
      b[i++] = (clockseq >>> 8) | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : (0, _bytesToUuid.default)(b);
    }
    var _default = v1;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  'node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/v35.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = _default;
    exports.URL = exports.DNS = void 0;
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function uuidToBytes(uuid) {
      var bytes = [];
      uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {
        bytes.push(parseInt(hex, 16));
      });
      return bytes;
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      var bytes = new Array(str.length);
      for (var i = 0; i < str.length; i++) {
        bytes[i] = str.charCodeAt(i);
      }
      return bytes;
    }
    var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    exports.DNS = DNS;
    var URL2 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
    exports.URL = URL2;
    function _default(name, version, hashfunc) {
      var generateUUID = function (value, namespace, buf, offset) {
        var off = (buf && offset) || 0;
        if (typeof value == 'string') value = stringToBytes(value);
        if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
        if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
        if (!Array.isArray(namespace) || namespace.length !== 16)
          throw TypeError('namespace must be uuid string or an Array of 16 byte values');
        var bytes = hashfunc(namespace.concat(value));
        bytes[6] = (bytes[6] & 15) | version;
        bytes[8] = (bytes[8] & 63) | 128;
        if (buf) {
          for (var idx = 0; idx < 16; ++idx) {
            buf[off + idx] = bytes[idx];
          }
        }
        return buf || (0, _bytesToUuid.default)(bytes);
      };
      try {
        generateUUID.name = name;
      } catch (err) {}
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  },
});

// node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  'node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/md5.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require('crypto'));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
      }
      return _crypto.default.createHash('md5').update(bytes).digest();
    }
    var _default = md5;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/v3.js
var require_v32 = __commonJS({
  'node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/v3.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)('v3', 48, _md.default);
    var _default = v3;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/v4.js
var require_v42 = __commonJS({
  'node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/v4.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      var i = (buf && offset) || 0;
      if (typeof options == 'string') {
        buf = options === 'binary' ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = (rnds[6] & 15) | 64;
      rnds[8] = (rnds[8] & 63) | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || (0, _bytesToUuid.default)(rnds);
    }
    var _default = v4;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  'node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/sha1.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require('crypto'));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
      }
      return _crypto.default.createHash('sha1').update(bytes).digest();
    }
    var _default = sha1;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  'node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/v5.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)('v5', 80, _sha.default);
    var _default = v5;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/index.js
var require_dist = __commonJS({
  'node_modules/.pnpm/uuid@8.0.0/node_modules/uuid/dist/index.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'v1', {
      enumerable: true,
      get: function () {
        return _v.default;
      },
    });
    Object.defineProperty(exports, 'v3', {
      enumerable: true,
      get: function () {
        return _v2.default;
      },
    });
    Object.defineProperty(exports, 'v4', {
      enumerable: true,
      get: function () {
        return _v3.default;
      },
    });
    Object.defineProperty(exports, 'v5', {
      enumerable: true,
      get: function () {
        return _v4.default;
      },
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v32());
    var _v3 = _interopRequireDefault(require_v42());
    var _v4 = _interopRequireDefault(require_v5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/util.js
var require_util = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/util.js'(exports, module2) {
    var AWS3;
    var util = {
      environment: 'nodejs',
      engine: function engine() {
        if (util.isBrowser() && typeof navigator !== 'undefined') {
          return navigator.userAgent;
        } else {
          var engine2 = process.platform + '/' + process.version;
          if (process.env.AWS_EXECUTION_ENV) {
            engine2 += ' exec-env/' + process.env.AWS_EXECUTION_ENV;
          }
          return engine2;
        }
      },
      userAgent: function userAgent() {
        var name = util.environment;
        var agent = 'aws-sdk-' + name + '/' + require_core().VERSION;
        if (name === 'nodejs') agent += ' ' + util.engine();
        return agent;
      },
      uriEscape: function uriEscape(string) {
        var output = encodeURIComponent(string);
        output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);
        output = output.replace(/[*]/g, function (ch) {
          return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
        });
        return output;
      },
      uriEscapePath: function uriEscapePath(string) {
        var parts = [];
        util.arrayEach(string.split('/'), function (part) {
          parts.push(util.uriEscape(part));
        });
        return parts.join('/');
      },
      urlParse: function urlParse(url) {
        return util.url.parse(url);
      },
      urlFormat: function urlFormat(url) {
        return util.url.format(url);
      },
      queryStringParse: function queryStringParse(qs) {
        return util.querystring.parse(qs);
      },
      queryParamsToString: function queryParamsToString(params) {
        var items = [];
        var escape2 = util.uriEscape;
        var sortedKeys = Object.keys(params).sort();
        util.arrayEach(sortedKeys, function (name) {
          var value = params[name];
          var ename = escape2(name);
          var result = ename + '=';
          if (Array.isArray(value)) {
            var vals = [];
            util.arrayEach(value, function (item) {
              vals.push(escape2(item));
            });
            result = ename + '=' + vals.sort().join('&' + ename + '=');
          } else if (value !== void 0 && value !== null) {
            result = ename + '=' + escape2(value);
          }
          items.push(result);
        });
        return items.join('&');
      },
      readFileSync: function readFileSync(path) {
        if (util.isBrowser()) return null;
        return require('fs').readFileSync(path, 'utf-8');
      },
      base64: {
        encode: function encode64(string) {
          if (typeof string === 'number') {
            throw util.error(new Error('Cannot base64 encode number ' + string));
          }
          if (string === null || typeof string === 'undefined') {
            return string;
          }
          var buf = util.buffer.toBuffer(string);
          return buf.toString('base64');
        },
        decode: function decode64(string) {
          if (typeof string === 'number') {
            throw util.error(new Error('Cannot base64 decode number ' + string));
          }
          if (string === null || typeof string === 'undefined') {
            return string;
          }
          return util.buffer.toBuffer(string, 'base64');
        },
      },
      buffer: {
        toBuffer: function (data, encoding) {
          return typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from
            ? util.Buffer.from(data, encoding)
            : new util.Buffer(data, encoding);
        },
        alloc: function (size, fill, encoding) {
          if (typeof size !== 'number') {
            throw new Error('size passed to alloc must be a number.');
          }
          if (typeof util.Buffer.alloc === 'function') {
            return util.Buffer.alloc(size, fill, encoding);
          } else {
            var buf = new util.Buffer(size);
            if (fill !== void 0 && typeof buf.fill === 'function') {
              buf.fill(fill, void 0, void 0, encoding);
            }
            return buf;
          }
        },
        toStream: function toStream(buffer) {
          if (!util.Buffer.isBuffer(buffer)) buffer = util.buffer.toBuffer(buffer);
          var readable = new util.stream.Readable();
          var pos = 0;
          readable._read = function (size) {
            if (pos >= buffer.length) return readable.push(null);
            var end = pos + size;
            if (end > buffer.length) end = buffer.length;
            readable.push(buffer.slice(pos, end));
            pos = end;
          };
          return readable;
        },
        concat: function (buffers) {
          var length = 0,
            offset = 0,
            buffer = null,
            i;
          for (i = 0; i < buffers.length; i++) {
            length += buffers[i].length;
          }
          buffer = util.buffer.alloc(length);
          for (i = 0; i < buffers.length; i++) {
            buffers[i].copy(buffer, offset);
            offset += buffers[i].length;
          }
          return buffer;
        },
      },
      string: {
        byteLength: function byteLength(string) {
          if (string === null || string === void 0) return 0;
          if (typeof string === 'string') string = util.buffer.toBuffer(string);
          if (typeof string.byteLength === 'number') {
            return string.byteLength;
          } else if (typeof string.length === 'number') {
            return string.length;
          } else if (typeof string.size === 'number') {
            return string.size;
          } else if (typeof string.path === 'string') {
            return require('fs').lstatSync(string.path).size;
          } else {
            throw util.error(new Error('Cannot determine length of ' + string), { object: string });
          }
        },
        upperFirst: function upperFirst(string) {
          return string[0].toUpperCase() + string.substr(1);
        },
        lowerFirst: function lowerFirst(string) {
          return string[0].toLowerCase() + string.substr(1);
        },
      },
      ini: {
        parse: function string(ini) {
          var currentSection,
            map = {};
          util.arrayEach(ini.split(/\r?\n/), function (line) {
            line = line.split(/(^|\s)[;#]/)[0].trim();
            var isSection = line[0] === '[' && line[line.length - 1] === ']';
            if (isSection) {
              currentSection = line.substring(1, line.length - 1);
              if (currentSection === '__proto__' || currentSection.split(/\s/)[1] === '__proto__') {
                throw util.error(new Error("Cannot load profile name '" + currentSection + "' from shared ini file."));
              }
            } else if (currentSection) {
              var indexOfEqualsSign = line.indexOf('=');
              var start = 0;
              var end = line.length - 1;
              var isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
              if (isAssignment) {
                var name = line.substring(0, indexOfEqualsSign).trim();
                var value = line.substring(indexOfEqualsSign + 1).trim();
                map[currentSection] = map[currentSection] || {};
                map[currentSection][name] = value;
              }
            }
          });
          return map;
        },
      },
      fn: {
        noop: function () {},
        callback: function (err) {
          if (err) throw err;
        },
        makeAsync: function makeAsync(fn, expectedArgs) {
          if (expectedArgs && expectedArgs <= fn.length) {
            return fn;
          }
          return function () {
            var args = Array.prototype.slice.call(arguments, 0);
            var callback = args.pop();
            var result = fn.apply(null, args);
            callback(result);
          };
        },
      },
      date: {
        getDate: function getDate() {
          if (!AWS3) AWS3 = require_core();
          if (AWS3.config.systemClockOffset) {
            return new Date(new Date().getTime() + AWS3.config.systemClockOffset);
          } else {
            return new Date();
          }
        },
        iso8601: function iso8601(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
        },
        rfc822: function rfc822(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.toUTCString();
        },
        unixTimestamp: function unixTimestamp(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.getTime() / 1e3;
        },
        from: function format(date) {
          if (typeof date === 'number') {
            return new Date(date * 1e3);
          } else {
            return new Date(date);
          }
        },
        format: function format(date, formatter) {
          if (!formatter) formatter = 'iso8601';
          return util.date[formatter](util.date.from(date));
        },
        parseTimestamp: function parseTimestamp(value) {
          if (typeof value === 'number') {
            return new Date(value * 1e3);
          } else if (value.match(/^\d+$/)) {
            return new Date(value * 1e3);
          } else if (value.match(/^\d{4}/)) {
            return new Date(value);
          } else if (value.match(/^\w{3},/)) {
            return new Date(value);
          } else {
            throw util.error(new Error('unhandled timestamp format: ' + value), { code: 'TimestampParserError' });
          }
        },
      },
      crypto: {
        crc32Table: [
          0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324,
          3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648,
          2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636,
          335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145,
          1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101,
          3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705,
          3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565,
          1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290,
          251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866,
          2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202,
          4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538,
          1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467,
          855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635,
          3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443,
          3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523,
          3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580,
          2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920,
          282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732,
          1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512,
          3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109,
          3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625,
          752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877,
          83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881,
          2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934,
          4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406,
          1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270,
          936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150,
          3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471,
          3272380065, 1510334235, 755167117,
        ],
        crc32: function crc32(data) {
          var tbl = util.crypto.crc32Table;
          var crc = 0 ^ -1;
          if (typeof data === 'string') {
            data = util.buffer.toBuffer(data);
          }
          for (var i = 0; i < data.length; i++) {
            var code = data.readUInt8(i);
            crc = (crc >>> 8) ^ tbl[(crc ^ code) & 255];
          }
          return (crc ^ -1) >>> 0;
        },
        hmac: function hmac(key, string, digest, fn) {
          if (!digest) digest = 'binary';
          if (digest === 'buffer') {
            digest = void 0;
          }
          if (!fn) fn = 'sha256';
          if (typeof string === 'string') string = util.buffer.toBuffer(string);
          return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
        },
        md5: function md5(data, digest, callback) {
          return util.crypto.hash('md5', data, digest, callback);
        },
        sha256: function sha256(data, digest, callback) {
          return util.crypto.hash('sha256', data, digest, callback);
        },
        hash: function (algorithm, data, digest, callback) {
          var hash = util.crypto.createHash(algorithm);
          if (!digest) {
            digest = 'binary';
          }
          if (digest === 'buffer') {
            digest = void 0;
          }
          if (typeof data === 'string') data = util.buffer.toBuffer(data);
          var sliceFn = util.arraySliceFn(data);
          var isBuffer = util.Buffer.isBuffer(data);
          if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer)
            isBuffer = true;
          if (callback && typeof data === 'object' && typeof data.on === 'function' && !isBuffer) {
            data.on('data', function (chunk) {
              hash.update(chunk);
            });
            data.on('error', function (err) {
              callback(err);
            });
            data.on('end', function () {
              callback(null, hash.digest(digest));
            });
          } else if (callback && sliceFn && !isBuffer && typeof FileReader !== 'undefined') {
            var index = 0,
              size = 1024 * 512;
            var reader = new FileReader();
            reader.onerror = function () {
              callback(new Error('Failed to read data.'));
            };
            reader.onload = function () {
              var buf = new util.Buffer(new Uint8Array(reader.result));
              hash.update(buf);
              index += buf.length;
              reader._continueReading();
            };
            reader._continueReading = function () {
              if (index >= data.size) {
                callback(null, hash.digest(digest));
                return;
              }
              var back = index + size;
              if (back > data.size) back = data.size;
              reader.readAsArrayBuffer(sliceFn.call(data, index, back));
            };
            reader._continueReading();
          } else {
            if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
              data = new util.Buffer(new Uint8Array(data));
            }
            var out = hash.update(data).digest(digest);
            if (callback) callback(null, out);
            return out;
          }
        },
        toHex: function toHex(data) {
          var out = [];
          for (var i = 0; i < data.length; i++) {
            out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
          }
          return out.join('');
        },
        createHash: function createHash(algorithm) {
          return util.crypto.lib.createHash(algorithm);
        },
      },
      abort: {},
      each: function each(object, iterFunction) {
        for (var key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            var ret = iterFunction.call(this, key, object[key]);
            if (ret === util.abort) break;
          }
        }
      },
      arrayEach: function arrayEach(array, iterFunction) {
        for (var idx in array) {
          if (Object.prototype.hasOwnProperty.call(array, idx)) {
            var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
            if (ret === util.abort) break;
          }
        }
      },
      update: function update(obj1, obj2) {
        util.each(obj2, function iterator(key, item) {
          obj1[key] = item;
        });
        return obj1;
      },
      merge: function merge(obj1, obj2) {
        return util.update(util.copy(obj1), obj2);
      },
      copy: function copy(object) {
        if (object === null || object === void 0) return object;
        var dupe = {};
        for (var key in object) {
          dupe[key] = object[key];
        }
        return dupe;
      },
      isEmpty: function isEmpty(obj) {
        for (var prop in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, prop)) {
            return false;
          }
        }
        return true;
      },
      arraySliceFn: function arraySliceFn(obj) {
        var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
        return typeof fn === 'function' ? fn : null;
      },
      isType: function isType(obj, type) {
        if (typeof type === 'function') type = util.typeName(type);
        return Object.prototype.toString.call(obj) === '[object ' + type + ']';
      },
      typeName: function typeName(type) {
        if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
        var str = type.toString();
        var match = str.match(/^\s*function (.+)\(/);
        return match ? match[1] : str;
      },
      error: function error(err, options) {
        var originalError = null;
        if (typeof err.message === 'string' && err.message !== '') {
          if (typeof options === 'string' || (options && options.message)) {
            originalError = util.copy(err);
            originalError.message = err.message;
          }
        }
        err.message = err.message || null;
        if (typeof options === 'string') {
          err.message = options;
        } else if (typeof options === 'object' && options !== null) {
          util.update(err, options);
          if (options.message) err.message = options.message;
          if (options.code || options.name) err.code = options.code || options.name;
          if (options.stack) err.stack = options.stack;
        }
        if (typeof Object.defineProperty === 'function') {
          Object.defineProperty(err, 'name', { writable: true, enumerable: false });
          Object.defineProperty(err, 'message', { enumerable: true });
        }
        err.name = String((options && options.name) || err.name || err.code || 'Error');
        err.time = new Date();
        if (originalError) {
          err.originalError = originalError;
        }
        for (var key in options || {}) {
          if (key[0] === '[' && key[key.length - 1] === ']') {
            key = key.slice(1, -1);
            if (key === 'code' || key === 'message') {
              continue;
            }
            err['[' + key + ']'] = 'See error.' + key + ' for details.';
            Object.defineProperty(err, key, {
              value: err[key] || (options && options[key]) || (originalError && originalError[key]),
              enumerable: false,
              writable: true,
            });
          }
        }
        return err;
      },
      inherit: function inherit(klass, features) {
        var newObject = null;
        if (features === void 0) {
          features = klass;
          klass = Object;
          newObject = {};
        } else {
          var ctor = function ConstructorWrapper() {};
          ctor.prototype = klass.prototype;
          newObject = new ctor();
        }
        if (features.constructor === Object) {
          features.constructor = function () {
            if (klass !== Object) {
              return klass.apply(this, arguments);
            }
          };
        }
        features.constructor.prototype = newObject;
        util.update(features.constructor.prototype, features);
        features.constructor.__super__ = klass;
        return features.constructor;
      },
      mixin: function mixin() {
        var klass = arguments[0];
        for (var i = 1; i < arguments.length; i++) {
          for (var prop in arguments[i].prototype) {
            var fn = arguments[i].prototype[prop];
            if (prop !== 'constructor') {
              klass.prototype[prop] = fn;
            }
          }
        }
        return klass;
      },
      hideProperties: function hideProperties(obj, props) {
        if (typeof Object.defineProperty !== 'function') return;
        util.arrayEach(props, function (key) {
          Object.defineProperty(obj, key, {
            enumerable: false,
            writable: true,
            configurable: true,
          });
        });
      },
      property: function property(obj, name, value, enumerable, isValue) {
        var opts = {
          configurable: true,
          enumerable: enumerable !== void 0 ? enumerable : true,
        };
        if (typeof value === 'function' && !isValue) {
          opts.get = value;
        } else {
          opts.value = value;
          opts.writable = true;
        }
        Object.defineProperty(obj, name, opts);
      },
      memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
        var cachedValue = null;
        util.property(
          obj,
          name,
          function () {
            if (cachedValue === null) {
              cachedValue = get();
            }
            return cachedValue;
          },
          enumerable
        );
      },
      hoistPayloadMember: function hoistPayloadMember(resp) {
        var req = resp.request;
        var operationName = req.operation;
        var operation = req.service.api.operations[operationName];
        var output = operation.output;
        if (output.payload && !operation.hasEventOutput) {
          var payloadMember = output.members[output.payload];
          var responsePayload = resp.data[output.payload];
          if (payloadMember.type === 'structure') {
            util.each(responsePayload, function (key, value) {
              util.property(resp.data, key, value, false);
            });
          }
        }
      },
      computeSha256: function computeSha256(body, done) {
        if (util.isNode()) {
          var Stream = util.stream.Stream;
          var fs = require('fs');
          if (typeof Stream === 'function' && body instanceof Stream) {
            if (typeof body.path === 'string') {
              var settings = {};
              if (typeof body.start === 'number') {
                settings.start = body.start;
              }
              if (typeof body.end === 'number') {
                settings.end = body.end;
              }
              body = fs.createReadStream(body.path, settings);
            } else {
              return done(new Error('Non-file stream objects are not supported with SigV4'));
            }
          }
        }
        util.crypto.sha256(body, 'hex', function (err, sha) {
          if (err) done(err);
          else done(null, sha);
        });
      },
      isClockSkewed: function isClockSkewed(serverTime) {
        if (serverTime) {
          util.property(AWS3.config, 'isClockSkewed', Math.abs(new Date().getTime() - serverTime) >= 3e5, false);
          return AWS3.config.isClockSkewed;
        }
      },
      applyClockOffset: function applyClockOffset(serverTime) {
        if (serverTime) AWS3.config.systemClockOffset = serverTime - new Date().getTime();
      },
      extractRequestId: function extractRequestId(resp) {
        var requestId = resp.httpResponse.headers['x-amz-request-id'] || resp.httpResponse.headers['x-amzn-requestid'];
        if (!requestId && resp.data && resp.data.ResponseMetadata) {
          requestId = resp.data.ResponseMetadata.RequestId;
        }
        if (requestId) {
          resp.requestId = requestId;
        }
        if (resp.error) {
          resp.error.requestId = requestId;
        }
      },
      addPromises: function addPromises(constructors, PromiseDependency) {
        var deletePromises = false;
        if (PromiseDependency === void 0 && AWS3 && AWS3.config) {
          PromiseDependency = AWS3.config.getPromisesDependency();
        }
        if (PromiseDependency === void 0 && typeof Promise !== 'undefined') {
          PromiseDependency = Promise;
        }
        if (typeof PromiseDependency !== 'function') deletePromises = true;
        if (!Array.isArray(constructors)) constructors = [constructors];
        for (var ind = 0; ind < constructors.length; ind++) {
          var constructor = constructors[ind];
          if (deletePromises) {
            if (constructor.deletePromisesFromClass) {
              constructor.deletePromisesFromClass();
            }
          } else if (constructor.addPromisesToClass) {
            constructor.addPromisesToClass(PromiseDependency);
          }
        }
      },
      promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
        return function promise() {
          var self = this;
          var args = Array.prototype.slice.call(arguments);
          return new PromiseDependency(function (resolve, reject) {
            args.push(function (err, data) {
              if (err) {
                reject(err);
              } else {
                resolve(data);
              }
            });
            self[methodName].apply(self, args);
          });
        };
      },
      isDualstackAvailable: function isDualstackAvailable(service) {
        if (!service) return false;
        var metadata = require_metadata();
        if (typeof service !== 'string') service = service.serviceIdentifier;
        if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
        return !!metadata[service].dualstackAvailable;
      },
      calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
        if (!retryDelayOptions) retryDelayOptions = {};
        var customBackoff = retryDelayOptions.customBackoff || null;
        if (typeof customBackoff === 'function') {
          return customBackoff(retryCount, err);
        }
        var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;
        var delay = Math.random() * (Math.pow(2, retryCount) * base);
        return delay;
      },
      handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
        if (!options) options = {};
        var http = AWS3.HttpClient.getInstance();
        var httpOptions = options.httpOptions || {};
        var retryCount = 0;
        var errCallback = function (err) {
          var maxRetries = options.maxRetries || 0;
          if (err && err.code === 'TimeoutError') err.retryable = true;
          if (err && err.retryable && retryCount < maxRetries) {
            var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
            if (delay >= 0) {
              retryCount++;
              setTimeout(sendRequest, delay + (err.retryAfter || 0));
              return;
            }
          }
          cb(err);
        };
        var sendRequest = function () {
          var data = '';
          http.handleRequest(
            httpRequest,
            httpOptions,
            function (httpResponse) {
              httpResponse.on('data', function (chunk) {
                data += chunk.toString();
              });
              httpResponse.on('end', function () {
                var statusCode = httpResponse.statusCode;
                if (statusCode < 300) {
                  cb(null, data);
                } else {
                  var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1e3 || 0;
                  var err = util.error(new Error(), {
                    statusCode,
                    retryable: statusCode >= 500 || statusCode === 429,
                  });
                  if (retryAfter && err.retryable) err.retryAfter = retryAfter;
                  errCallback(err);
                }
              });
            },
            errCallback
          );
        };
        AWS3.util.defer(sendRequest);
      },
      uuid: {
        v4: function uuidV4() {
          return require_dist().v4();
        },
      },
      convertPayloadToString: function convertPayloadToString(resp) {
        var req = resp.request;
        var operation = req.operation;
        var rules = req.service.api.operations[operation].output || {};
        if (rules.payload && resp.data[rules.payload]) {
          resp.data[rules.payload] = resp.data[rules.payload].toString();
        }
      },
      defer: function defer(callback) {
        if (typeof process === 'object' && typeof process.nextTick === 'function') {
          process.nextTick(callback);
        } else if (typeof setImmediate === 'function') {
          setImmediate(callback);
        } else {
          setTimeout(callback, 0);
        }
      },
      getRequestPayloadShape: function getRequestPayloadShape(req) {
        var operations = req.service.api.operations;
        if (!operations) return void 0;
        var operation = (operations || {})[req.operation];
        if (!operation || !operation.input || !operation.input.payload) return void 0;
        return operation.input.members[operation.input.payload];
      },
      getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
        var profiles = {};
        var profilesFromConfig = {};
        if (process.env[util.configOptInEnv]) {
          var profilesFromConfig = iniLoader.loadFrom({
            isConfig: true,
            filename: process.env[util.sharedConfigFileEnv],
          });
        }
        var profilesFromCreds = {};
        try {
          var profilesFromCreds = iniLoader.loadFrom({
            filename: filename || (process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv]),
          });
        } catch (error) {
          if (!process.env[util.configOptInEnv]) throw error;
        }
        for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
          profiles[profileNames[i]] = objectAssign(
            profiles[profileNames[i]] || {},
            profilesFromConfig[profileNames[i]]
          );
        }
        for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
          profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromCreds[profileNames[i]]);
        }
        return profiles;
        function objectAssign(target, source) {
          for (var i2 = 0, keys = Object.keys(source); i2 < keys.length; i2++) {
            target[keys[i2]] = source[keys[i2]];
          }
          return target;
        }
      },
      ARN: {
        validate: function validateARN(str) {
          return str && str.indexOf('arn:') === 0 && str.split(':').length >= 6;
        },
        parse: function parseARN(arn) {
          var matched = arn.split(':');
          return {
            partition: matched[1],
            service: matched[2],
            region: matched[3],
            accountId: matched[4],
            resource: matched.slice(5).join(':'),
          };
        },
        build: function buildARN(arnObject) {
          if (
            arnObject.service === void 0 ||
            arnObject.region === void 0 ||
            arnObject.accountId === void 0 ||
            arnObject.resource === void 0
          )
            throw util.error(new Error('Input ARN object is invalid'));
          return (
            'arn:' +
            (arnObject.partition || 'aws') +
            ':' +
            arnObject.service +
            ':' +
            arnObject.region +
            ':' +
            arnObject.accountId +
            ':' +
            arnObject.resource
          );
        },
      },
      defaultProfile: 'default',
      configOptInEnv: 'AWS_SDK_LOAD_CONFIG',
      sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',
      sharedConfigFileEnv: 'AWS_CONFIG_FILE',
      imdsDisabledEnv: 'AWS_EC2_METADATA_DISABLED',
    };
    module2.exports = util;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js
var require_event_message_chunker_stream = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js'(
    exports,
    module2
  ) {
    var util = require_core().util;
    var Transform = require('stream').Transform;
    var allocBuffer = util.buffer.alloc;
    function EventMessageChunkerStream(options) {
      Transform.call(this, options);
      this.currentMessageTotalLength = 0;
      this.currentMessagePendingLength = 0;
      this.currentMessage = null;
      this.messageLengthBuffer = null;
    }
    EventMessageChunkerStream.prototype = Object.create(Transform.prototype);
    EventMessageChunkerStream.prototype._transform = function (chunk, encoding, callback) {
      var chunkLength = chunk.length;
      var currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!this.currentMessage) {
          var bytesRemaining = chunkLength - currentOffset;
          if (!this.messageLengthBuffer) {
            this.messageLengthBuffer = allocBuffer(4);
          }
          var numBytesForTotal = Math.min(4 - this.currentMessagePendingLength, bytesRemaining);
          chunk.copy(
            this.messageLengthBuffer,
            this.currentMessagePendingLength,
            currentOffset,
            currentOffset + numBytesForTotal
          );
          this.currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (this.currentMessagePendingLength < 4) {
            break;
          }
          this.allocateMessage(this.messageLengthBuffer.readUInt32BE(0));
          this.messageLengthBuffer = null;
        }
        var numBytesToWrite = Math.min(
          this.currentMessageTotalLength - this.currentMessagePendingLength,
          chunkLength - currentOffset
        );
        chunk.copy(
          this.currentMessage,
          this.currentMessagePendingLength,
          currentOffset,
          currentOffset + numBytesToWrite
        );
        this.currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (this.currentMessageTotalLength && this.currentMessageTotalLength === this.currentMessagePendingLength) {
          this.push(this.currentMessage);
          this.currentMessage = null;
          this.currentMessageTotalLength = 0;
          this.currentMessagePendingLength = 0;
        }
      }
      callback();
    };
    EventMessageChunkerStream.prototype._flush = function (callback) {
      if (this.currentMessageTotalLength) {
        if (this.currentMessageTotalLength === this.currentMessagePendingLength) {
          callback(null, this.currentMessage);
        } else {
          callback(new Error('Truncated event message received.'));
        }
      } else {
        callback();
      }
    };
    EventMessageChunkerStream.prototype.allocateMessage = function (size) {
      if (typeof size !== 'number') {
        throw new Error('Attempted to allocate an event message where size was not a number: ' + size);
      }
      this.currentMessageTotalLength = size;
      this.currentMessagePendingLength = 4;
      this.currentMessage = allocBuffer(size);
      this.currentMessage.writeUInt32BE(size, 0);
    };
    module2.exports = {
      EventMessageChunkerStream,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/int64.js
var require_int64 = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/int64.js'(exports, module2) {
    var util = require_core().util;
    var toBuffer = util.buffer.toBuffer;
    function Int64(bytes) {
      if (bytes.length !== 8) {
        throw new Error('Int64 buffers must be exactly 8 bytes');
      }
      if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);
      this.bytes = bytes;
    }
    Int64.fromNumber = function (number) {
      if (number > 9223372036854776e3 || number < -9223372036854776e3) {
        throw new Error(number + ' is too large (or, if negative, too small) to represent as an Int64');
      }
      var bytes = new Uint8Array(8);
      for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
        bytes[i] = remaining;
      }
      if (number < 0) {
        negate(bytes);
      }
      return new Int64(bytes);
    };
    Int64.prototype.valueOf = function () {
      var bytes = this.bytes.slice(0);
      var negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);
    };
    Int64.prototype.toString = function () {
      return String(this.valueOf());
    };
    function negate(bytes) {
      for (var i = 0; i < 8; i++) {
        bytes[i] ^= 255;
      }
      for (var i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0) {
          break;
        }
      }
    }
    module2.exports = {
      Int64,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/split-message.js
var require_split_message = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/split-message.js'(exports, module2) {
    var util = require_core().util;
    var toBuffer = util.buffer.toBuffer;
    var PRELUDE_MEMBER_LENGTH = 4;
    var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
    var CHECKSUM_LENGTH = 4;
    var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
    function splitMessage(message) {
      if (!util.Buffer.isBuffer(message)) message = toBuffer(message);
      if (message.length < MINIMUM_MESSAGE_LENGTH) {
        throw new Error('Provided message too short to accommodate event stream message overhead');
      }
      if (message.length !== message.readUInt32BE(0)) {
        throw new Error('Reported message length does not match received message length');
      }
      var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);
      if (expectedPreludeChecksum !== util.crypto.crc32(message.slice(0, PRELUDE_LENGTH))) {
        throw new Error(
          'The prelude checksum specified in the message (' +
            expectedPreludeChecksum +
            ') does not match the calculated CRC32 checksum.'
        );
      }
      var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);
      if (expectedMessageChecksum !== util.crypto.crc32(message.slice(0, message.length - CHECKSUM_LENGTH))) {
        throw new Error('The message checksum did not match the expected value of ' + expectedMessageChecksum);
      }
      var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
      var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);
      return {
        headers: message.slice(headersStart, headersEnd),
        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH),
      };
    }
    module2.exports = {
      splitMessage,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/parse-message.js
var require_parse_message = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/parse-message.js'(exports, module2) {
    var Int64 = require_int64().Int64;
    var splitMessage = require_split_message().splitMessage;
    var BOOLEAN_TAG = 'boolean';
    var BYTE_TAG = 'byte';
    var SHORT_TAG = 'short';
    var INT_TAG = 'integer';
    var LONG_TAG = 'long';
    var BINARY_TAG = 'binary';
    var STRING_TAG = 'string';
    var TIMESTAMP_TAG = 'timestamp';
    var UUID_TAG = 'uuid';
    function parseHeaders(headers) {
      var out = {};
      var position = 0;
      while (position < headers.length) {
        var nameLength = headers.readUInt8(position++);
        var name = headers.slice(position, position + nameLength).toString();
        position += nameLength;
        switch (headers.readUInt8(position++)) {
          case 0:
            out[name] = {
              type: BOOLEAN_TAG,
              value: true,
            };
            break;
          case 1:
            out[name] = {
              type: BOOLEAN_TAG,
              value: false,
            };
            break;
          case 2:
            out[name] = {
              type: BYTE_TAG,
              value: headers.readInt8(position++),
            };
            break;
          case 3:
            out[name] = {
              type: SHORT_TAG,
              value: headers.readInt16BE(position),
            };
            position += 2;
            break;
          case 4:
            out[name] = {
              type: INT_TAG,
              value: headers.readInt32BE(position),
            };
            position += 4;
            break;
          case 5:
            out[name] = {
              type: LONG_TAG,
              value: new Int64(headers.slice(position, position + 8)),
            };
            position += 8;
            break;
          case 6:
            var binaryLength = headers.readUInt16BE(position);
            position += 2;
            out[name] = {
              type: BINARY_TAG,
              value: headers.slice(position, position + binaryLength),
            };
            position += binaryLength;
            break;
          case 7:
            var stringLength = headers.readUInt16BE(position);
            position += 2;
            out[name] = {
              type: STRING_TAG,
              value: headers.slice(position, position + stringLength).toString(),
            };
            position += stringLength;
            break;
          case 8:
            out[name] = {
              type: TIMESTAMP_TAG,
              value: new Date(new Int64(headers.slice(position, position + 8)).valueOf()),
            };
            position += 8;
            break;
          case 9:
            var uuidChars = headers.slice(position, position + 16).toString('hex');
            position += 16;
            out[name] = {
              type: UUID_TAG,
              value:
                uuidChars.substr(0, 8) +
                '-' +
                uuidChars.substr(8, 4) +
                '-' +
                uuidChars.substr(12, 4) +
                '-' +
                uuidChars.substr(16, 4) +
                '-' +
                uuidChars.substr(20),
            };
            break;
          default:
            throw new Error('Unrecognized header type tag');
        }
      }
      return out;
    }
    function parseMessage(message) {
      var parsed = splitMessage(message);
      return { headers: parseHeaders(parsed.headers), body: parsed.body };
    }
    module2.exports = {
      parseMessage,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/parse-event.js
var require_parse_event = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/parse-event.js'(exports, module2) {
    var parseMessage = require_parse_message().parseMessage;
    function parseEvent(parser, message, shape) {
      var parsedMessage = parseMessage(message);
      var messageType = parsedMessage.headers[':message-type'];
      if (messageType) {
        if (messageType.value === 'error') {
          throw parseError(parsedMessage);
        } else if (messageType.value !== 'event') {
          return;
        }
      }
      var eventType = parsedMessage.headers[':event-type'];
      var eventModel = shape.members[eventType.value];
      if (!eventModel) {
        return;
      }
      var result = {};
      var eventPayloadMemberName = eventModel.eventPayloadMemberName;
      if (eventPayloadMemberName) {
        var payloadShape = eventModel.members[eventPayloadMemberName];
        if (payloadShape.type === 'binary') {
          result[eventPayloadMemberName] = parsedMessage.body;
        } else {
          result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
        }
      }
      var eventHeaderNames = eventModel.eventHeaderMemberNames;
      for (var i = 0; i < eventHeaderNames.length; i++) {
        var name = eventHeaderNames[i];
        if (parsedMessage.headers[name]) {
          result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
        }
      }
      var output = {};
      output[eventType.value] = result;
      return output;
    }
    function parseError(message) {
      var errorCode = message.headers[':error-code'];
      var errorMessage = message.headers[':error-message'];
      var error = new Error(errorMessage.value || errorMessage);
      error.code = error.name = errorCode.value || errorCode;
      return error;
    }
    module2.exports = {
      parseEvent,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js
var require_event_message_unmarshaller_stream = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js'(
    exports,
    module2
  ) {
    var Transform = require('stream').Transform;
    var parseEvent = require_parse_event().parseEvent;
    function EventUnmarshallerStream(options) {
      options = options || {};
      options.readableObjectMode = true;
      Transform.call(this, options);
      this._readableState.objectMode = true;
      this.parser = options.parser;
      this.eventStreamModel = options.eventStreamModel;
    }
    EventUnmarshallerStream.prototype = Object.create(Transform.prototype);
    EventUnmarshallerStream.prototype._transform = function (chunk, encoding, callback) {
      try {
        var event = parseEvent(this.parser, chunk, this.eventStreamModel);
        this.push(event);
        return callback();
      } catch (err) {
        callback(err);
      }
    };
    module2.exports = {
      EventUnmarshallerStream,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js
var require_streaming_create_event_stream = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js'(
    exports,
    module2
  ) {
    var EventMessageChunkerStream = require_event_message_chunker_stream().EventMessageChunkerStream;
    var EventUnmarshallerStream = require_event_message_unmarshaller_stream().EventUnmarshallerStream;
    function createEventStream(stream, parser, model) {
      var eventStream = new EventUnmarshallerStream({
        parser,
        eventStreamModel: model,
      });
      var eventMessageChunker = new EventMessageChunkerStream();
      stream.pipe(eventMessageChunker).pipe(eventStream);
      stream.on('error', function (err) {
        eventMessageChunker.emit('error', err);
      });
      eventMessageChunker.on('error', function (err) {
        eventStream.emit('error', err);
      });
      return eventStream;
    }
    module2.exports = {
      createEventStream,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/event-message-chunker.js
var require_event_message_chunker = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/event-message-chunker.js'(
    exports,
    module2
  ) {
    function eventMessageChunker(buffer) {
      var messages = [];
      var offset = 0;
      while (offset < buffer.length) {
        var totalLength = buffer.readInt32BE(offset);
        var message = buffer.slice(offset, totalLength + offset);
        offset += totalLength;
        messages.push(message);
      }
      return messages;
    }
    module2.exports = {
      eventMessageChunker,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js
var require_buffered_create_event_stream = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js'(
    exports,
    module2
  ) {
    var eventMessageChunker = require_event_message_chunker().eventMessageChunker;
    var parseEvent = require_parse_event().parseEvent;
    function createEventStream(body, parser, model) {
      var eventMessages = eventMessageChunker(body);
      var events = [];
      for (var i = 0; i < eventMessages.length; i++) {
        events.push(parseEvent(parser, eventMessages[i], model));
      }
      return events;
    }
    module2.exports = {
      createEventStream,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/realclock/nodeClock.js
var require_nodeClock = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/realclock/nodeClock.js'(exports, module2) {
    module2.exports = {
      now: function now() {
        var second = process.hrtime();
        return second[0] * 1e3 + second[1] / 1e6;
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/publisher/index.js
var require_publisher = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/publisher/index.js'(exports, module2) {
    var util = require_core().util;
    var dgram = require('dgram');
    var stringToBuffer = util.buffer.toBuffer;
    var MAX_MESSAGE_SIZE = 1024 * 8;
    function Publisher(options) {
      options = options || {};
      this.enabled = options.enabled || false;
      this.port = options.port || 31e3;
      this.clientId = options.clientId || '';
      this.address = options.host || '127.0.0.1';
      if (this.clientId.length > 255) {
        this.clientId = this.clientId.substr(0, 255);
      }
      this.messagesInFlight = 0;
    }
    Publisher.prototype.fieldsToTrim = {
      UserAgent: 256,
      SdkException: 128,
      SdkExceptionMessage: 512,
      AwsException: 128,
      AwsExceptionMessage: 512,
      FinalSdkException: 128,
      FinalSdkExceptionMessage: 512,
      FinalAwsException: 128,
      FinalAwsExceptionMessage: 512,
    };
    Publisher.prototype.trimFields = function (event) {
      var trimmableFields = Object.keys(this.fieldsToTrim);
      for (var i = 0, iLen = trimmableFields.length; i < iLen; i++) {
        var field = trimmableFields[i];
        if (event.hasOwnProperty(field)) {
          var maxLength = this.fieldsToTrim[field];
          var value = event[field];
          if (value && value.length > maxLength) {
            event[field] = value.substr(0, maxLength);
          }
        }
      }
      return event;
    };
    Publisher.prototype.eventHandler = function (event) {
      event.ClientId = this.clientId;
      this.trimFields(event);
      var message = stringToBuffer(JSON.stringify(event));
      if (!this.enabled || message.length > MAX_MESSAGE_SIZE) {
        return;
      }
      this.publishDatagram(message);
    };
    Publisher.prototype.publishDatagram = function (message) {
      var self = this;
      var client = this.getClient();
      this.messagesInFlight++;
      this.client.send(message, 0, message.length, this.port, this.address, function (err, bytes) {
        if (--self.messagesInFlight <= 0) {
          self.destroyClient();
        }
      });
    };
    Publisher.prototype.getClient = function () {
      if (!this.client) {
        this.client = dgram.createSocket('udp4');
      }
      return this.client;
    };
    Publisher.prototype.destroyClient = function () {
      if (this.client) {
        this.client.close();
        this.client = void 0;
      }
    };
    module2.exports = {
      Publisher,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/publisher/configuration.js
var require_configuration = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/publisher/configuration.js'(exports, module2) {
    var AWS3 = require_core();
    function resolveMonitoringConfig() {
      var config = {
        port: void 0,
        clientId: void 0,
        enabled: void 0,
        host: void 0,
      };
      if (fromEnvironment(config) || fromConfigFile(config)) return toJSType(config);
      return toJSType(config);
    }
    function fromEnvironment(config) {
      config.port = config.port || process.env.AWS_CSM_PORT;
      config.enabled = config.enabled || process.env.AWS_CSM_ENABLED;
      config.clientId = config.clientId || process.env.AWS_CSM_CLIENT_ID;
      config.host = config.host || process.env.AWS_CSM_HOST;
      return (
        (config.port && config.enabled && config.clientId && config.host) || ['false', '0'].indexOf(config.enabled) >= 0
      );
    }
    function fromConfigFile(config) {
      var sharedFileConfig;
      try {
        var configFile = AWS3.util.iniLoader.loadFrom({
          isConfig: true,
          filename: process.env[AWS3.util.sharedConfigFileEnv],
        });
        var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS3.util.defaultProfile];
      } catch (err) {
        return false;
      }
      if (!sharedFileConfig) return config;
      config.port = config.port || sharedFileConfig.csm_port;
      config.enabled = config.enabled || sharedFileConfig.csm_enabled;
      config.clientId = config.clientId || sharedFileConfig.csm_client_id;
      config.host = config.host || sharedFileConfig.csm_host;
      return config.port && config.enabled && config.clientId && config.host;
    }
    function toJSType(config) {
      var falsyNotations = ['false', '0', void 0];
      if (!config.enabled || falsyNotations.indexOf(config.enabled.toLowerCase()) >= 0) {
        config.enabled = false;
      } else {
        config.enabled = true;
      }
      config.port = config.port ? parseInt(config.port, 10) : void 0;
      return config;
    }
    module2.exports = resolveMonitoringConfig;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/shared-ini/ini-loader.js
var require_ini_loader = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/shared-ini/ini-loader.js'(exports, module2) {
    var AWS3 = require_core();
    var os = require('os');
    var path = require('path');
    function parseFile(filename) {
      return AWS3.util.ini.parse(AWS3.util.readFileSync(filename));
    }
    function getProfiles(fileContent) {
      var tmpContent = {};
      Object.keys(fileContent).forEach(function (sectionName) {
        if (/^sso-session\s/.test(sectionName)) return;
        Object.defineProperty(tmpContent, sectionName.replace(/^profile\s/, ''), {
          value: fileContent[sectionName],
          enumerable: true,
        });
      });
      return tmpContent;
    }
    function getSsoSessions(fileContent) {
      var tmpContent = {};
      Object.keys(fileContent).forEach(function (sectionName) {
        if (!/^sso-session\s/.test(sectionName)) return;
        Object.defineProperty(tmpContent, sectionName.replace(/^sso-session\s/, ''), {
          value: fileContent[sectionName],
          enumerable: true,
        });
      });
      return tmpContent;
    }
    AWS3.IniLoader = AWS3.util.inherit({
      constructor: function IniLoader2() {
        this.resolvedProfiles = {};
        this.resolvedSsoSessions = {};
      },
      clearCachedFiles: function clearCachedFiles() {
        this.resolvedProfiles = {};
        this.resolvedSsoSessions = {};
      },
      loadFrom: function loadFrom(options) {
        options = options || {};
        var isConfig = options.isConfig === true;
        var filename = options.filename || this.getDefaultFilePath(isConfig);
        if (!this.resolvedProfiles[filename]) {
          var fileContent = parseFile(filename);
          if (isConfig) {
            Object.defineProperty(this.resolvedProfiles, filename, {
              value: getProfiles(fileContent),
            });
          } else {
            Object.defineProperty(this.resolvedProfiles, filename, { value: fileContent });
          }
        }
        return this.resolvedProfiles[filename];
      },
      loadSsoSessionsFrom: function loadSsoSessionsFrom(options) {
        options = options || {};
        var filename = options.filename || this.getDefaultFilePath(true);
        if (!this.resolvedSsoSessions[filename]) {
          var fileContent = parseFile(filename);
          Object.defineProperty(this.resolvedSsoSessions, filename, {
            value: getSsoSessions(fileContent),
          });
        }
        return this.resolvedSsoSessions[filename];
      },
      getDefaultFilePath: function getDefaultFilePath(isConfig) {
        return path.join(this.getHomeDir(), '.aws', isConfig ? 'config' : 'credentials');
      },
      getHomeDir: function getHomeDir() {
        var env = process.env;
        var home = env.HOME || env.USERPROFILE || (env.HOMEPATH ? (env.HOMEDRIVE || 'C:/') + env.HOMEPATH : null);
        if (home) {
          return home;
        }
        if (typeof os.homedir === 'function') {
          return os.homedir();
        }
        throw AWS3.util.error(new Error('Cannot load credentials, HOME path not set'));
      },
    });
    var IniLoader = AWS3.IniLoader;
    module2.exports = {
      IniLoader,
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/shared-ini/index.js
var require_shared_ini = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/shared-ini/index.js'(exports, module2) {
    var IniLoader = require_ini_loader().IniLoader;
    module2.exports.iniLoader = new IniLoader();
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/config_regional_endpoint.js
var require_config_regional_endpoint = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/config_regional_endpoint.js'(exports, module2) {
    var AWS3 = require_core();
    function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
      if (typeof configValue !== 'string') return void 0;
      else if (['legacy', 'regional'].indexOf(configValue.toLowerCase()) >= 0) {
        return configValue.toLowerCase();
      } else {
        throw AWS3.util.error(new Error(), errorOptions);
      }
    }
    function resolveRegionalEndpointsFlag(originalConfig, options) {
      originalConfig = originalConfig || {};
      var resolved;
      if (originalConfig[options.clientConfig]) {
        resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
          code: 'InvalidConfiguration',
          message:
            'invalid "' +
            options.clientConfig +
            '" configuration. Expect "legacy"  or "regional". Got "' +
            originalConfig[options.clientConfig] +
            '".',
        });
        if (resolved) return resolved;
      }
      if (!AWS3.util.isNode()) return resolved;
      if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
        var envFlag = process.env[options.env];
        resolved = validateRegionalEndpointsFlagValue(envFlag, {
          code: 'InvalidEnvironmentalVariable',
          message:
            'invalid ' +
            options.env +
            ' environmental variable. Expect "legacy"  or "regional". Got "' +
            process.env[options.env] +
            '".',
        });
        if (resolved) return resolved;
      }
      var profile = {};
      try {
        var profiles = AWS3.util.getProfilesFromSharedConfig(AWS3.util.iniLoader);
        profile = profiles[process.env.AWS_PROFILE || AWS3.util.defaultProfile];
      } catch (e) {}
      if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
        var fileFlag = profile[options.sharedConfig];
        resolved = validateRegionalEndpointsFlagValue(fileFlag, {
          code: 'InvalidConfiguration',
          message:
            'invalid ' +
            options.sharedConfig +
            ' profile config. Expect "legacy"  or "regional". Got "' +
            profile[options.sharedConfig] +
            '".',
        });
        if (resolved) return resolved;
      }
      return resolved;
    }
    module2.exports = resolveRegionalEndpointsFlag;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/services/sts.js
var require_sts = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/services/sts.js'() {
    var AWS3 = require_core();
    var resolveRegionalEndpointsFlag = require_config_regional_endpoint();
    var ENV_REGIONAL_ENDPOINT_ENABLED = 'AWS_STS_REGIONAL_ENDPOINTS';
    var CONFIG_REGIONAL_ENDPOINT_ENABLED = 'sts_regional_endpoints';
    AWS3.util.update(AWS3.STS.prototype, {
      credentialsFrom: function credentialsFrom(data, credentials) {
        if (!data) return null;
        if (!credentials) credentials = new AWS3.TemporaryCredentials();
        credentials.expired = false;
        credentials.accessKeyId = data.Credentials.AccessKeyId;
        credentials.secretAccessKey = data.Credentials.SecretAccessKey;
        credentials.sessionToken = data.Credentials.SessionToken;
        credentials.expireTime = data.Credentials.Expiration;
        return credentials;
      },
      assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
        return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
      },
      assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
        return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
      },
      setupRequestListeners: function setupRequestListeners(request) {
        request.addListener('validate', this.optInRegionalEndpoint, true);
      },
      optInRegionalEndpoint: function optInRegionalEndpoint(req) {
        var service = req.service;
        var config = service.config;
        config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
          env: ENV_REGIONAL_ENDPOINT_ENABLED,
          sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
          clientConfig: 'stsRegionalEndpoints',
        });
        if (config.stsRegionalEndpoints === 'regional' && service.isGlobalEndpoint) {
          if (!config.region) {
            throw AWS3.util.error(new Error(), { code: 'ConfigError', message: 'Missing region in config' });
          }
          var insertPoint = config.endpoint.indexOf('.amazonaws.com');
          var regionalEndpoint =
            config.endpoint.substring(0, insertPoint) + '.' + config.region + config.endpoint.substring(insertPoint);
          req.httpRequest.updateEndpoint(regionalEndpoint);
          req.httpRequest.region = config.region;
        }
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/sts-2011-06-15.min.json
var require_sts_2011_06_15_min = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/sts-2011-06-15.min.json'(exports, module2) {
    module2.exports = {
      version: '2.0',
      metadata: {
        apiVersion: '2011-06-15',
        endpointPrefix: 'sts',
        globalEndpoint: 'sts.amazonaws.com',
        protocol: 'query',
        serviceAbbreviation: 'AWS STS',
        serviceFullName: 'AWS Security Token Service',
        serviceId: 'STS',
        signatureVersion: 'v4',
        uid: 'sts-2011-06-15',
        xmlNamespace: 'https://sts.amazonaws.com/doc/2011-06-15/',
      },
      operations: {
        AssumeRole: {
          input: {
            type: 'structure',
            required: ['RoleArn', 'RoleSessionName'],
            members: {
              RoleArn: {},
              RoleSessionName: {},
              PolicyArns: {
                shape: 'S4',
              },
              Policy: {},
              DurationSeconds: {
                type: 'integer',
              },
              Tags: {
                shape: 'S8',
              },
              TransitiveTagKeys: {
                type: 'list',
                member: {},
              },
              ExternalId: {},
              SerialNumber: {},
              TokenCode: {},
              SourceIdentity: {},
              ProvidedContexts: {
                type: 'list',
                member: {
                  type: 'structure',
                  members: {
                    ProviderArn: {},
                    ContextAssertion: {},
                  },
                },
              },
            },
          },
          output: {
            resultWrapper: 'AssumeRoleResult',
            type: 'structure',
            members: {
              Credentials: {
                shape: 'Sl',
              },
              AssumedRoleUser: {
                shape: 'Sq',
              },
              PackedPolicySize: {
                type: 'integer',
              },
              SourceIdentity: {},
            },
          },
        },
        AssumeRoleWithSAML: {
          input: {
            type: 'structure',
            required: ['RoleArn', 'PrincipalArn', 'SAMLAssertion'],
            members: {
              RoleArn: {},
              PrincipalArn: {},
              SAMLAssertion: {
                type: 'string',
                sensitive: true,
              },
              PolicyArns: {
                shape: 'S4',
              },
              Policy: {},
              DurationSeconds: {
                type: 'integer',
              },
            },
          },
          output: {
            resultWrapper: 'AssumeRoleWithSAMLResult',
            type: 'structure',
            members: {
              Credentials: {
                shape: 'Sl',
              },
              AssumedRoleUser: {
                shape: 'Sq',
              },
              PackedPolicySize: {
                type: 'integer',
              },
              Subject: {},
              SubjectType: {},
              Issuer: {},
              Audience: {},
              NameQualifier: {},
              SourceIdentity: {},
            },
          },
        },
        AssumeRoleWithWebIdentity: {
          input: {
            type: 'structure',
            required: ['RoleArn', 'RoleSessionName', 'WebIdentityToken'],
            members: {
              RoleArn: {},
              RoleSessionName: {},
              WebIdentityToken: {
                type: 'string',
                sensitive: true,
              },
              ProviderId: {},
              PolicyArns: {
                shape: 'S4',
              },
              Policy: {},
              DurationSeconds: {
                type: 'integer',
              },
            },
          },
          output: {
            resultWrapper: 'AssumeRoleWithWebIdentityResult',
            type: 'structure',
            members: {
              Credentials: {
                shape: 'Sl',
              },
              SubjectFromWebIdentityToken: {},
              AssumedRoleUser: {
                shape: 'Sq',
              },
              PackedPolicySize: {
                type: 'integer',
              },
              Provider: {},
              Audience: {},
              SourceIdentity: {},
            },
          },
        },
        DecodeAuthorizationMessage: {
          input: {
            type: 'structure',
            required: ['EncodedMessage'],
            members: {
              EncodedMessage: {},
            },
          },
          output: {
            resultWrapper: 'DecodeAuthorizationMessageResult',
            type: 'structure',
            members: {
              DecodedMessage: {},
            },
          },
        },
        GetAccessKeyInfo: {
          input: {
            type: 'structure',
            required: ['AccessKeyId'],
            members: {
              AccessKeyId: {},
            },
          },
          output: {
            resultWrapper: 'GetAccessKeyInfoResult',
            type: 'structure',
            members: {
              Account: {},
            },
          },
        },
        GetCallerIdentity: {
          input: {
            type: 'structure',
            members: {},
          },
          output: {
            resultWrapper: 'GetCallerIdentityResult',
            type: 'structure',
            members: {
              UserId: {},
              Account: {},
              Arn: {},
            },
          },
        },
        GetFederationToken: {
          input: {
            type: 'structure',
            required: ['Name'],
            members: {
              Name: {},
              Policy: {},
              PolicyArns: {
                shape: 'S4',
              },
              DurationSeconds: {
                type: 'integer',
              },
              Tags: {
                shape: 'S8',
              },
            },
          },
          output: {
            resultWrapper: 'GetFederationTokenResult',
            type: 'structure',
            members: {
              Credentials: {
                shape: 'Sl',
              },
              FederatedUser: {
                type: 'structure',
                required: ['FederatedUserId', 'Arn'],
                members: {
                  FederatedUserId: {},
                  Arn: {},
                },
              },
              PackedPolicySize: {
                type: 'integer',
              },
            },
          },
        },
        GetSessionToken: {
          input: {
            type: 'structure',
            members: {
              DurationSeconds: {
                type: 'integer',
              },
              SerialNumber: {},
              TokenCode: {},
            },
          },
          output: {
            resultWrapper: 'GetSessionTokenResult',
            type: 'structure',
            members: {
              Credentials: {
                shape: 'Sl',
              },
            },
          },
        },
      },
      shapes: {
        S4: {
          type: 'list',
          member: {
            type: 'structure',
            members: {
              arn: {},
            },
          },
        },
        S8: {
          type: 'list',
          member: {
            type: 'structure',
            required: ['Key', 'Value'],
            members: {
              Key: {},
              Value: {},
            },
          },
        },
        Sl: {
          type: 'structure',
          required: ['AccessKeyId', 'SecretAccessKey', 'SessionToken', 'Expiration'],
          members: {
            AccessKeyId: {},
            SecretAccessKey: {
              type: 'string',
              sensitive: true,
            },
            SessionToken: {},
            Expiration: {
              type: 'timestamp',
            },
          },
        },
        Sq: {
          type: 'structure',
          required: ['AssumedRoleId', 'Arn'],
          members: {
            AssumedRoleId: {},
            Arn: {},
          },
        },
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json
var require_sts_2011_06_15_paginators = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json'(exports, module2) {
    module2.exports = {
      pagination: {},
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/clients/sts.js
var require_sts2 = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/clients/sts.js'(exports, module2) {
    require_node_loader();
    var AWS3 = require_core();
    var Service = AWS3.Service;
    var apiLoader = AWS3.apiLoader;
    apiLoader.services['sts'] = {};
    AWS3.STS = Service.defineService('sts', ['2011-06-15']);
    require_sts();
    Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
      get: function get() {
        var model = require_sts_2011_06_15_min();
        model.paginators = require_sts_2011_06_15_paginators().pagination;
        return model;
      },
      enumerable: true,
      configurable: true,
    });
    module2.exports = AWS3.STS;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/temporary_credentials.js
var require_temporary_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/temporary_credentials.js'() {
    var AWS3 = require_core();
    var STS = require_sts2();
    AWS3.TemporaryCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function TemporaryCredentials(params, masterCredentials) {
        AWS3.Credentials.call(this);
        this.loadMasterCredentials(masterCredentials);
        this.expired = true;
        this.params = params || {};
        if (this.params.RoleArn) {
          this.params.RoleSessionName = this.params.RoleSessionName || 'temporary-credentials';
        }
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.masterCredentials.get(function () {
          self.service.config.credentials = self.masterCredentials;
          var operation = self.params.RoleArn ? self.service.assumeRole : self.service.getSessionToken;
          operation.call(self.service, function (err, data) {
            if (!err) {
              self.service.credentialsFrom(data, self);
            }
            callback(err);
          });
        });
      },
      loadMasterCredentials: function loadMasterCredentials(masterCredentials) {
        this.masterCredentials = masterCredentials || AWS3.config.credentials;
        while (this.masterCredentials.masterCredentials) {
          this.masterCredentials = this.masterCredentials.masterCredentials;
        }
        if (typeof this.masterCredentials.get !== 'function') {
          this.masterCredentials = new AWS3.Credentials(this.masterCredentials);
        }
      },
      createClients: function () {
        this.service = this.service || new STS({ params: this.params });
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js
var require_chainable_temporary_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js'() {
    var AWS3 = require_core();
    var STS = require_sts2();
    AWS3.ChainableTemporaryCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function ChainableTemporaryCredentials(options) {
        AWS3.Credentials.call(this);
        options = options || {};
        this.errorCode = 'ChainableTemporaryCredentialsProviderFailure';
        this.expired = true;
        this.tokenCodeFn = null;
        var params = AWS3.util.copy(options.params) || {};
        if (params.RoleArn) {
          params.RoleSessionName = params.RoleSessionName || 'temporary-credentials';
        }
        if (params.SerialNumber) {
          if (!options.tokenCodeFn || typeof options.tokenCodeFn !== 'function') {
            throw new AWS3.util.error(new Error('tokenCodeFn must be a function when params.SerialNumber is given'), {
              code: this.errorCode,
            });
          } else {
            this.tokenCodeFn = options.tokenCodeFn;
          }
        }
        var config = AWS3.util.merge(
          {
            params,
            credentials: options.masterCredentials || AWS3.config.credentials,
          },
          options.stsConfig || {}
        );
        this.service = new STS(config);
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
      load: function load(callback) {
        var self = this;
        var operation = self.service.config.params.RoleArn ? 'assumeRole' : 'getSessionToken';
        this.getTokenCode(function (err, tokenCode) {
          var params = {};
          if (err) {
            callback(err);
            return;
          }
          if (tokenCode) {
            params.TokenCode = tokenCode;
          }
          self.service[operation](params, function (err2, data) {
            if (!err2) {
              self.service.credentialsFrom(data, self);
            }
            callback(err2);
          });
        });
      },
      getTokenCode: function getTokenCode(callback) {
        var self = this;
        if (this.tokenCodeFn) {
          this.tokenCodeFn(this.service.config.params.SerialNumber, function (err, token) {
            if (err) {
              var message = err;
              if (err instanceof Error) {
                message = err.message;
              }
              callback(AWS3.util.error(new Error('Error fetching MFA token: ' + message), { code: self.errorCode }));
              return;
            }
            callback(null, token);
          });
        } else {
          callback(null);
        }
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/web_identity_credentials.js
var require_web_identity_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/web_identity_credentials.js'() {
    var AWS3 = require_core();
    var STS = require_sts2();
    AWS3.WebIdentityCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function WebIdentityCredentials(params, clientConfig) {
        AWS3.Credentials.call(this);
        this.expired = true;
        this.params = params;
        this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
        this.data = null;
        this._clientConfig = AWS3.util.copy(clientConfig || {});
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.service.assumeRoleWithWebIdentity(function (err, data) {
          self.data = null;
          if (!err) {
            self.data = data;
            self.service.credentialsFrom(data, self);
          }
          callback(err);
        });
      },
      createClients: function () {
        if (!this.service) {
          var stsConfig = AWS3.util.merge({}, this._clientConfig);
          stsConfig.params = this.params;
          this.service = new STS(stsConfig);
        }
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json
var require_cognito_identity_2014_06_30_min = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json'(
    exports,
    module2
  ) {
    module2.exports = {
      version: '2.0',
      metadata: {
        apiVersion: '2014-06-30',
        endpointPrefix: 'cognito-identity',
        jsonVersion: '1.1',
        protocol: 'json',
        serviceFullName: 'Amazon Cognito Identity',
        serviceId: 'Cognito Identity',
        signatureVersion: 'v4',
        targetPrefix: 'AWSCognitoIdentityService',
        uid: 'cognito-identity-2014-06-30',
      },
      operations: {
        CreateIdentityPool: {
          input: {
            type: 'structure',
            required: ['IdentityPoolName', 'AllowUnauthenticatedIdentities'],
            members: {
              IdentityPoolName: {},
              AllowUnauthenticatedIdentities: {
                type: 'boolean',
              },
              AllowClassicFlow: {
                type: 'boolean',
              },
              SupportedLoginProviders: {
                shape: 'S5',
              },
              DeveloperProviderName: {},
              OpenIdConnectProviderARNs: {
                shape: 'S9',
              },
              CognitoIdentityProviders: {
                shape: 'Sb',
              },
              SamlProviderARNs: {
                shape: 'Sg',
              },
              IdentityPoolTags: {
                shape: 'Sh',
              },
            },
          },
          output: {
            shape: 'Sk',
          },
        },
        DeleteIdentities: {
          input: {
            type: 'structure',
            required: ['IdentityIdsToDelete'],
            members: {
              IdentityIdsToDelete: {
                type: 'list',
                member: {},
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              UnprocessedIdentityIds: {
                type: 'list',
                member: {
                  type: 'structure',
                  members: {
                    IdentityId: {},
                    ErrorCode: {},
                  },
                },
              },
            },
          },
        },
        DeleteIdentityPool: {
          input: {
            type: 'structure',
            required: ['IdentityPoolId'],
            members: {
              IdentityPoolId: {},
            },
          },
        },
        DescribeIdentity: {
          input: {
            type: 'structure',
            required: ['IdentityId'],
            members: {
              IdentityId: {},
            },
          },
          output: {
            shape: 'Sv',
          },
        },
        DescribeIdentityPool: {
          input: {
            type: 'structure',
            required: ['IdentityPoolId'],
            members: {
              IdentityPoolId: {},
            },
          },
          output: {
            shape: 'Sk',
          },
        },
        GetCredentialsForIdentity: {
          input: {
            type: 'structure',
            required: ['IdentityId'],
            members: {
              IdentityId: {},
              Logins: {
                shape: 'S10',
              },
              CustomRoleArn: {},
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityId: {},
              Credentials: {
                type: 'structure',
                members: {
                  AccessKeyId: {},
                  SecretKey: {},
                  SessionToken: {},
                  Expiration: {
                    type: 'timestamp',
                  },
                },
              },
            },
          },
          authtype: 'none',
        },
        GetId: {
          input: {
            type: 'structure',
            required: ['IdentityPoolId'],
            members: {
              AccountId: {},
              IdentityPoolId: {},
              Logins: {
                shape: 'S10',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityId: {},
            },
          },
          authtype: 'none',
        },
        GetIdentityPoolRoles: {
          input: {
            type: 'structure',
            required: ['IdentityPoolId'],
            members: {
              IdentityPoolId: {},
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityPoolId: {},
              Roles: {
                shape: 'S1c',
              },
              RoleMappings: {
                shape: 'S1e',
              },
            },
          },
        },
        GetOpenIdToken: {
          input: {
            type: 'structure',
            required: ['IdentityId'],
            members: {
              IdentityId: {},
              Logins: {
                shape: 'S10',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityId: {},
              Token: {},
            },
          },
          authtype: 'none',
        },
        GetOpenIdTokenForDeveloperIdentity: {
          input: {
            type: 'structure',
            required: ['IdentityPoolId', 'Logins'],
            members: {
              IdentityPoolId: {},
              IdentityId: {},
              Logins: {
                shape: 'S10',
              },
              PrincipalTags: {
                shape: 'S1s',
              },
              TokenDuration: {
                type: 'long',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityId: {},
              Token: {},
            },
          },
        },
        GetPrincipalTagAttributeMap: {
          input: {
            type: 'structure',
            required: ['IdentityPoolId', 'IdentityProviderName'],
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: 'boolean',
              },
              PrincipalTags: {
                shape: 'S1s',
              },
            },
          },
        },
        ListIdentities: {
          input: {
            type: 'structure',
            required: ['IdentityPoolId', 'MaxResults'],
            members: {
              IdentityPoolId: {},
              MaxResults: {
                type: 'integer',
              },
              NextToken: {},
              HideDisabled: {
                type: 'boolean',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityPoolId: {},
              Identities: {
                type: 'list',
                member: {
                  shape: 'Sv',
                },
              },
              NextToken: {},
            },
          },
        },
        ListIdentityPools: {
          input: {
            type: 'structure',
            required: ['MaxResults'],
            members: {
              MaxResults: {
                type: 'integer',
              },
              NextToken: {},
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityPools: {
                type: 'list',
                member: {
                  type: 'structure',
                  members: {
                    IdentityPoolId: {},
                    IdentityPoolName: {},
                  },
                },
              },
              NextToken: {},
            },
          },
        },
        ListTagsForResource: {
          input: {
            type: 'structure',
            required: ['ResourceArn'],
            members: {
              ResourceArn: {},
            },
          },
          output: {
            type: 'structure',
            members: {
              Tags: {
                shape: 'Sh',
              },
            },
          },
        },
        LookupDeveloperIdentity: {
          input: {
            type: 'structure',
            required: ['IdentityPoolId'],
            members: {
              IdentityPoolId: {},
              IdentityId: {},
              DeveloperUserIdentifier: {},
              MaxResults: {
                type: 'integer',
              },
              NextToken: {},
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityId: {},
              DeveloperUserIdentifierList: {
                type: 'list',
                member: {},
              },
              NextToken: {},
            },
          },
        },
        MergeDeveloperIdentities: {
          input: {
            type: 'structure',
            required: ['SourceUserIdentifier', 'DestinationUserIdentifier', 'DeveloperProviderName', 'IdentityPoolId'],
            members: {
              SourceUserIdentifier: {},
              DestinationUserIdentifier: {},
              DeveloperProviderName: {},
              IdentityPoolId: {},
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityId: {},
            },
          },
        },
        SetIdentityPoolRoles: {
          input: {
            type: 'structure',
            required: ['IdentityPoolId', 'Roles'],
            members: {
              IdentityPoolId: {},
              Roles: {
                shape: 'S1c',
              },
              RoleMappings: {
                shape: 'S1e',
              },
            },
          },
        },
        SetPrincipalTagAttributeMap: {
          input: {
            type: 'structure',
            required: ['IdentityPoolId', 'IdentityProviderName'],
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: 'boolean',
              },
              PrincipalTags: {
                shape: 'S1s',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: 'boolean',
              },
              PrincipalTags: {
                shape: 'S1s',
              },
            },
          },
        },
        TagResource: {
          input: {
            type: 'structure',
            required: ['ResourceArn', 'Tags'],
            members: {
              ResourceArn: {},
              Tags: {
                shape: 'Sh',
              },
            },
          },
          output: {
            type: 'structure',
            members: {},
          },
        },
        UnlinkDeveloperIdentity: {
          input: {
            type: 'structure',
            required: ['IdentityId', 'IdentityPoolId', 'DeveloperProviderName', 'DeveloperUserIdentifier'],
            members: {
              IdentityId: {},
              IdentityPoolId: {},
              DeveloperProviderName: {},
              DeveloperUserIdentifier: {},
            },
          },
        },
        UnlinkIdentity: {
          input: {
            type: 'structure',
            required: ['IdentityId', 'Logins', 'LoginsToRemove'],
            members: {
              IdentityId: {},
              Logins: {
                shape: 'S10',
              },
              LoginsToRemove: {
                shape: 'Sw',
              },
            },
          },
          authtype: 'none',
        },
        UntagResource: {
          input: {
            type: 'structure',
            required: ['ResourceArn', 'TagKeys'],
            members: {
              ResourceArn: {},
              TagKeys: {
                type: 'list',
                member: {},
              },
            },
          },
          output: {
            type: 'structure',
            members: {},
          },
        },
        UpdateIdentityPool: {
          input: {
            shape: 'Sk',
          },
          output: {
            shape: 'Sk',
          },
        },
      },
      shapes: {
        S5: {
          type: 'map',
          key: {},
          value: {},
        },
        S9: {
          type: 'list',
          member: {},
        },
        Sb: {
          type: 'list',
          member: {
            type: 'structure',
            members: {
              ProviderName: {},
              ClientId: {},
              ServerSideTokenCheck: {
                type: 'boolean',
              },
            },
          },
        },
        Sg: {
          type: 'list',
          member: {},
        },
        Sh: {
          type: 'map',
          key: {},
          value: {},
        },
        Sk: {
          type: 'structure',
          required: ['IdentityPoolId', 'IdentityPoolName', 'AllowUnauthenticatedIdentities'],
          members: {
            IdentityPoolId: {},
            IdentityPoolName: {},
            AllowUnauthenticatedIdentities: {
              type: 'boolean',
            },
            AllowClassicFlow: {
              type: 'boolean',
            },
            SupportedLoginProviders: {
              shape: 'S5',
            },
            DeveloperProviderName: {},
            OpenIdConnectProviderARNs: {
              shape: 'S9',
            },
            CognitoIdentityProviders: {
              shape: 'Sb',
            },
            SamlProviderARNs: {
              shape: 'Sg',
            },
            IdentityPoolTags: {
              shape: 'Sh',
            },
          },
        },
        Sv: {
          type: 'structure',
          members: {
            IdentityId: {},
            Logins: {
              shape: 'Sw',
            },
            CreationDate: {
              type: 'timestamp',
            },
            LastModifiedDate: {
              type: 'timestamp',
            },
          },
        },
        Sw: {
          type: 'list',
          member: {},
        },
        S10: {
          type: 'map',
          key: {},
          value: {},
        },
        S1c: {
          type: 'map',
          key: {},
          value: {},
        },
        S1e: {
          type: 'map',
          key: {},
          value: {
            type: 'structure',
            required: ['Type'],
            members: {
              Type: {},
              AmbiguousRoleResolution: {},
              RulesConfiguration: {
                type: 'structure',
                required: ['Rules'],
                members: {
                  Rules: {
                    type: 'list',
                    member: {
                      type: 'structure',
                      required: ['Claim', 'MatchType', 'Value', 'RoleARN'],
                      members: {
                        Claim: {},
                        MatchType: {},
                        Value: {},
                        RoleARN: {},
                      },
                    },
                  },
                },
              },
            },
          },
        },
        S1s: {
          type: 'map',
          key: {},
          value: {},
        },
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json
var require_cognito_identity_2014_06_30_paginators = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json'(
    exports,
    module2
  ) {
    module2.exports = {
      pagination: {
        ListIdentityPools: {
          input_token: 'NextToken',
          limit_key: 'MaxResults',
          output_token: 'NextToken',
          result_key: 'IdentityPools',
        },
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/clients/cognitoidentity.js
var require_cognitoidentity = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/clients/cognitoidentity.js'(exports, module2) {
    require_node_loader();
    var AWS3 = require_core();
    var Service = AWS3.Service;
    var apiLoader = AWS3.apiLoader;
    apiLoader.services['cognitoidentity'] = {};
    AWS3.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
    Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
      get: function get() {
        var model = require_cognito_identity_2014_06_30_min();
        model.paginators = require_cognito_identity_2014_06_30_paginators().pagination;
        return model;
      },
      enumerable: true,
      configurable: true,
    });
    module2.exports = AWS3.CognitoIdentity;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js
var require_cognito_identity_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js'() {
    var AWS3 = require_core();
    var CognitoIdentity = require_cognitoidentity();
    var STS = require_sts2();
    AWS3.CognitoIdentityCredentials = AWS3.util.inherit(AWS3.Credentials, {
      localStorageKey: {
        id: 'aws.cognito.identity-id.',
        providers: 'aws.cognito.identity-providers.',
      },
      constructor: function CognitoIdentityCredentials(params, clientConfig) {
        AWS3.Credentials.call(this);
        this.expired = true;
        this.params = params;
        this.data = null;
        this._identityId = null;
        this._clientConfig = AWS3.util.copy(clientConfig || {});
        this.loadCachedId();
        var self = this;
        Object.defineProperty(this, 'identityId', {
          get: function () {
            self.loadCachedId();
            return self._identityId || self.params.IdentityId;
          },
          set: function (identityId) {
            self._identityId = identityId;
          },
        });
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.data = null;
        self._identityId = null;
        self.getId(function (err) {
          if (!err) {
            if (!self.params.RoleArn) {
              self.getCredentialsForIdentity(callback);
            } else {
              self.getCredentialsFromSTS(callback);
            }
          } else {
            self.clearIdOnNotAuthorized(err);
            callback(err);
          }
        });
      },
      clearCachedId: function clearCache() {
        this._identityId = null;
        delete this.params.IdentityId;
        var poolId = this.params.IdentityPoolId;
        var loginId = this.params.LoginId || '';
        delete this.storage[this.localStorageKey.id + poolId + loginId];
        delete this.storage[this.localStorageKey.providers + poolId + loginId];
      },
      clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
        var self = this;
        if (err.code == 'NotAuthorizedException') {
          self.clearCachedId();
        }
      },
      getId: function getId(callback) {
        var self = this;
        if (typeof self.params.IdentityId === 'string') {
          return callback(null, self.params.IdentityId);
        }
        self.cognito.getId(function (err, data) {
          if (!err && data.IdentityId) {
            self.params.IdentityId = data.IdentityId;
            callback(null, data.IdentityId);
          } else {
            callback(err);
          }
        });
      },
      loadCredentials: function loadCredentials(data, credentials) {
        if (!data || !credentials) return;
        credentials.expired = false;
        credentials.accessKeyId = data.Credentials.AccessKeyId;
        credentials.secretAccessKey = data.Credentials.SecretKey;
        credentials.sessionToken = data.Credentials.SessionToken;
        credentials.expireTime = data.Credentials.Expiration;
      },
      getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
        var self = this;
        self.cognito.getCredentialsForIdentity(function (err, data) {
          if (!err) {
            self.cacheId(data);
            self.data = data;
            self.loadCredentials(self.data, self);
          } else {
            self.clearIdOnNotAuthorized(err);
          }
          callback(err);
        });
      },
      getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
        var self = this;
        self.cognito.getOpenIdToken(function (err, data) {
          if (!err) {
            self.cacheId(data);
            self.params.WebIdentityToken = data.Token;
            self.webIdentityCredentials.refresh(function (webErr) {
              if (!webErr) {
                self.data = self.webIdentityCredentials.data;
                self.sts.credentialsFrom(self.data, self);
              }
              callback(webErr);
            });
          } else {
            self.clearIdOnNotAuthorized(err);
            callback(err);
          }
        });
      },
      loadCachedId: function loadCachedId() {
        var self = this;
        if (AWS3.util.isBrowser() && !self.params.IdentityId) {
          var id = self.getStorage('id');
          if (id && self.params.Logins) {
            var actualProviders = Object.keys(self.params.Logins);
            var cachedProviders = (self.getStorage('providers') || '').split(',');
            var intersect = cachedProviders.filter(function (n) {
              return actualProviders.indexOf(n) !== -1;
            });
            if (intersect.length !== 0) {
              self.params.IdentityId = id;
            }
          } else if (id) {
            self.params.IdentityId = id;
          }
        }
      },
      createClients: function () {
        var clientConfig = this._clientConfig;
        this.webIdentityCredentials =
          this.webIdentityCredentials || new AWS3.WebIdentityCredentials(this.params, clientConfig);
        if (!this.cognito) {
          var cognitoConfig = AWS3.util.merge({}, clientConfig);
          cognitoConfig.params = this.params;
          this.cognito = new CognitoIdentity(cognitoConfig);
        }
        this.sts = this.sts || new STS(clientConfig);
      },
      cacheId: function cacheId(data) {
        this._identityId = data.IdentityId;
        this.params.IdentityId = this._identityId;
        if (AWS3.util.isBrowser()) {
          this.setStorage('id', data.IdentityId);
          if (this.params.Logins) {
            this.setStorage('providers', Object.keys(this.params.Logins).join(','));
          }
        }
      },
      getStorage: function getStorage(key) {
        return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
      },
      setStorage: function setStorage(key, val) {
        try {
          this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
        } catch (_) {}
      },
      storage: (function () {
        try {
          var storage =
            AWS3.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object'
              ? window.localStorage
              : {};
          storage['aws.test-storage'] = 'foobar';
          delete storage['aws.test-storage'];
          return storage;
        } catch (_) {
          return {};
        }
      })(),
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/saml_credentials.js
var require_saml_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/saml_credentials.js'() {
    var AWS3 = require_core();
    var STS = require_sts2();
    AWS3.SAMLCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function SAMLCredentials(params) {
        AWS3.Credentials.call(this);
        this.expired = true;
        this.params = params;
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.service.assumeRoleWithSAML(function (err, data) {
          if (!err) {
            self.service.credentialsFrom(data, self);
          }
          callback(err);
        });
      },
      createClients: function () {
        this.service = this.service || new STS({ params: this.params });
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/process_credentials.js
var require_process_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/process_credentials.js'() {
    var AWS3 = require_core();
    var proc = require('child_process');
    var iniLoader = AWS3.util.iniLoader;
    AWS3.ProcessCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function ProcessCredentials(options) {
        AWS3.Credentials.call(this);
        options = options || {};
        this.filename = options.filename;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS3.util.defaultProfile;
        this.get(options.callback || AWS3.util.fn.noop);
      },
      load: function load(callback) {
        var self = this;
        try {
          var profiles = AWS3.util.getProfilesFromSharedConfig(iniLoader, this.filename);
          var profile = profiles[this.profile] || {};
          if (Object.keys(profile).length === 0) {
            throw AWS3.util.error(new Error('Profile ' + this.profile + ' not found'), {
              code: 'ProcessCredentialsProviderFailure',
            });
          }
          if (profile['credential_process']) {
            this.loadViaCredentialProcess(profile, function (err, data) {
              if (err) {
                callback(err, null);
              } else {
                self.expired = false;
                self.accessKeyId = data.AccessKeyId;
                self.secretAccessKey = data.SecretAccessKey;
                self.sessionToken = data.SessionToken;
                if (data.Expiration) {
                  self.expireTime = new Date(data.Expiration);
                }
                callback(null);
              }
            });
          } else {
            throw AWS3.util.error(new Error('Profile ' + this.profile + ' did not include credential process'), {
              code: 'ProcessCredentialsProviderFailure',
            });
          }
        } catch (err) {
          callback(err);
        }
      },
      loadViaCredentialProcess: function loadViaCredentialProcess(profile, callback) {
        proc.exec(profile['credential_process'], { env: process.env }, function (err, stdOut, stdErr) {
          if (err) {
            callback(
              AWS3.util.error(new Error('credential_process returned error'), {
                code: 'ProcessCredentialsProviderFailure',
              }),
              null
            );
          } else {
            try {
              var credData = JSON.parse(stdOut);
              if (credData.Expiration) {
                var currentTime = AWS3.util.date.getDate();
                var expireTime = new Date(credData.Expiration);
                if (expireTime < currentTime) {
                  throw Error('credential_process returned expired credentials');
                }
              }
              if (credData.Version !== 1) {
                throw Error('credential_process does not return Version == 1');
              }
              callback(null, credData);
            } catch (err2) {
              callback(AWS3.util.error(new Error(err2.message), { code: 'ProcessCredentialsProviderFailure' }), null);
            }
          }
        });
      },
      refresh: function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
    });
  },
});

// node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS({
  'node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/defaults.js'(exports) {
    (function () {
      exports.defaults = {
        0.1: {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: '@',
          charkey: '#',
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: '@@',
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: '',
        },
        0.2: {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: '$',
          charkey: '_',
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          preserveChildrenOrder: false,
          childkey: '$$',
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: 'root',
          xmldec: {
            version: '1.0',
            encoding: 'UTF-8',
            standalone: true,
          },
          doctype: null,
          renderOpts: {
            pretty: true,
            indent: '  ',
            newline: '\n',
          },
          headless: false,
          chunkSize: 1e4,
          emptyTag: '',
          cdata: false,
        },
      };
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js'(exports, module2) {
    (function () {
      var assign,
        getValue,
        isArray,
        isEmpty,
        isFunction,
        isObject,
        isPlainObject,
        slice = [].slice,
        hasProp = {}.hasOwnProperty;
      assign = function () {
        var i, key, len, source, sources, target;
        (target = arguments[0]), (sources = 2 <= arguments.length ? slice.call(arguments, 1) : []);
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i = 0, len = sources.length; i < len; i++) {
            source = sources[i];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key)) continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      };
      isFunction = function (val) {
        return !!val && Object.prototype.toString.call(val) === '[object Function]';
      };
      isObject = function (val) {
        var ref;
        return !!val && ((ref = typeof val) === 'function' || ref === 'object');
      };
      isArray = function (val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === '[object Array]';
        }
      };
      isEmpty = function (val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key)) continue;
            return false;
          }
          return true;
        }
      };
      isPlainObject = function (val) {
        var ctor, proto;
        return (
          isObject(val) &&
          (proto = Object.getPrototypeOf(val)) &&
          (ctor = proto.constructor) &&
          typeof ctor === 'function' &&
          ctor instanceof ctor &&
          Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object)
        );
      };
      getValue = function (obj) {
        if (isFunction(obj.valueOf)) {
          return obj.valueOf();
        } else {
          return obj;
        }
      };
      module2.exports.assign = assign;
      module2.exports.isFunction = isFunction;
      module2.exports.isObject = isObject;
      module2.exports.isArray = isArray;
      module2.exports.isEmpty = isEmpty;
      module2.exports.isPlainObject = isPlainObject;
      module2.exports.getValue = getValue;
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMImplementation.js'(exports, module2) {
    (function () {
      var XMLDOMImplementation;
      module2.exports = XMLDOMImplementation = (function () {
        function XMLDOMImplementation2() {}
        XMLDOMImplementation2.prototype.hasFeature = function (feature, version) {
          return true;
        };
        XMLDOMImplementation2.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {
          throw new Error('This DOM method is not implemented.');
        };
        XMLDOMImplementation2.prototype.createDocument = function (namespaceURI, qualifiedName, doctype) {
          throw new Error('This DOM method is not implemented.');
        };
        XMLDOMImplementation2.prototype.createHTMLDocument = function (title) {
          throw new Error('This DOM method is not implemented.');
        };
        XMLDOMImplementation2.prototype.getFeature = function (feature, version) {
          throw new Error('This DOM method is not implemented.');
        };
        return XMLDOMImplementation2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js'(exports, module2) {
    (function () {
      var XMLDOMErrorHandler;
      module2.exports = XMLDOMErrorHandler = (function () {
        function XMLDOMErrorHandler2() {}
        XMLDOMErrorHandler2.prototype.handleError = function (error) {
          throw new Error(error);
        };
        return XMLDOMErrorHandler2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMStringList.js'(exports, module2) {
    (function () {
      var XMLDOMStringList;
      module2.exports = XMLDOMStringList = (function () {
        function XMLDOMStringList2(arr) {
          this.arr = arr || [];
        }
        Object.defineProperty(XMLDOMStringList2.prototype, 'length', {
          get: function () {
            return this.arr.length;
          },
        });
        XMLDOMStringList2.prototype.item = function (index) {
          return this.arr[index] || null;
        };
        XMLDOMStringList2.prototype.contains = function (str) {
          return this.arr.indexOf(str) !== -1;
        };
        return XMLDOMStringList2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMConfiguration.js'(exports, module2) {
    (function () {
      var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
      XMLDOMErrorHandler = require_XMLDOMErrorHandler();
      XMLDOMStringList = require_XMLDOMStringList();
      module2.exports = XMLDOMConfiguration = (function () {
        function XMLDOMConfiguration2() {
          var clonedSelf;
          this.defaultParams = {
            'canonical-form': false,
            'cdata-sections': false,
            comments: false,
            'datatype-normalization': false,
            'element-content-whitespace': true,
            entities: true,
            'error-handler': new XMLDOMErrorHandler(),
            infoset: true,
            'validate-if-schema': false,
            namespaces: true,
            'namespace-declarations': true,
            'normalize-characters': false,
            'schema-location': '',
            'schema-type': '',
            'split-cdata-sections': true,
            validate: false,
            'well-formed': true,
          };
          this.params = clonedSelf = Object.create(this.defaultParams);
        }
        Object.defineProperty(XMLDOMConfiguration2.prototype, 'parameterNames', {
          get: function () {
            return new XMLDOMStringList(Object.keys(this.defaultParams));
          },
        });
        XMLDOMConfiguration2.prototype.getParameter = function (name) {
          if (this.params.hasOwnProperty(name)) {
            return this.params[name];
          } else {
            return null;
          }
        };
        XMLDOMConfiguration2.prototype.canSetParameter = function (name, value) {
          return true;
        };
        XMLDOMConfiguration2.prototype.setParameter = function (name, value) {
          if (value != null) {
            return (this.params[name] = value);
          } else {
            return delete this.params[name];
          }
        };
        return XMLDOMConfiguration2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js'(exports, module2) {
    (function () {
      module2.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205,
      };
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLAttribute.js'(exports, module2) {
    (function () {
      var NodeType, XMLAttribute, XMLNode;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module2.exports = XMLAttribute = (function () {
        function XMLAttribute2(parent, name, value) {
          this.parent = parent;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          if (name == null) {
            throw new Error('Missing attribute name. ' + this.debugInfo(name));
          }
          this.name = this.stringify.name(name);
          this.value = this.stringify.attValue(value);
          this.type = NodeType.Attribute;
          this.isId = false;
          this.schemaTypeInfo = null;
        }
        Object.defineProperty(XMLAttribute2.prototype, 'nodeType', {
          get: function () {
            return this.type;
          },
        });
        Object.defineProperty(XMLAttribute2.prototype, 'ownerElement', {
          get: function () {
            return this.parent;
          },
        });
        Object.defineProperty(XMLAttribute2.prototype, 'textContent', {
          get: function () {
            return this.value;
          },
          set: function (value) {
            return (this.value = value || '');
          },
        });
        Object.defineProperty(XMLAttribute2.prototype, 'namespaceURI', {
          get: function () {
            return '';
          },
        });
        Object.defineProperty(XMLAttribute2.prototype, 'prefix', {
          get: function () {
            return '';
          },
        });
        Object.defineProperty(XMLAttribute2.prototype, 'localName', {
          get: function () {
            return this.name;
          },
        });
        Object.defineProperty(XMLAttribute2.prototype, 'specified', {
          get: function () {
            return true;
          },
        });
        XMLAttribute2.prototype.clone = function () {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function (options) {
          return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
        };
        XMLAttribute2.prototype.debugInfo = function (name) {
          name = name || this.name;
          if (name == null) {
            return 'parent: <' + this.parent.name + '>';
          } else {
            return 'attribute: {' + name + '}, parent: <' + this.parent.name + '>';
          }
        };
        XMLAttribute2.prototype.isEqualNode = function (node) {
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.value !== this.value) {
            return false;
          }
          return true;
        };
        return XMLAttribute2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js'(exports, module2) {
    (function () {
      var XMLNamedNodeMap;
      module2.exports = XMLNamedNodeMap = (function () {
        function XMLNamedNodeMap2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNamedNodeMap2.prototype, 'length', {
          get: function () {
            return Object.keys(this.nodes).length || 0;
          },
        });
        XMLNamedNodeMap2.prototype.clone = function () {
          return (this.nodes = null);
        };
        XMLNamedNodeMap2.prototype.getNamedItem = function (name) {
          return this.nodes[name];
        };
        XMLNamedNodeMap2.prototype.setNamedItem = function (node) {
          var oldNode;
          oldNode = this.nodes[node.nodeName];
          this.nodes[node.nodeName] = node;
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.removeNamedItem = function (name) {
          var oldNode;
          oldNode = this.nodes[name];
          delete this.nodes[name];
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.item = function (index) {
          return this.nodes[Object.keys(this.nodes)[index]] || null;
        };
        XMLNamedNodeMap2.prototype.getNamedItemNS = function (namespaceURI, localName) {
          throw new Error('This DOM method is not implemented.');
        };
        XMLNamedNodeMap2.prototype.setNamedItemNS = function (node) {
          throw new Error('This DOM method is not implemented.');
        };
        XMLNamedNodeMap2.prototype.removeNamedItemNS = function (namespaceURI, localName) {
          throw new Error('This DOM method is not implemented.');
        };
        return XMLNamedNodeMap2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLElement.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLAttribute,
        XMLElement,
        XMLNamedNodeMap,
        XMLNode,
        getValue,
        isFunction,
        isObject,
        ref,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      (ref = require_Utility()), (isObject = ref.isObject), (isFunction = ref.isFunction), (getValue = ref.getValue);
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLAttribute = require_XMLAttribute();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module2.exports = XMLElement = (function (superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent, name, attributes) {
          var child, j, len, ref1;
          XMLElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error('Missing element name. ' + this.debugInfo());
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.Element;
          this.attribs = {};
          this.schemaTypeInfo = null;
          if (attributes != null) {
            this.attribute(attributes);
          }
          if (parent.type === NodeType.Document) {
            this.isRoot = true;
            this.documentObject = parent;
            parent.rootObject = this;
            if (parent.children) {
              ref1 = parent.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                if (child.type === NodeType.DocType) {
                  child.name = this.name;
                  break;
                }
              }
            }
          }
        }
        Object.defineProperty(XMLElement2.prototype, 'tagName', {
          get: function () {
            return this.name;
          },
        });
        Object.defineProperty(XMLElement2.prototype, 'namespaceURI', {
          get: function () {
            return '';
          },
        });
        Object.defineProperty(XMLElement2.prototype, 'prefix', {
          get: function () {
            return '';
          },
        });
        Object.defineProperty(XMLElement2.prototype, 'localName', {
          get: function () {
            return this.name;
          },
        });
        Object.defineProperty(XMLElement2.prototype, 'id', {
          get: function () {
            throw new Error('This DOM method is not implemented.' + this.debugInfo());
          },
        });
        Object.defineProperty(XMLElement2.prototype, 'className', {
          get: function () {
            throw new Error('This DOM method is not implemented.' + this.debugInfo());
          },
        });
        Object.defineProperty(XMLElement2.prototype, 'classList', {
          get: function () {
            throw new Error('This DOM method is not implemented.' + this.debugInfo());
          },
        });
        Object.defineProperty(XMLElement2.prototype, 'attributes', {
          get: function () {
            if (!this.attributeMap || !this.attributeMap.nodes) {
              this.attributeMap = new XMLNamedNodeMap(this.attribs);
            }
            return this.attributeMap;
          },
        });
        XMLElement2.prototype.clone = function () {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attribs = {};
          ref1 = this.attribs;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName)) continue;
            att = ref1[attName];
            clonedSelf.attribs[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function (child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function (name, value) {
          var attName, attValue;
          if (name != null) {
            name = getValue(name);
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName)) continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.attribs[name] = new XMLAttribute(this, name, '');
            } else if (value != null) {
              this.attribs[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function (name) {
          var attName, j, len;
          if (name == null) {
            throw new Error('Missing attribute name. ' + this.debugInfo());
          }
          name = getValue(name);
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              attName = name[j];
              delete this.attribs[attName];
            }
          } else {
            delete this.attribs[name];
          }
          return this;
        };
        XMLElement2.prototype.toString = function (options) {
          return this.options.writer.element(this, this.options.writer.filterOptions(options));
        };
        XMLElement2.prototype.att = function (name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.a = function (name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.getAttribute = function (name) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name].value;
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttribute = function (name, value) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNode = function (name) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name];
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttributeNode = function (newAttr) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNode = function (oldAttr) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function (name) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNS = function (namespaceURI, localName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNS = function (namespaceURI, qualifiedName, value) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNS = function (namespaceURI, localName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNodeNS = function (namespaceURI, localName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNodeNS = function (newAttr) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.hasAttribute = function (name) {
          return this.attribs.hasOwnProperty(name);
        };
        XMLElement2.prototype.hasAttributeNS = function (namespaceURI, localName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttribute = function (name, isId) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name].isId;
          } else {
            return isId;
          }
        };
        XMLElement2.prototype.setIdAttributeNS = function (namespaceURI, localName, isId) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttributeNode = function (idAttr, isId) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function (tagname) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByClassName = function (classNames) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLElement2.prototype.isEqualNode = function (node) {
          var i, j, ref1;
          if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.attribs.length !== this.attribs.length) {
            return false;
          }
          for (
            i = j = 0, ref1 = this.attribs.length - 1;
            0 <= ref1 ? j <= ref1 : j >= ref1;
            i = 0 <= ref1 ? ++j : --j
          ) {
            if (!this.attribs[i].isEqualNode(node.attribs[i])) {
              return false;
            }
          }
          return true;
        };
        return XMLElement2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCharacterData.js'(exports, module2) {
    (function () {
      var XMLCharacterData,
        XMLNode,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLCharacterData = (function (superClass) {
        extend(XMLCharacterData2, superClass);
        function XMLCharacterData2(parent) {
          XMLCharacterData2.__super__.constructor.call(this, parent);
          this.value = '';
        }
        Object.defineProperty(XMLCharacterData2.prototype, 'data', {
          get: function () {
            return this.value;
          },
          set: function (value) {
            return (this.value = value || '');
          },
        });
        Object.defineProperty(XMLCharacterData2.prototype, 'length', {
          get: function () {
            return this.value.length;
          },
        });
        Object.defineProperty(XMLCharacterData2.prototype, 'textContent', {
          get: function () {
            return this.value;
          },
          set: function (value) {
            return (this.value = value || '');
          },
        });
        XMLCharacterData2.prototype.clone = function () {
          return Object.create(this);
        };
        XMLCharacterData2.prototype.substringData = function (offset, count) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLCharacterData2.prototype.appendData = function (arg) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLCharacterData2.prototype.insertData = function (offset, arg) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLCharacterData2.prototype.deleteData = function (offset, count) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLCharacterData2.prototype.replaceData = function (offset, count, arg) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLCharacterData2.prototype.isEqualNode = function (node) {
          if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.data !== this.data) {
            return false;
          }
          return true;
        };
        return XMLCharacterData2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCData.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLCData,
        XMLCharacterData,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLCData = (function (superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent, text) {
          XMLCData2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error('Missing CDATA text. ' + this.debugInfo());
          }
          this.name = '#cdata-section';
          this.type = NodeType.CData;
          this.value = this.stringify.cdata(text);
        }
        XMLCData2.prototype.clone = function () {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function (options) {
          return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        };
        return XMLCData2;
      })(XMLCharacterData);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLComment.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLCharacterData,
        XMLComment,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLComment = (function (superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent, text) {
          XMLComment2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error('Missing comment text. ' + this.debugInfo());
          }
          this.name = '#comment';
          this.type = NodeType.Comment;
          this.value = this.stringify.comment(text);
        }
        XMLComment2.prototype.clone = function () {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function (options) {
          return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        };
        return XMLComment2;
      })(XMLCharacterData);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDeclaration.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLDeclaration,
        XMLNode,
        isObject,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDeclaration = (function (superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent, version, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent);
          if (isObject(version)) {
            (ref = version), (version = ref.version), (encoding = ref.encoding), (standalone = ref.standalone);
          }
          if (!version) {
            version = '1.0';
          }
          this.type = NodeType.Declaration;
          this.version = this.stringify.xmlVersion(version);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        XMLDeclaration2.prototype.toString = function (options) {
          return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        };
        return XMLDeclaration2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDAttList.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLDTDAttList,
        XMLNode,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDAttList = (function (superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent);
          if (elementName == null) {
            throw new Error('Missing DTD element name. ' + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error('Missing DTD attribute name. ' + this.debugInfo(elementName));
          }
          if (!attributeType) {
            throw new Error('Missing DTD attribute type. ' + this.debugInfo(elementName));
          }
          if (!defaultValueType) {
            throw new Error('Missing DTD attribute default. ' + this.debugInfo(elementName));
          }
          if (defaultValueType.indexOf('#') !== 0) {
            defaultValueType = '#' + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error(
              'Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. ' +
                this.debugInfo(elementName)
            );
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error('Default value only applies to #FIXED or #DEFAULT. ' + this.debugInfo(elementName));
          }
          this.elementName = this.stringify.name(elementName);
          this.type = NodeType.AttributeDeclaration;
          this.attributeName = this.stringify.name(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          if (defaultValue) {
            this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          }
          this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList2.prototype.toString = function (options) {
          return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDAttList2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDEntity.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLDTDEntity,
        XMLNode,
        isObject,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDEntity = (function (superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent, pe, name, value) {
          XMLDTDEntity2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error('Missing DTD entity name. ' + this.debugInfo(name));
          }
          if (value == null) {
            throw new Error('Missing DTD entity value. ' + this.debugInfo(name));
          }
          this.pe = !!pe;
          this.name = this.stringify.name(name);
          this.type = NodeType.EntityDeclaration;
          if (!isObject(value)) {
            this.value = this.stringify.dtdEntityValue(value);
            this.internal = true;
          } else {
            if (!value.pubID && !value.sysID) {
              throw new Error(
                'Public and/or system identifiers are required for an external entity. ' + this.debugInfo(name)
              );
            }
            if (value.pubID && !value.sysID) {
              throw new Error('System identifier is required for a public external entity. ' + this.debugInfo(name));
            }
            this.internal = false;
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
            if (value.nData != null) {
              this.nData = this.stringify.dtdNData(value.nData);
            }
            if (this.pe && this.nData) {
              throw new Error('Notation declaration is not allowed in a parameter entity. ' + this.debugInfo(name));
            }
          }
        }
        Object.defineProperty(XMLDTDEntity2.prototype, 'publicId', {
          get: function () {
            return this.pubID;
          },
        });
        Object.defineProperty(XMLDTDEntity2.prototype, 'systemId', {
          get: function () {
            return this.sysID;
          },
        });
        Object.defineProperty(XMLDTDEntity2.prototype, 'notationName', {
          get: function () {
            return this.nData || null;
          },
        });
        Object.defineProperty(XMLDTDEntity2.prototype, 'inputEncoding', {
          get: function () {
            return null;
          },
        });
        Object.defineProperty(XMLDTDEntity2.prototype, 'xmlEncoding', {
          get: function () {
            return null;
          },
        });
        Object.defineProperty(XMLDTDEntity2.prototype, 'xmlVersion', {
          get: function () {
            return null;
          },
        });
        XMLDTDEntity2.prototype.toString = function (options) {
          return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDEntity2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDElement.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLDTDElement,
        XMLNode,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDElement = (function (superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent, name, value) {
          XMLDTDElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error('Missing DTD element name. ' + this.debugInfo());
          }
          if (!value) {
            value = '(#PCDATA)';
          }
          if (Array.isArray(value)) {
            value = '(' + value.join(',') + ')';
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.ElementDeclaration;
          this.value = this.stringify.dtdElementValue(value);
        }
        XMLDTDElement2.prototype.toString = function (options) {
          return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDElement2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDNotation.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLDTDNotation,
        XMLNode,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDNotation = (function (superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent, name, value) {
          XMLDTDNotation2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error('Missing DTD notation name. ' + this.debugInfo(name));
          }
          if (!value.pubID && !value.sysID) {
            throw new Error(
              'Public or system identifiers are required for an external entity. ' + this.debugInfo(name)
            );
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.NotationDeclaration;
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
        }
        Object.defineProperty(XMLDTDNotation2.prototype, 'publicId', {
          get: function () {
            return this.pubID;
          },
        });
        Object.defineProperty(XMLDTDNotation2.prototype, 'systemId', {
          get: function () {
            return this.sysID;
          },
        });
        XMLDTDNotation2.prototype.toString = function (options) {
          return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDNotation2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocType.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLDTDAttList,
        XMLDTDElement,
        XMLDTDEntity,
        XMLDTDNotation,
        XMLDocType,
        XMLNamedNodeMap,
        XMLNode,
        isObject,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module2.exports = XMLDocType = (function (superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent, pubID, sysID) {
          var child, i, len, ref, ref1, ref2;
          XMLDocType2.__super__.constructor.call(this, parent);
          this.type = NodeType.DocType;
          if (parent.children) {
            ref = parent.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.Element) {
                this.name = child.name;
                break;
              }
            }
          }
          this.documentObject = parent;
          if (isObject(pubID)) {
            (ref1 = pubID), (pubID = ref1.pubID), (sysID = ref1.sysID);
          }
          if (sysID == null) {
            (ref2 = [pubID, sysID]), (sysID = ref2[0]), (pubID = ref2[1]);
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        Object.defineProperty(XMLDocType2.prototype, 'entities', {
          get: function () {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.EntityDeclaration && !child.pe) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          },
        });
        Object.defineProperty(XMLDocType2.prototype, 'notations', {
          get: function () {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.NotationDeclaration) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          },
        });
        Object.defineProperty(XMLDocType2.prototype, 'publicId', {
          get: function () {
            return this.pubID;
          },
        });
        Object.defineProperty(XMLDocType2.prototype, 'systemId', {
          get: function () {
            return this.sysID;
          },
        });
        Object.defineProperty(XMLDocType2.prototype, 'internalSubset', {
          get: function () {
            throw new Error('This DOM method is not implemented.' + this.debugInfo());
          },
        });
        XMLDocType2.prototype.element = function (name, value) {
          var child;
          child = new XMLDTDElement(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function (
          elementName,
          attributeName,
          attributeType,
          defaultValueType,
          defaultValue
        ) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function (name, value) {
          var child;
          child = new XMLDTDEntity(this, false, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function (name, value) {
          var child;
          child = new XMLDTDEntity(this, true, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function (name, value) {
          var child;
          child = new XMLDTDNotation(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function (options) {
          return this.options.writer.docType(this, this.options.writer.filterOptions(options));
        };
        XMLDocType2.prototype.ele = function (name, value) {
          return this.element(name, value);
        };
        XMLDocType2.prototype.att = function (
          elementName,
          attributeName,
          attributeType,
          defaultValueType,
          defaultValue
        ) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function (name, value) {
          return this.entity(name, value);
        };
        XMLDocType2.prototype.pent = function (name, value) {
          return this.pEntity(name, value);
        };
        XMLDocType2.prototype.not = function (name, value) {
          return this.notation(name, value);
        };
        XMLDocType2.prototype.up = function () {
          return this.root() || this.documentObject;
        };
        XMLDocType2.prototype.isEqualNode = function (node) {
          if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.name !== this.name) {
            return false;
          }
          if (node.publicId !== this.publicId) {
            return false;
          }
          if (node.systemId !== this.systemId) {
            return false;
          }
          return true;
        };
        return XMLDocType2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLRaw.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLNode,
        XMLRaw,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module2.exports = XMLRaw = (function (superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent, text) {
          XMLRaw2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error('Missing raw text. ' + this.debugInfo());
          }
          this.type = NodeType.Raw;
          this.value = this.stringify.raw(text);
        }
        XMLRaw2.prototype.clone = function () {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function (options) {
          return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        };
        return XMLRaw2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLText.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLCharacterData,
        XMLText,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLText = (function (superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent, text) {
          XMLText2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error('Missing element text. ' + this.debugInfo());
          }
          this.name = '#text';
          this.type = NodeType.Text;
          this.value = this.stringify.text(text);
        }
        Object.defineProperty(XMLText2.prototype, 'isElementContentWhitespace', {
          get: function () {
            throw new Error('This DOM method is not implemented.' + this.debugInfo());
          },
        });
        Object.defineProperty(XMLText2.prototype, 'wholeText', {
          get: function () {
            var next, prev, str;
            str = '';
            prev = this.previousSibling;
            while (prev) {
              str = prev.data + str;
              prev = prev.previousSibling;
            }
            str += this.data;
            next = this.nextSibling;
            while (next) {
              str = str + next.data;
              next = next.nextSibling;
            }
            return str;
          },
        });
        XMLText2.prototype.clone = function () {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function (options) {
          return this.options.writer.text(this, this.options.writer.filterOptions(options));
        };
        XMLText2.prototype.splitText = function (offset) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLText2.prototype.replaceWholeText = function (content) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        return XMLText2;
      })(XMLCharacterData);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLCharacterData,
        XMLProcessingInstruction,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLProcessingInstruction = (function (superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent, target, value) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent);
          if (target == null) {
            throw new Error('Missing instruction target. ' + this.debugInfo());
          }
          this.type = NodeType.ProcessingInstruction;
          this.target = this.stringify.insTarget(target);
          this.name = this.target;
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
        XMLProcessingInstruction2.prototype.clone = function () {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function (options) {
          return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        };
        XMLProcessingInstruction2.prototype.isEqualNode = function (node) {
          if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.target !== this.target) {
            return false;
          }
          return true;
        };
        return XMLProcessingInstruction2;
      })(XMLCharacterData);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDummy.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLDummy,
        XMLNode,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDummy = (function (superClass) {
        extend(XMLDummy2, superClass);
        function XMLDummy2(parent) {
          XMLDummy2.__super__.constructor.call(this, parent);
          this.type = NodeType.Dummy;
        }
        XMLDummy2.prototype.clone = function () {
          return Object.create(this);
        };
        XMLDummy2.prototype.toString = function (options) {
          return '';
        };
        return XMLDummy2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNodeList.js'(exports, module2) {
    (function () {
      var XMLNodeList;
      module2.exports = XMLNodeList = (function () {
        function XMLNodeList2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNodeList2.prototype, 'length', {
          get: function () {
            return this.nodes.length || 0;
          },
        });
        XMLNodeList2.prototype.clone = function () {
          return (this.nodes = null);
        };
        XMLNodeList2.prototype.item = function (index) {
          return this.nodes[index] || null;
        };
        return XMLNodeList2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/DocumentPosition.js'(exports, module2) {
    (function () {
      module2.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32,
      };
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js'(exports, module2) {
    (function () {
      var DocumentPosition,
        NodeType,
        XMLCData,
        XMLComment,
        XMLDeclaration,
        XMLDocType,
        XMLDummy,
        XMLElement,
        XMLNamedNodeMap,
        XMLNode,
        XMLNodeList,
        XMLProcessingInstruction,
        XMLRaw,
        XMLText,
        getValue,
        isEmpty,
        isFunction,
        isObject,
        ref1,
        hasProp = {}.hasOwnProperty;
      (ref1 = require_Utility()),
        (isObject = ref1.isObject),
        (isFunction = ref1.isFunction),
        (isEmpty = ref1.isEmpty),
        (getValue = ref1.getValue);
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      XMLDummy = null;
      NodeType = null;
      XMLNodeList = null;
      XMLNamedNodeMap = null;
      DocumentPosition = null;
      module2.exports = XMLNode = (function () {
        function XMLNode2(parent1) {
          this.parent = parent1;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.value = null;
          this.children = [];
          this.baseURI = null;
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
            XMLDummy = require_XMLDummy();
            NodeType = require_NodeType();
            XMLNodeList = require_XMLNodeList();
            XMLNamedNodeMap = require_XMLNamedNodeMap();
            DocumentPosition = require_DocumentPosition();
          }
        }
        Object.defineProperty(XMLNode2.prototype, 'nodeName', {
          get: function () {
            return this.name;
          },
        });
        Object.defineProperty(XMLNode2.prototype, 'nodeType', {
          get: function () {
            return this.type;
          },
        });
        Object.defineProperty(XMLNode2.prototype, 'nodeValue', {
          get: function () {
            return this.value;
          },
        });
        Object.defineProperty(XMLNode2.prototype, 'parentNode', {
          get: function () {
            return this.parent;
          },
        });
        Object.defineProperty(XMLNode2.prototype, 'childNodes', {
          get: function () {
            if (!this.childNodeList || !this.childNodeList.nodes) {
              this.childNodeList = new XMLNodeList(this.children);
            }
            return this.childNodeList;
          },
        });
        Object.defineProperty(XMLNode2.prototype, 'firstChild', {
          get: function () {
            return this.children[0] || null;
          },
        });
        Object.defineProperty(XMLNode2.prototype, 'lastChild', {
          get: function () {
            return this.children[this.children.length - 1] || null;
          },
        });
        Object.defineProperty(XMLNode2.prototype, 'previousSibling', {
          get: function () {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i - 1] || null;
          },
        });
        Object.defineProperty(XMLNode2.prototype, 'nextSibling', {
          get: function () {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i + 1] || null;
          },
        });
        Object.defineProperty(XMLNode2.prototype, 'ownerDocument', {
          get: function () {
            return this.document() || null;
          },
        });
        Object.defineProperty(XMLNode2.prototype, 'textContent', {
          get: function () {
            var child, j, len, ref2, str;
            if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
              str = '';
              ref2 = this.children;
              for (j = 0, len = ref2.length; j < len; j++) {
                child = ref2[j];
                if (child.textContent) {
                  str += child.textContent;
                }
              }
              return str;
            } else {
              return null;
            }
          },
          set: function (value) {
            throw new Error('This DOM method is not implemented.' + this.debugInfo());
          },
        });
        XMLNode2.prototype.setParent = function (parent) {
          var child, j, len, ref2, results;
          this.parent = parent;
          if (parent) {
            this.options = parent.options;
            this.stringify = parent.stringify;
          }
          ref2 = this.children;
          results = [];
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            results.push(child.setParent(this));
          }
          return results;
        };
        XMLNode2.prototype.element = function (name, attributes, text) {
          var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
          lastChild = null;
          if (attributes === null && text == null) {
            (ref2 = [{}, null]), (attributes = ref2[0]), (text = ref2[1]);
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            (ref3 = [attributes, text]), (text = ref3[0]), (attributes = ref3[1]);
          }
          if (name != null) {
            name = getValue(name);
          }
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              item = name[j];
              lastChild = this.element(item);
            }
          } else if (isFunction(name)) {
            lastChild = this.element(name.apply());
          } else if (isObject(name)) {
            for (key in name) {
              if (!hasProp.call(name, key)) continue;
              val = name[key];
              if (isFunction(val)) {
                val = val.apply();
              }
              if (
                !this.options.ignoreDecorators &&
                this.stringify.convertAttKey &&
                key.indexOf(this.stringify.convertAttKey) === 0
              ) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                lastChild = this.dummy();
              } else if (isObject(val) && isEmpty(val)) {
                lastChild = this.element(key);
              } else if (!this.options.keepNullNodes && val == null) {
                lastChild = this.dummy();
              } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                for (k = 0, len1 = val.length; k < len1; k++) {
                  item = val[k];
                  childNode = {};
                  childNode[key] = item;
                  lastChild = this.element(childNode);
                }
              } else if (isObject(val)) {
                if (
                  !this.options.ignoreDecorators &&
                  this.stringify.convertTextKey &&
                  key.indexOf(this.stringify.convertTextKey) === 0
                ) {
                  lastChild = this.element(val);
                } else {
                  lastChild = this.element(key);
                  lastChild.element(val);
                }
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else if (!this.options.keepNullNodes && text === null) {
            lastChild = this.dummy();
          } else {
            if (
              !this.options.ignoreDecorators &&
              this.stringify.convertTextKey &&
              name.indexOf(this.stringify.convertTextKey) === 0
            ) {
              lastChild = this.text(text);
            } else if (
              !this.options.ignoreDecorators &&
              this.stringify.convertCDataKey &&
              name.indexOf(this.stringify.convertCDataKey) === 0
            ) {
              lastChild = this.cdata(text);
            } else if (
              !this.options.ignoreDecorators &&
              this.stringify.convertCommentKey &&
              name.indexOf(this.stringify.convertCommentKey) === 0
            ) {
              lastChild = this.comment(text);
            } else if (
              !this.options.ignoreDecorators &&
              this.stringify.convertRawKey &&
              name.indexOf(this.stringify.convertRawKey) === 0
            ) {
              lastChild = this.raw(text);
            } else if (
              !this.options.ignoreDecorators &&
              this.stringify.convertPIKey &&
              name.indexOf(this.stringify.convertPIKey) === 0
            ) {
              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
            } else {
              lastChild = this.node(name, attributes, text);
            }
          }
          if (lastChild == null) {
            throw new Error('Could not create any elements with: ' + name + '. ' + this.debugInfo());
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function (name, attributes, text) {
          var child, i, newChild, refChild, removed;
          if (name != null ? name.type : void 0) {
            newChild = name;
            refChild = attributes;
            newChild.setParent(this);
            if (refChild) {
              i = children.indexOf(refChild);
              removed = children.splice(i);
              children.push(newChild);
              Array.prototype.push.apply(children, removed);
            } else {
              children.push(newChild);
            }
            return newChild;
          } else {
            if (this.isRoot) {
              throw new Error('Cannot insert elements at root level. ' + this.debugInfo(name));
            }
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.element(name, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          }
        };
        XMLNode2.prototype.insertAfter = function (name, attributes, text) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error('Cannot insert elements at root level. ' + this.debugInfo(name));
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function () {
          var i, ref2;
          if (this.isRoot) {
            throw new Error('Cannot remove the root element. ' + this.debugInfo());
          }
          i = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i, i - i + 1].concat((ref2 = []))), ref2;
          return this.parent;
        };
        XMLNode2.prototype.node = function (name, attributes, text) {
          var child, ref2;
          if (name != null) {
            name = getValue(name);
          }
          attributes || (attributes = {});
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            (ref2 = [attributes, text]), (text = ref2[0]), (attributes = ref2[1]);
          }
          child = new XMLElement(this, name, attributes);
          if (text != null) {
            child.text(text);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function (value) {
          var child;
          if (isObject(value)) {
            this.element(value);
          }
          child = new XMLText(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function (value) {
          var child;
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function (value) {
          var child;
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function (value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function (value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function (value) {
          var child;
          child = new XMLRaw(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.dummy = function () {
          var child;
          child = new XMLDummy(this);
          return child;
        };
        XMLNode2.prototype.instruction = function (target, value) {
          var insTarget, insValue, instruction, j, len;
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (j = 0, len = target.length; j < len; j++) {
              insTarget = target[j];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function (target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function (target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function (version, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version, encoding, standalone);
          if (doc.children.length === 0) {
            doc.children.unshift(xmldec);
          } else if (doc.children[0].type === NodeType.Declaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.dtd = function (pubID, sysID) {
          var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref2 = doc.children;
          for (i = j = 0, len = ref2.length; j < len; i = ++j) {
            child = ref2[i];
            if (child.type === NodeType.DocType) {
              doc.children[i] = doctype;
              return doctype;
            }
          }
          ref3 = doc.children;
          for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
            child = ref3[i];
            if (child.isRoot) {
              doc.children.splice(i, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function () {
          if (this.isRoot) {
            throw new Error('The root node has no parent. Use doc() if you need to get the document object.');
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function () {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function () {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function (options) {
          return this.document().end(options);
        };
        XMLNode2.prototype.prev = function () {
          var i;
          i = this.parent.children.indexOf(this);
          if (i < 1) {
            throw new Error('Already at the first node. ' + this.debugInfo());
          }
          return this.parent.children[i - 1];
        };
        XMLNode2.prototype.next = function () {
          var i;
          i = this.parent.children.indexOf(this);
          if (i === -1 || i === this.parent.children.length - 1) {
            throw new Error('Already at the last node. ' + this.debugInfo());
          }
          return this.parent.children[i + 1];
        };
        XMLNode2.prototype.importDocument = function (doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.debugInfo = function (name) {
          var ref2, ref3;
          name = name || this.name;
          if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
            return '';
          } else if (name == null) {
            return 'parent: <' + this.parent.name + '>';
          } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
            return 'node: <' + name + '>';
          } else {
            return 'node: <' + name + '>, parent: <' + this.parent.name + '>';
          }
        };
        XMLNode2.prototype.ele = function (name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.nod = function (name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.txt = function (value) {
          return this.text(value);
        };
        XMLNode2.prototype.dat = function (value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.com = function (value) {
          return this.comment(value);
        };
        XMLNode2.prototype.ins = function (target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.doc = function () {
          return this.document();
        };
        XMLNode2.prototype.dec = function (version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLNode2.prototype.e = function (name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.n = function (name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.t = function (value) {
          return this.text(value);
        };
        XMLNode2.prototype.d = function (value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.c = function (value) {
          return this.comment(value);
        };
        XMLNode2.prototype.r = function (value) {
          return this.raw(value);
        };
        XMLNode2.prototype.i = function (target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.u = function () {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function (doc) {
          return this.importDocument(doc);
        };
        XMLNode2.prototype.replaceChild = function (newChild, oldChild) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.removeChild = function (oldChild) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.appendChild = function (newChild) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.hasChildNodes = function () {
          return this.children.length !== 0;
        };
        XMLNode2.prototype.cloneNode = function (deep) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.normalize = function () {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.isSupported = function (feature, version) {
          return true;
        };
        XMLNode2.prototype.hasAttributes = function () {
          return this.attribs.length !== 0;
        };
        XMLNode2.prototype.compareDocumentPosition = function (other) {
          var ref, res;
          ref = this;
          if (ref === other) {
            return 0;
          } else if (this.document() !== other.document()) {
            res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
            if (Math.random() < 0.5) {
              res |= DocumentPosition.Preceding;
            } else {
              res |= DocumentPosition.Following;
            }
            return res;
          } else if (ref.isAncestor(other)) {
            return DocumentPosition.Contains | DocumentPosition.Preceding;
          } else if (ref.isDescendant(other)) {
            return DocumentPosition.Contains | DocumentPosition.Following;
          } else if (ref.isPreceding(other)) {
            return DocumentPosition.Preceding;
          } else {
            return DocumentPosition.Following;
          }
        };
        XMLNode2.prototype.isSameNode = function (other) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.lookupPrefix = function (namespaceURI) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.isDefaultNamespace = function (namespaceURI) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.lookupNamespaceURI = function (prefix) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.isEqualNode = function (node) {
          var i, j, ref2;
          if (node.nodeType !== this.nodeType) {
            return false;
          }
          if (node.children.length !== this.children.length) {
            return false;
          }
          for (
            i = j = 0, ref2 = this.children.length - 1;
            0 <= ref2 ? j <= ref2 : j >= ref2;
            i = 0 <= ref2 ? ++j : --j
          ) {
            if (!this.children[i].isEqualNode(node.children[i])) {
              return false;
            }
          }
          return true;
        };
        XMLNode2.prototype.getFeature = function (feature, version) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.setUserData = function (key, data, handler) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.getUserData = function (key) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLNode2.prototype.contains = function (other) {
          if (!other) {
            return false;
          }
          return other === this || this.isDescendant(other);
        };
        XMLNode2.prototype.isDescendant = function (node) {
          var child, isDescendantChild, j, len, ref2;
          ref2 = this.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (node === child) {
              return true;
            }
            isDescendantChild = child.isDescendant(node);
            if (isDescendantChild) {
              return true;
            }
          }
          return false;
        };
        XMLNode2.prototype.isAncestor = function (node) {
          return node.isDescendant(this);
        };
        XMLNode2.prototype.isPreceding = function (node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos < thisPos;
          }
        };
        XMLNode2.prototype.isFollowing = function (node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos > thisPos;
          }
        };
        XMLNode2.prototype.treePosition = function (node) {
          var found, pos;
          pos = 0;
          found = false;
          this.foreachTreeNode(this.document(), function (childNode) {
            pos++;
            if (!found && childNode === node) {
              return (found = true);
            }
          });
          if (found) {
            return pos;
          } else {
            return -1;
          }
        };
        XMLNode2.prototype.foreachTreeNode = function (node, func) {
          var child, j, len, ref2, res;
          node || (node = this.document());
          ref2 = node.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if ((res = func(child))) {
              return res;
            } else {
              res = this.foreachTreeNode(child, func);
              if (res) {
                return res;
              }
            }
          }
        };
        return XMLNode2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringifier.js'(exports, module2) {
    (function () {
      var XMLStringifier,
        bind = function (fn, me) {
          return function () {
            return fn.apply(me, arguments);
          };
        },
        hasProp = {}.hasOwnProperty;
      module2.exports = XMLStringifier = (function () {
        function XMLStringifier2(options) {
          this.assertLegalName = bind(this.assertLegalName, this);
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key, ref, value;
          options || (options = {});
          this.options = options;
          if (!this.options.version) {
            this.options.version = '1.0';
          }
          ref = options.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this[key] = value;
          }
        }
        XMLStringifier2.prototype.name = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalName('' + val || '');
        };
        XMLStringifier2.prototype.text = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.textEscape('' + val || ''));
        };
        XMLStringifier2.prototype.cdata = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          val = '' + val || '';
          val = val.replace(']]>', ']]]]><![CDATA[>');
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.comment = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          val = '' + val || '';
          if (val.match(/--/)) {
            throw new Error('Comment text cannot contain double-hypen: ' + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.raw = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return '' + val || '';
        };
        XMLStringifier2.prototype.attValue = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.attEscape((val = '' + val || '')));
        };
        XMLStringifier2.prototype.insTarget = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar('' + val || '');
        };
        XMLStringifier2.prototype.insValue = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          val = '' + val || '';
          if (val.match(/\?>/)) {
            throw new Error('Invalid processing instruction value: ' + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlVersion = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          val = '' + val || '';
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error('Invalid version number: ' + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlEncoding = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          val = '' + val || '';
          if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error('Invalid encoding: ' + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlStandalone = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          if (val) {
            return 'yes';
          } else {
            return 'no';
          }
        };
        XMLStringifier2.prototype.dtdPubID = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar('' + val || '');
        };
        XMLStringifier2.prototype.dtdSysID = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar('' + val || '');
        };
        XMLStringifier2.prototype.dtdElementValue = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar('' + val || '');
        };
        XMLStringifier2.prototype.dtdAttType = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar('' + val || '');
        };
        XMLStringifier2.prototype.dtdAttDefault = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar('' + val || '');
        };
        XMLStringifier2.prototype.dtdEntityValue = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar('' + val || '');
        };
        XMLStringifier2.prototype.dtdNData = function (val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar('' + val || '');
        };
        XMLStringifier2.prototype.convertAttKey = '@';
        XMLStringifier2.prototype.convertPIKey = '?';
        XMLStringifier2.prototype.convertTextKey = '#text';
        XMLStringifier2.prototype.convertCDataKey = '#cdata';
        XMLStringifier2.prototype.convertCommentKey = '#comment';
        XMLStringifier2.prototype.convertRawKey = '#raw';
        XMLStringifier2.prototype.assertLegalChar = function (str) {
          var regex, res;
          if (this.options.noValidation) {
            return str;
          }
          regex = '';
          if (this.options.version === '1.0') {
            regex =
              /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if ((res = str.match(regex))) {
              throw new Error('Invalid character in string: ' + str + ' at index ' + res.index);
            }
          } else if (this.options.version === '1.1') {
            regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if ((res = str.match(regex))) {
              throw new Error('Invalid character in string: ' + str + ' at index ' + res.index);
            }
          }
          return str;
        };
        XMLStringifier2.prototype.assertLegalName = function (str) {
          var regex;
          if (this.options.noValidation) {
            return str;
          }
          this.assertLegalChar(str);
          regex =
            /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
          if (!str.match(regex)) {
            throw new Error('Invalid character in name');
          }
          return str;
        };
        XMLStringifier2.prototype.textEscape = function (str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
        };
        XMLStringifier2.prototype.attEscape = function (str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str
            .replace(ampregex, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/"/g, '&quot;')
            .replace(/\t/g, '&#x9;')
            .replace(/\n/g, '&#xA;')
            .replace(/\r/g, '&#xD;');
        };
        return XMLStringifier2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/WriterState.js'(exports, module2) {
    (function () {
      module2.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3,
      };
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLWriterBase.js'(exports, module2) {
    (function () {
      var NodeType,
        WriterState,
        XMLCData,
        XMLComment,
        XMLDTDAttList,
        XMLDTDElement,
        XMLDTDEntity,
        XMLDTDNotation,
        XMLDeclaration,
        XMLDocType,
        XMLDummy,
        XMLElement,
        XMLProcessingInstruction,
        XMLRaw,
        XMLText,
        XMLWriterBase,
        assign,
        hasProp = {}.hasOwnProperty;
      assign = require_Utility().assign;
      NodeType = require_NodeType();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      WriterState = require_WriterState();
      module2.exports = XMLWriterBase = (function () {
        function XMLWriterBase2(options) {
          var key, ref, value;
          options || (options = {});
          this.options = options;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this['_' + key] = this[key];
            this[key] = value;
          }
        }
        XMLWriterBase2.prototype.filterOptions = function (options) {
          var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
          options || (options = {});
          options = assign({}, this.options, options);
          filteredOptions = {
            writer: this,
          };
          filteredOptions.pretty = options.pretty || false;
          filteredOptions.allowEmpty = options.allowEmpty || false;
          filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';
          filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\n';
          filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
          filteredOptions.dontPrettyTextNodes =
            (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null
              ? ref3
              : 0;
          filteredOptions.spaceBeforeSlash =
            (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';
          if (filteredOptions.spaceBeforeSlash === true) {
            filteredOptions.spaceBeforeSlash = ' ';
          }
          filteredOptions.suppressPrettyCount = 0;
          filteredOptions.user = {};
          filteredOptions.state = WriterState.None;
          return filteredOptions;
        };
        XMLWriterBase2.prototype.indent = function (node, options, level) {
          var indentLevel;
          if (!options.pretty || options.suppressPrettyCount) {
            return '';
          } else if (options.pretty) {
            indentLevel = (level || 0) + options.offset + 1;
            if (indentLevel > 0) {
              return new Array(indentLevel).join(options.indent);
            }
          }
          return '';
        };
        XMLWriterBase2.prototype.endline = function (node, options, level) {
          if (!options.pretty || options.suppressPrettyCount) {
            return '';
          } else {
            return options.newline;
          }
        };
        XMLWriterBase2.prototype.attribute = function (att, options, level) {
          var r;
          this.openAttribute(att, options, level);
          r = ' ' + att.name + '="' + att.value + '"';
          this.closeAttribute(att, options, level);
          return r;
        };
        XMLWriterBase2.prototype.cdata = function (node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + '<![CDATA[';
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += ']]>' + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.comment = function (node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + '<!-- ';
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += ' -->' + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.declaration = function (node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + '<?xml';
          options.state = WriterState.InsideTag;
          r += ' version="' + node.version + '"';
          if (node.encoding != null) {
            r += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r += ' standalone="' + node.standalone + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + '?>';
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.docType = function (node, options, level) {
          var child, i, len, r, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          r += '<!DOCTYPE ' + node.root().name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r += ' [';
            r += this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += ']';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + '>';
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.element = function (node, options, level) {
          var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
          level || (level = 0);
          prettySuppressed = false;
          r = '';
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r += this.indent(node, options, level) + '<' + node.name;
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name)) continue;
            att = ref[name];
            r += this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (
            childNodeCount === 0 ||
            node.children.every(function (e) {
              return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
            })
          ) {
            if (options.allowEmpty) {
              r += '>';
              options.state = WriterState.CloseTag;
              r += '</' + node.name + '>' + this.endline(node, options, level);
            } else {
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);
            }
          } else if (
            options.pretty &&
            childNodeCount === 1 &&
            (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) &&
            firstChildNode.value != null
          ) {
            r += '>';
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            r += this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            r += '</' + node.name + '>' + this.endline(node, options, level);
          } else {
            if (options.dontPrettyTextNodes) {
              ref1 = node.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                  options.suppressPrettyCount++;
                  prettySuppressed = true;
                  break;
                }
              }
            }
            r += '>' + this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref2 = node.children;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += this.indent(node, options, level) + '</' + node.name + '>';
            if (prettySuppressed) {
              options.suppressPrettyCount--;
            }
            r += this.endline(node, options, level);
            options.state = WriterState.None;
          }
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.writeChildNode = function (node, options, level) {
          switch (node.type) {
            case NodeType.CData:
              return this.cdata(node, options, level);
            case NodeType.Comment:
              return this.comment(node, options, level);
            case NodeType.Element:
              return this.element(node, options, level);
            case NodeType.Raw:
              return this.raw(node, options, level);
            case NodeType.Text:
              return this.text(node, options, level);
            case NodeType.ProcessingInstruction:
              return this.processingInstruction(node, options, level);
            case NodeType.Dummy:
              return '';
            case NodeType.Declaration:
              return this.declaration(node, options, level);
            case NodeType.DocType:
              return this.docType(node, options, level);
            case NodeType.AttributeDeclaration:
              return this.dtdAttList(node, options, level);
            case NodeType.ElementDeclaration:
              return this.dtdElement(node, options, level);
            case NodeType.EntityDeclaration:
              return this.dtdEntity(node, options, level);
            case NodeType.NotationDeclaration:
              return this.dtdNotation(node, options, level);
            default:
              throw new Error('Unknown XML node type: ' + node.constructor.name);
          }
        };
        XMLWriterBase2.prototype.processingInstruction = function (node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + '<?';
          options.state = WriterState.InsideTag;
          r += node.target;
          if (node.value) {
            r += ' ' + node.value;
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + '?>';
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.raw = function (node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.text = function (node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdAttList = function (node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + '<!ATTLIST';
          options.state = WriterState.InsideTag;
          r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
          if (node.defaultValueType !== '#DEFAULT') {
            r += ' ' + node.defaultValueType;
          }
          if (node.defaultValue) {
            r += ' "' + node.defaultValue + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdElement = function (node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + '<!ELEMENT';
          options.state = WriterState.InsideTag;
          r += ' ' + node.name + ' ' + node.value;
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdEntity = function (node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + '<!ENTITY';
          options.state = WriterState.InsideTag;
          if (node.pe) {
            r += ' %';
          }
          r += ' ' + node.name;
          if (node.value) {
            r += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r += ' NDATA ' + node.nData;
            }
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdNotation = function (node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + '<!NOTATION';
          options.state = WriterState.InsideTag;
          r += ' ' + node.name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.openNode = function (node, options, level) {};
        XMLWriterBase2.prototype.closeNode = function (node, options, level) {};
        XMLWriterBase2.prototype.openAttribute = function (att, options, level) {};
        XMLWriterBase2.prototype.closeAttribute = function (att, options, level) {};
        return XMLWriterBase2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringWriter.js'(exports, module2) {
    (function () {
      var XMLStringWriter,
        XMLWriterBase,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStringWriter = (function (superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options) {
          XMLStringWriter2.__super__.constructor.call(this, options);
        }
        XMLStringWriter2.prototype.document = function (doc, options) {
          var child, i, len, r, ref;
          options = this.filterOptions(options);
          r = '';
          ref = doc.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            r += this.writeChildNode(child, options, 0);
          }
          if (options.pretty && r.slice(-options.newline.length) === options.newline) {
            r = r.slice(0, -options.newline.length);
          }
          return r;
        };
        return XMLStringWriter2;
      })(XMLWriterBase);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocument.js'(exports, module2) {
    (function () {
      var NodeType,
        XMLDOMConfiguration,
        XMLDOMImplementation,
        XMLDocument,
        XMLNode,
        XMLStringWriter,
        XMLStringifier,
        isPlainObject,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDOMConfiguration = require_XMLDOMConfiguration();
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocument = (function (superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options) {
          XMLDocument2.__super__.constructor.call(this, null);
          this.name = '#document';
          this.type = NodeType.Document;
          this.documentURI = null;
          this.domConfig = new XMLDOMConfiguration();
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
        }
        Object.defineProperty(XMLDocument2.prototype, 'implementation', {
          value: new XMLDOMImplementation(),
        });
        Object.defineProperty(XMLDocument2.prototype, 'doctype', {
          get: function () {
            var child, i, len, ref;
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.DocType) {
                return child;
              }
            }
            return null;
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'documentElement', {
          get: function () {
            return this.rootObject || null;
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'inputEncoding', {
          get: function () {
            return null;
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'strictErrorChecking', {
          get: function () {
            return false;
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'xmlEncoding', {
          get: function () {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].encoding;
            } else {
              return null;
            }
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'xmlStandalone', {
          get: function () {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].standalone === 'yes';
            } else {
              return false;
            }
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'xmlVersion', {
          get: function () {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].version;
            } else {
              return '1.0';
            }
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'URL', {
          get: function () {
            return this.documentURI;
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'origin', {
          get: function () {
            return null;
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'compatMode', {
          get: function () {
            return null;
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'characterSet', {
          get: function () {
            return null;
          },
        });
        Object.defineProperty(XMLDocument2.prototype, 'contentType', {
          get: function () {
            return null;
          },
        });
        XMLDocument2.prototype.end = function (writer) {
          var writerOptions;
          writerOptions = {};
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer;
          }
          return writer.document(this, writer.filterOptions(writerOptions));
        };
        XMLDocument2.prototype.toString = function (options) {
          return this.options.writer.document(this, this.options.writer.filterOptions(options));
        };
        XMLDocument2.prototype.createElement = function (tagName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createDocumentFragment = function () {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createTextNode = function (data) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createComment = function (data) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createCDATASection = function (data) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createProcessingInstruction = function (target, data) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createAttribute = function (name) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createEntityReference = function (name) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagName = function (tagname) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.importNode = function (importedNode, deep) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createElementNS = function (namespaceURI, qualifiedName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createAttributeNS = function (namespaceURI, qualifiedName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.getElementById = function (elementId) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.adoptNode = function (source) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.normalizeDocument = function () {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.renameNode = function (node, namespaceURI, qualifiedName) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByClassName = function (classNames) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createEvent = function (eventInterface) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createRange = function () {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createNodeIterator = function (root, whatToShow, filter) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        XMLDocument2.prototype.createTreeWalker = function (root, whatToShow, filter) {
          throw new Error('This DOM method is not implemented.' + this.debugInfo());
        };
        return XMLDocument2;
      })(XMLNode);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocumentCB.js'(exports, module2) {
    (function () {
      var NodeType,
        WriterState,
        XMLAttribute,
        XMLCData,
        XMLComment,
        XMLDTDAttList,
        XMLDTDElement,
        XMLDTDEntity,
        XMLDTDNotation,
        XMLDeclaration,
        XMLDocType,
        XMLDocument,
        XMLDocumentCB,
        XMLElement,
        XMLProcessingInstruction,
        XMLRaw,
        XMLStringWriter,
        XMLStringifier,
        XMLText,
        getValue,
        isFunction,
        isObject,
        isPlainObject,
        ref,
        hasProp = {}.hasOwnProperty;
      (ref = require_Utility()),
        (isObject = ref.isObject),
        (isFunction = ref.isFunction),
        (isPlainObject = ref.isPlainObject),
        (getValue = ref.getValue);
      NodeType = require_NodeType();
      XMLDocument = require_XMLDocument();
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      WriterState = require_WriterState();
      module2.exports = XMLDocumentCB = (function () {
        function XMLDocumentCB2(options, onData, onEnd) {
          var writerOptions;
          this.name = '?xml';
          this.type = NodeType.Document;
          options || (options = {});
          writerOptions = {};
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.writer = options.writer;
          this.writerOptions = this.writer.filterOptions(writerOptions);
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function () {};
          this.onEndCallback = onEnd || function () {};
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        XMLDocumentCB2.prototype.createChildNode = function (node) {
          var att, attName, attributes, child, i, len, ref1, ref2;
          switch (node.type) {
            case NodeType.CData:
              this.cdata(node.value);
              break;
            case NodeType.Comment:
              this.comment(node.value);
              break;
            case NodeType.Element:
              attributes = {};
              ref1 = node.attribs;
              for (attName in ref1) {
                if (!hasProp.call(ref1, attName)) continue;
                att = ref1[attName];
                attributes[attName] = att.value;
              }
              this.node(node.name, attributes);
              break;
            case NodeType.Dummy:
              this.dummy();
              break;
            case NodeType.Raw:
              this.raw(node.value);
              break;
            case NodeType.Text:
              this.text(node.value);
              break;
            case NodeType.ProcessingInstruction:
              this.instruction(node.target, node.value);
              break;
            default:
              throw new Error('This XML node type is not supported in a JS object: ' + node.constructor.name);
          }
          ref2 = node.children;
          for (i = 0, len = ref2.length; i < len; i++) {
            child = ref2[i];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.dummy = function () {
          return this;
        };
        XMLDocumentCB2.prototype.node = function (name, attributes, text) {
          var ref1;
          if (name == null) {
            throw new Error('Missing node name.');
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error('Document can only have one root node. ' + this.debugInfo(name));
          }
          this.openCurrent();
          name = getValue(name);
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            (ref1 = [attributes, text]), (text = ref1[0]), (attributes = ref1[1]);
          }
          this.currentNode = new XMLElement(this, name, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function (name, attributes, text) {
          var child, i, len, oldValidationFlag, ref1, root;
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            this.dtdElement.apply(this, arguments);
          } else {
            if (Array.isArray(name) || isObject(name) || isFunction(name)) {
              oldValidationFlag = this.options.noValidation;
              this.options.noValidation = true;
              root = new XMLDocument(this.options).element('TEMP_ROOT');
              root.element(name);
              this.options.noValidation = oldValidationFlag;
              ref1 = root.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
            } else {
              this.node(name, attributes, text);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.attribute = function (name, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error(
              'att() can only be used immediately after an ele() call in callback mode. ' + this.debugInfo(name)
            );
          }
          if (name != null) {
            name = getValue(name);
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName)) continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, '');
            } else if (value != null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function (value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function (value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.comment = function (value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.raw = function (value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function (target, value) {
          var i, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (i = 0, len = target.length; i < len; i++) {
              insTarget = target[i];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(
              this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1),
              this.currentLevel + 1
            );
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function (version, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error('declaration() must be the first node.');
          }
          node = new XMLDeclaration(this, version, encoding, standalone);
          this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function (root, pubID, sysID) {
          this.openCurrent();
          if (root == null) {
            throw new Error('Missing root node name.');
          }
          if (this.root) {
            throw new Error('dtd() must come before the root node.');
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function (name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value);
          this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.attList = function (
          elementName,
          attributeName,
          attributeType,
          defaultValueType,
          defaultValue
        ) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.entity = function (name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function (name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.notation = function (name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value);
          this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.up = function () {
          if (this.currentLevel < 0) {
            throw new Error('The document node has no parent.');
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function () {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function () {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function (node) {
          var att, chunk, name, ref1;
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
              this.root = node;
            }
            chunk = '';
            if (node.type === NodeType.Element) {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;
              ref1 = node.attribs;
              for (name in ref1) {
                if (!hasProp.call(ref1, name)) continue;
                att = ref1[name];
                chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
              }
              chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.OpenTag;
              chunk =
                this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;
              if (node.pubID && node.sysID) {
                chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                chunk += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.children) {
                chunk += ' [';
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.CloseTag;
                chunk += '>';
              }
              chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.onData(chunk, this.currentLevel);
            return (node.isOpen = true);
          }
        };
        XMLDocumentCB2.prototype.closeNode = function (node) {
          var chunk;
          if (!node.isClosed) {
            chunk = '';
            this.writerOptions.state = WriterState.CloseTag;
            if (node.type === NodeType.Element) {
              chunk =
                this.writer.indent(node, this.writerOptions, this.currentLevel) +
                '</' +
                node.name +
                '>' +
                this.writer.endline(node, this.writerOptions, this.currentLevel);
            } else {
              chunk =
                this.writer.indent(node, this.writerOptions, this.currentLevel) +
                ']>' +
                this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.writerOptions.state = WriterState.None;
            this.onData(chunk, this.currentLevel);
            return (node.isClosed = true);
          }
        };
        XMLDocumentCB2.prototype.onData = function (chunk, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk, level + 1);
        };
        XMLDocumentCB2.prototype.onEnd = function () {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.debugInfo = function (name) {
          if (name == null) {
            return '';
          } else {
            return 'node: <' + name + '>';
          }
        };
        XMLDocumentCB2.prototype.ele = function () {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function (name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.txt = function (value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.dat = function (value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.com = function (value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.ins = function (target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.dec = function (version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function (root, pubID, sysID) {
          return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function (name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLDocumentCB2.prototype.n = function (name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.t = function (value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.d = function (value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.c = function (value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.r = function (value) {
          return this.raw(value);
        };
        XMLDocumentCB2.prototype.i = function (target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.att = function () {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function () {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function (name, value) {
          return this.entity(name, value);
        };
        XMLDocumentCB2.prototype.pent = function (name, value) {
          return this.pEntity(name, value);
        };
        XMLDocumentCB2.prototype.not = function (name, value) {
          return this.notation(name, value);
        };
        return XMLDocumentCB2;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStreamWriter.js'(exports, module2) {
    (function () {
      var NodeType,
        WriterState,
        XMLStreamWriter,
        XMLWriterBase,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLWriterBase = require_XMLWriterBase();
      WriterState = require_WriterState();
      module2.exports = XMLStreamWriter = (function (superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream, options) {
          this.stream = stream;
          XMLStreamWriter2.__super__.constructor.call(this, options);
        }
        XMLStreamWriter2.prototype.endline = function (node, options, level) {
          if (node.isLastRootNode && options.state === WriterState.CloseTag) {
            return '';
          } else {
            return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
          }
        };
        XMLStreamWriter2.prototype.document = function (doc, options) {
          var child, i, j, k, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            child = ref[i];
            child.isLastRootNode = i === doc.children.length - 1;
          }
          options = this.filterOptions(options);
          ref1 = doc.children;
          results = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            child = ref1[k];
            results.push(this.writeChildNode(child, options, 0));
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function (att, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
        };
        XMLStreamWriter2.prototype.cdata = function (node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.comment = function (node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.declaration = function (node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.docType = function (node, options, level) {
          var child, j, len, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level));
          this.stream.write('<!DOCTYPE ' + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(' [');
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (j = 0, len = ref.length; j < len; j++) {
              child = ref[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write(']');
          }
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + '>');
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.element = function (node, options, level) {
          var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level) + '<' + node.name);
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name)) continue;
            att = ref[name];
            this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (
            childNodeCount === 0 ||
            node.children.every(function (e) {
              return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
            })
          ) {
            if (options.allowEmpty) {
              this.stream.write('>');
              options.state = WriterState.CloseTag;
              this.stream.write('</' + node.name + '>');
            } else {
              options.state = WriterState.CloseTag;
              this.stream.write(options.spaceBeforeSlash + '/>');
            }
          } else if (
            options.pretty &&
            childNodeCount === 1 &&
            (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) &&
            firstChildNode.value != null
          ) {
            this.stream.write('>');
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            this.stream.write('</' + node.name + '>');
          } else {
            this.stream.write('>' + this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref1 = node.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');
          }
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.processingInstruction = function (node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.raw = function (node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.text = function (node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdAttList = function (node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdElement = function (node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdEntity = function (node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdNotation = function (node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
        };
        return XMLStreamWriter2;
      })(XMLWriterBase);
    }.call(exports));
  },
});

// node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/index.js
var require_lib = __commonJS({
  'node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/index.js'(exports, module2) {
    (function () {
      var NodeType,
        WriterState,
        XMLDOMImplementation,
        XMLDocument,
        XMLDocumentCB,
        XMLStreamWriter,
        XMLStringWriter,
        assign,
        isFunction,
        ref;
      (ref = require_Utility()), (assign = ref.assign), (isFunction = ref.isFunction);
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      NodeType = require_NodeType();
      WriterState = require_WriterState();
      module2.exports.create = function (name, xmldec, doctype, options) {
        var doc, root;
        if (name == null) {
          throw new Error('Root element needs a name.');
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.dtd(options);
          }
        }
        return root;
      };
      module2.exports.begin = function (options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
          (ref1 = [options, onData]), (onData = ref1[0]), (onEnd = ref1[1]);
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module2.exports.stringWriter = function (options) {
        return new XMLStringWriter(options);
      };
      module2.exports.streamWriter = function (stream, options) {
        return new XMLStreamWriter(stream, options);
      };
      module2.exports.implementation = new XMLDOMImplementation();
      module2.exports.nodeType = NodeType;
      module2.exports.writerState = WriterState;
    }.call(exports));
  },
});

// node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/builder.js
var require_builder3 = __commonJS({
  'node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/builder.js'(exports) {
    (function () {
      'use strict';
      var builder,
        defaults,
        escapeCDATA,
        requiresCDATA,
        wrapCDATA,
        hasProp = {}.hasOwnProperty;
      builder = require_lib();
      defaults = require_defaults().defaults;
      requiresCDATA = function (entry) {
        return (
          typeof entry === 'string' && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0)
        );
      };
      wrapCDATA = function (entry) {
        return '<![CDATA[' + escapeCDATA(entry) + ']]>';
      };
      escapeCDATA = function (entry) {
        return entry.replace(']]>', ']]]]><![CDATA[>');
      };
      exports.Builder = (function () {
        function Builder(opts) {
          var key, ref, value;
          this.options = {};
          ref = defaults['0.2'];
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key)) continue;
            value = opts[key];
            this.options[key] = value;
          }
        }
        Builder.prototype.buildObject = function (rootObj) {
          var attrkey, charkey, render, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults['0.2'].rootName) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render = (function (_this) {
            return function (element, obj) {
              var attr, child, entry, index, key, value;
              if (typeof obj !== 'object') {
                if (_this.options.cdata && requiresCDATA(obj)) {
                  element.raw(wrapCDATA(obj));
                } else {
                  element.txt(obj);
                }
              } else if (Array.isArray(obj)) {
                for (index in obj) {
                  if (!hasProp.call(obj, index)) continue;
                  child = obj[index];
                  for (key in child) {
                    entry = child[key];
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else {
                for (key in obj) {
                  if (!hasProp.call(obj, key)) continue;
                  child = obj[key];
                  if (key === attrkey) {
                    if (typeof child === 'object') {
                      for (attr in child) {
                        value = child[attr];
                        element = element.att(attr, value);
                      }
                    }
                  } else if (key === charkey) {
                    if (_this.options.cdata && requiresCDATA(child)) {
                      element = element.raw(wrapCDATA(child));
                    } else {
                      element = element.txt(child);
                    }
                  } else if (Array.isArray(child)) {
                    for (index in child) {
                      if (!hasProp.call(child, index)) continue;
                      entry = child[index];
                      if (typeof entry === 'string') {
                        if (_this.options.cdata && requiresCDATA(entry)) {
                          element = element.ele(key).raw(wrapCDATA(entry)).up();
                        } else {
                          element = element.ele(key, entry).up();
                        }
                      } else {
                        element = render(element.ele(key), entry).up();
                      }
                    }
                  } else if (typeof child === 'object') {
                    element = render(element.ele(key), child).up();
                  } else {
                    if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                      element = element.ele(key).raw(wrapCDATA(child)).up();
                    } else {
                      if (child == null) {
                        child = '';
                      }
                      element = element.ele(key, child.toString()).up();
                    }
                  }
                }
              }
              return element;
            };
          })(this);
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars,
          });
          return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
      })();
    }.call(exports));
  },
});

// node_modules/.pnpm/sax@1.2.1/node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  'node_modules/.pnpm/sax@1.2.1/node_modules/sax/lib/sax.js'(exports) {
    (function (sax) {
      sax.parser = function (strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        'comment',
        'sgmlDecl',
        'textNode',
        'tagName',
        'doctype',
        'procInstName',
        'procInstBody',
        'entity',
        'attribName',
        'attribValue',
        'cdata',
        'script',
      ];
      sax.EVENTS = [
        'text',
        'processinginstruction',
        'sgmldeclaration',
        'doctype',
        'comment',
        'opentagstart',
        'attribute',
        'opentag',
        'closetag',
        'opencdata',
        'cdata',
        'closecdata',
        'error',
        'end',
        'ready',
        'script',
        'opennamespace',
        'closenamespace',
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = '';
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, 'onready');
      }
      if (!Object.create) {
        Object.create = function (o) {
          function F() {}
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function (o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case 'textNode':
                closeText(parser);
                break;
              case 'cdata':
                emitNode(parser, 'oncdata', parser.cdata);
                parser.cdata = '';
                break;
              case 'script':
                emitNode(parser, 'onscript', parser.script);
                parser.script = '';
                break;
              default:
                error(parser, 'Max buffer length exceeded: ' + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = '';
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== '') {
          emitNode(parser, 'oncdata', parser.cdata);
          parser.cdata = '';
        }
        if (parser.script !== '') {
          emitNode(parser, 'onscript', parser.script);
          parser.script = '';
        }
      }
      SAXParser.prototype = {
        end: function () {
          end(this);
        },
        write,
        resume: function () {
          this.error = null;
          return this;
        },
        close: function () {
          return this.write(null);
        },
        flush: function () {
          flushBuffers(this);
        },
      };
      var Stream;
      try {
        Stream = require('stream').Stream;
      } catch (ex) {
        Stream = function () {};
      }
      var streamWraps = sax.EVENTS.filter(function (ev) {
        return ev !== 'error' && ev !== 'end';
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function () {
          me.emit('end');
        };
        this._parser.onerror = function (er) {
          me.emit('error', er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function (ev) {
          Object.defineProperty(me, 'on' + ev, {
            get: function () {
              return me._parser['on' + ev];
            },
            set: function (h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser['on' + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false,
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream,
        },
      });
      SAXStream.prototype.write = function (data) {
        if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require('string_decoder').StringDecoder;
            this._decoder = new SD('utf8');
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit('data', data);
        return true;
      };
      SAXStream.prototype.end = function (chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function (ev, handler) {
        var me = this;
        if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser['on' + ev] = function () {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var whitespace = '\r\n	 ';
      var number = '0124356789';
      var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
      var quote = `'"`;
      var attribEnd = whitespace + '>';
      var CDATA = '[CDATA[';
      var DOCTYPE = 'DOCTYPE';
      var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
      var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      whitespace = charClass(whitespace);
      number = charClass(number);
      letter = charClass(letter);
      var nameStart =
        /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody =
        /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
      var entityStart =
        /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody =
        /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
      quote = charClass(quote);
      attribEnd = charClass(attribEnd);
      function charClass(str) {
        return str.split('').reduce(function (s2, c) {
          s2[c] = true;
          return s2;
        }, {});
      }
      function isRegExp(c) {
        return Object.prototype.toString.call(c) === '[object RegExp]';
      }
      function is(charclass, c) {
        return isRegExp(charclass) ? !!c.match(charclass) : charclass[c];
      }
      function not(charclass, c) {
        return !is(charclass, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++,
      };
      sax.XML_ENTITIES = {
        amp: '&',
        gt: '>',
        lt: '<',
        quot: '"',
        apos: "'",
      };
      sax.ENTITIES = {
        amp: '&',
        gt: '>',
        lt: '<',
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830,
      };
      Object.keys(sax.ENTITIES).forEach(function (key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === 'number' ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, 'ontext', parser.textNode);
        parser.textNode = '';
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, ' ');
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, 'onerror', er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, 'Unexpected end');
        }
        closeText(parser);
        parser.c = '';
        parser.closed = true;
        emit(parser, 'onend');
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
          throw new Error('bad call to strictFail');
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = (parser.tag = { name: parser.tagName, attributes: {} });
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, 'onopentagstart', tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(':');
        var qualName = i < 0 ? ['', name] : name.split(':');
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === 'xmlns') {
          prefix = 'xmlns';
          local = '';
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (
          parser.attribList.indexOf(parser.attribName) !== -1 ||
          parser.tag.attributes.hasOwnProperty(parser.attribName)
        ) {
          parser.attribName = parser.attribValue = '';
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === 'xmlns') {
            if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
              strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\nActual: ' + parser.attribValue);
            } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\nActual: ' + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, 'onattribute', {
            name: parser.attribName,
            value: parser.attribValue,
          });
        }
        parser.attribName = parser.attribValue = '';
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || '';
          if (tag.prefix && !tag.uri) {
            strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function (p) {
              emitNode(parser, 'onopennamespace', {
                prefix: p,
                uri: tag.ns[p],
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === '' ? '' : tag.ns[prefix] || '';
            var a = {
              name,
              value,
              prefix,
              local,
              uri,
            };
            if (prefix && prefix !== 'xmlns' && !uri) {
              strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, 'onattribute', a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, 'onopentag', parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = '';
        }
        parser.attribName = parser.attribValue = '';
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, 'Weird empty close tag.');
          parser.textNode += '</>';
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== 'script') {
            parser.script += '</' + parser.tagName + '>';
            parser.tagName = '';
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, 'onscript', parser.script);
          parser.script = '';
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, 'Unexpected close tag');
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
          parser.textNode += '</' + parser.tagName + '>';
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = (parser.tag = parser.tags.pop());
          parser.tagName = parser.tag.name;
          emitNode(parser, 'onclosetag', parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function (p) {
              var n = tag.ns[p];
              emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = '';
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = '';
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === '#') {
          if (entity.charAt(1) === 'x') {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, '');
        if (numStr.toLowerCase() !== entity) {
          strictFail(parser, 'Invalid character entity');
          return '&' + parser.entity + ';';
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === '<') {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (not(whitespace, c)) {
          strictFail(parser, 'Non-whitespace before first tag.');
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = '';
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(parser, 'Cannot write after close. Assign an onready handler.');
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === 'object') {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = '';
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === '\n') {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === '\uFEFF') {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== '<' && c !== '&') {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === '\n') {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, 'Text data outside of root node.');
                }
                if (c === '&') {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === '<') {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === '/') {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += '<' + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === '!') {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = '';
              } else if (is(whitespace, c)) {
              } else if (is(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === '/') {
                parser.state = S.CLOSE_TAG;
                parser.tagName = '';
              } else if (c === '?') {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = '';
              } else {
                strictFail(parser, 'Unencoded <');
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(' ') + c;
                }
                parser.textNode += '<' + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, 'onopencdata');
                parser.state = S.CDATA;
                parser.sgmlDecl = '';
                parser.cdata = '';
              } else if (parser.sgmlDecl + c === '--') {
                parser.state = S.COMMENT;
                parser.comment = '';
                parser.sgmlDecl = '';
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(parser, 'Inappropriately located doctype declaration');
                }
                parser.doctype = '';
                parser.sgmlDecl = '';
              } else if (c === '>') {
                emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                parser.sgmlDecl = '';
                parser.state = S.TEXT;
              } else if (is(quote, c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = '';
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === '>') {
                parser.state = S.TEXT;
                emitNode(parser, 'ondoctype', parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === '[') {
                  parser.state = S.DOCTYPE_DTD;
                } else if (is(quote, c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = '';
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === ']') {
                parser.state = S.DOCTYPE;
              } else if (is(quote, c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = '';
              }
              continue;
            case S.COMMENT:
              if (c === '-') {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === '-') {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, 'oncomment', parser.comment);
                }
                parser.comment = '';
              } else {
                parser.comment += '-' + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== '>') {
                strictFail(parser, 'Malformed comment');
                parser.comment += '--' + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === ']') {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === ']') {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += ']' + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === '>') {
                if (parser.cdata) {
                  emitNode(parser, 'oncdata', parser.cdata);
                }
                emitNode(parser, 'onclosecdata');
                parser.cdata = '';
                parser.state = S.TEXT;
              } else if (c === ']') {
                parser.cdata += ']';
              } else {
                parser.cdata += ']]' + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === '?') {
                parser.state = S.PROC_INST_ENDING;
              } else if (is(whitespace, c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && is(whitespace, c)) {
                continue;
              } else if (c === '?') {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === '>') {
                emitNode(parser, 'onprocessinginstruction', {
                  name: parser.procInstName,
                  body: parser.procInstBody,
                });
                parser.procInstName = parser.procInstBody = '';
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += '?' + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (is(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === '>') {
                  openTag(parser);
                } else if (c === '/') {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (not(whitespace, c)) {
                    strictFail(parser, 'Invalid character in tag name');
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === '>') {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, 'Forward-slash in opening tag not followed by >');
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (is(whitespace, c)) {
                continue;
              } else if (c === '>') {
                openTag(parser);
              } else if (c === '/') {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (is(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = '';
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, 'Invalid attribute name');
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === '=') {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === '>') {
                strictFail(parser, 'Attribute without value');
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (is(whitespace, c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (is(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, 'Invalid attribute name');
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === '=') {
                parser.state = S.ATTRIB_VALUE;
              } else if (is(whitespace, c)) {
                continue;
              } else {
                strictFail(parser, 'Attribute without value');
                parser.tag.attributes[parser.attribName] = '';
                parser.attribValue = '';
                emitNode(parser, 'onattribute', {
                  name: parser.attribName,
                  value: '',
                });
                parser.attribName = '';
                if (c === '>') {
                  openTag(parser);
                } else if (is(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, 'Invalid attribute name');
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (is(whitespace, c)) {
                continue;
              } else if (is(quote, c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, 'Unquoted attribute value');
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === '&') {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = '';
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (is(whitespace, c)) {
                parser.state = S.ATTRIB;
              } else if (c === '>') {
                openTag(parser);
              } else if (c === '/') {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (is(nameStart, c)) {
                strictFail(parser, 'No whitespace between attributes');
                parser.attribName = c;
                parser.attribValue = '';
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, 'Invalid attribute name');
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (not(attribEnd, c)) {
                if (c === '&') {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === '>') {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (is(whitespace, c)) {
                  continue;
                } else if (not(nameStart, c)) {
                  if (parser.script) {
                    parser.script += '</' + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, 'Invalid tagname in closing tag.');
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === '>') {
                closeTag(parser);
              } else if (is(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += '</' + parser.tagName;
                parser.tagName = '';
                parser.state = S.SCRIPT;
              } else {
                if (not(whitespace, c)) {
                  strictFail(parser, 'Invalid tagname in closing tag');
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (is(whitespace, c)) {
                continue;
              }
              if (c === '>') {
                closeTag(parser);
              } else {
                strictFail(parser, 'Invalid characters in closing tag');
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = 'textNode';
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = 'attribValue';
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = 'attribValue';
                  break;
              }
              if (c === ';') {
                parser[buffer] += parseEntity(parser);
                parser.entity = '';
                parser.state = returnState;
              } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, 'Invalid character in entity name');
                parser[buffer] += '&' + parser.entity + c;
                parser.entity = '';
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, 'Unknown state: ' + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function () {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function () {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return '';
            }
            var result = '';
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
                throw RangeError('Invalid code point: ' + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = (codePoint % 1024) + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, 'fromCodePoint', {
              value: fromCodePoint,
              configurable: true,
              writable: true,
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === 'undefined' ? (exports.sax = {}) : exports);
  },
});

// node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/bom.js
var require_bom = __commonJS({
  'node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/bom.js'(exports) {
    (function () {
      'use strict';
      exports.stripBOM = function (str) {
        if (str[0] === '\uFEFF') {
          return str.substring(1);
        } else {
          return str;
        }
      };
    }.call(exports));
  },
});

// node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/processors.js
var require_processors = __commonJS({
  'node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/processors.js'(exports) {
    (function () {
      'use strict';
      var prefixMatch;
      prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      exports.normalize = function (str) {
        return str.toLowerCase();
      };
      exports.firstCharLowerCase = function (str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
      };
      exports.stripPrefix = function (str) {
        return str.replace(prefixMatch, '');
      };
      exports.parseNumbers = function (str) {
        if (!isNaN(str)) {
          str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
      };
      exports.parseBooleans = function (str) {
        if (/^(?:true|false)$/i.test(str)) {
          str = str.toLowerCase() === 'true';
        }
        return str;
      };
    }.call(exports));
  },
});

// node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/parser.js
var require_parser2 = __commonJS({
  'node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/parser.js'(exports) {
    (function () {
      'use strict';
      var bom,
        defaults,
        events,
        isEmpty,
        processItem,
        processors,
        sax,
        setImmediate2,
        bind = function (fn, me) {
          return function () {
            return fn.apply(me, arguments);
          };
        },
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      sax = require_sax();
      events = require('events');
      bom = require_bom();
      processors = require_processors();
      setImmediate2 = require('timers').setImmediate;
      defaults = require_defaults().defaults;
      isEmpty = function (thing) {
        return typeof thing === 'object' && thing != null && Object.keys(thing).length === 0;
      };
      processItem = function (processors2, item, key) {
        var i, len, process2;
        for (i = 0, len = processors2.length; i < len; i++) {
          process2 = processors2[i];
          item = process2(item, key);
        }
        return item;
      };
      exports.Parser = (function (superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
          this.parseStringPromise = bind(this.parseStringPromise, this);
          this.parseString = bind(this.parseString, this);
          this.reset = bind(this.reset, this);
          this.assignOrPush = bind(this.assignOrPush, this);
          this.processAsync = bind(this.processAsync, this);
          var key, ref, value;
          if (!(this instanceof exports.Parser)) {
            return new exports.Parser(opts);
          }
          this.options = {};
          ref = defaults['0.2'];
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key)) continue;
            value = opts[key];
            this.options[key] = value;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + 'ns';
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
        Parser.prototype.processAsync = function () {
          var chunk, err;
          try {
            if (this.remaining.length <= this.options.chunkSize) {
              chunk = this.remaining;
              this.remaining = '';
              this.saxParser = this.saxParser.write(chunk);
              return this.saxParser.close();
            } else {
              chunk = this.remaining.substr(0, this.options.chunkSize);
              this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
              this.saxParser = this.saxParser.write(chunk);
              return setImmediate2(this.processAsync);
            }
          } catch (error1) {
            err = error1;
            if (!this.saxParser.errThrown) {
              this.saxParser.errThrown = true;
              return this.emit(err);
            }
          }
        };
        Parser.prototype.assignOrPush = function (obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return (obj[key] = newValue);
            } else {
              return (obj[key] = [newValue]);
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
        Parser.prototype.reset = function () {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns,
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = (function (_this) {
            return function (error) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit('error', error);
              }
            };
          })(this);
          this.saxParser.onend = (function (_this) {
            return function () {
              if (!_this.saxParser.ended) {
                _this.saxParser.ended = true;
                return _this.emit('end', _this.resultObject);
              }
            };
          })(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = (function (_this) {
            return function (node) {
              var key, newValue, obj, processedKey, ref;
              obj = /* @__PURE__ */ Object.create(null);
              obj[charkey] = '';
              if (!_this.options.ignoreAttrs) {
                ref = node.attributes;
                for (key in ref) {
                  if (!hasProp.call(ref, key)) continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = /* @__PURE__ */ Object.create(null);
                  }
                  newValue = _this.options.attrValueProcessors
                    ? processItem(_this.options.attrValueProcessors, node.attributes[key], key)
                    : node.attributes[key];
                  processedKey = _this.options.attrNameProcessors
                    ? processItem(_this.options.attrNameProcessors, key)
                    : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj['#name'] = _this.options.tagNameProcessors
                ? processItem(_this.options.tagNameProcessors, node.name)
                : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local,
                };
              }
              return stack.push(obj);
            };
          })(this);
          this.saxParser.onclosetag = (function (_this) {
            return function () {
              var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
              obj = stack.pop();
              nodeName = obj['#name'];
              if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                delete obj['#name'];
              }
              if (obj.cdata === true) {
                cdata = obj.cdata;
                delete obj.cdata;
              }
              s = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, ' ').trim();
                }
                obj[charkey] = _this.options.valueProcessors
                  ? processItem(_this.options.valueProcessors, obj[charkey], nodeName)
                  : obj[charkey];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                if (typeof _this.options.emptyTag === 'function') {
                  obj = _this.options.emptyTag();
                } else {
                  obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
                }
              }
              if (_this.options.validator != null) {
                xpath =
                  '/' +
                  (function () {
                    var i, len, results;
                    results = [];
                    for (i = 0, len = stack.length; i < len; i++) {
                      node = stack[i];
                      results.push(node['#name']);
                    }
                    return results;
                  })()
                    .concat(nodeName)
                    .join('/');
                (function () {
                  var err;
                  try {
                    return (obj = _this.options.validator(xpath, s && s[nodeName], obj));
                  } catch (error1) {
                    err = error1;
                    return _this.emit('error', err);
                  }
                })();
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                if (!_this.options.preserveChildrenOrder) {
                  node = /* @__PURE__ */ Object.create(null);
                  if (_this.options.attrkey in obj) {
                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                    delete obj[_this.options.attrkey];
                  }
                  if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                    node[_this.options.charkey] = obj[_this.options.charkey];
                    delete obj[_this.options.charkey];
                  }
                  if (Object.getOwnPropertyNames(obj).length > 0) {
                    node[_this.options.childkey] = obj;
                  }
                  obj = node;
                } else if (s) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  objClone = /* @__PURE__ */ Object.create(null);
                  for (key in obj) {
                    if (!hasProp.call(obj, key)) continue;
                    objClone[key] = obj[key];
                  }
                  s[_this.options.childkey].push(objClone);
                  delete obj['#name'];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = /* @__PURE__ */ Object.create(null);
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit('end', _this.resultObject);
              }
            };
          })(this);
          ontext = (function (_this) {
            return function (text) {
              var charChild, s;
              s = stack[stack.length - 1];
              if (s) {
                s[charkey] += text;
                if (
                  _this.options.explicitChildren &&
                  _this.options.preserveChildrenOrder &&
                  _this.options.charsAsChildren &&
                  (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')
                ) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  charChild = {
                    '#name': '__text__',
                  };
                  charChild[charkey] = text;
                  if (_this.options.normalize) {
                    charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, ' ').trim();
                  }
                  s[_this.options.childkey].push(charChild);
                }
                return s;
              }
            };
          })(this);
          this.saxParser.ontext = ontext;
          return (this.saxParser.oncdata = (function (_this) {
            return function (text) {
              var s;
              s = ontext(text);
              if (s) {
                return (s.cdata = true);
              }
            };
          })(this));
        };
        Parser.prototype.parseString = function (str, cb) {
          var err;
          if (cb != null && typeof cb === 'function') {
            this.on('end', function (result) {
              this.reset();
              return cb(null, result);
            });
            this.on('error', function (err2) {
              this.reset();
              return cb(err2);
            });
          }
          try {
            str = str.toString();
            if (str.trim() === '') {
              this.emit('end', null);
              return true;
            }
            str = bom.stripBOM(str);
            if (this.options.async) {
              this.remaining = str;
              setImmediate2(this.processAsync);
              return this.saxParser;
            }
            return this.saxParser.write(str).close();
          } catch (error1) {
            err = error1;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit('error', err);
              return (this.saxParser.errThrown = true);
            } else if (this.saxParser.ended) {
              throw err;
            }
          }
        };
        Parser.prototype.parseStringPromise = function (str) {
          return new Promise(
            (function (_this) {
              return function (resolve, reject) {
                return _this.parseString(str, function (err, value) {
                  if (err) {
                    return reject(err);
                  } else {
                    return resolve(value);
                  }
                });
              };
            })(this)
          );
        };
        return Parser;
      })(events);
      exports.parseString = function (str, a, b) {
        var cb, options, parser;
        if (b != null) {
          if (typeof b === 'function') {
            cb = b;
          }
          if (typeof a === 'object') {
            options = a;
          }
        } else {
          if (typeof a === 'function') {
            cb = a;
          }
          options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
      };
      exports.parseStringPromise = function (str, a) {
        var options, parser;
        if (typeof a === 'object') {
          options = a;
        }
        parser = new exports.Parser(options);
        return parser.parseStringPromise(str);
      };
    }.call(exports));
  },
});

// node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS({
  'node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/xml2js.js'(exports) {
    (function () {
      'use strict';
      var builder,
        defaults,
        parser,
        processors,
        extend = function (child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
      defaults = require_defaults();
      builder = require_builder3();
      parser = require_parser2();
      processors = require_processors();
      exports.defaults = defaults.defaults;
      exports.processors = processors;
      exports.ValidationError = (function (superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
          this.message = message;
        }
        return ValidationError;
      })(Error);
      exports.Builder = builder.Builder;
      exports.Parser = parser.Parser;
      exports.parseString = parser.parseString;
      exports.parseStringPromise = parser.parseStringPromise;
    }.call(exports));
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/node_parser.js
var require_node_parser = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/xml/node_parser.js'(exports, module2) {
    var AWS3 = require_core();
    var util = AWS3.util;
    var Shape = AWS3.Model.Shape;
    var xml2js = require_xml2js();
    var options = {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      explicitRoot: false,
      emptyTag: null,
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      validator: null,
    };
    function NodeXmlParser() {}
    NodeXmlParser.prototype.parse = function (xml, shape) {
      shape = shape || {};
      var result = null;
      var error = null;
      var parser = new xml2js.Parser(options);
      parser.parseString(xml, function (e, r) {
        error = e;
        result = r;
      });
      if (result) {
        var data = parseXml(result, shape);
        if (result.ResponseMetadata) {
          data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});
        }
        return data;
      } else if (error) {
        throw util.error(error, { code: 'XMLParserError', retryable: true });
      } else {
        return parseXml({}, shape);
      }
    };
    function parseXml(xml, shape) {
      switch (shape.type) {
        case 'structure':
          return parseStructure(xml, shape);
        case 'map':
          return parseMap(xml, shape);
        case 'list':
          return parseList(xml, shape);
        case void 0:
        case null:
          return parseUnknown(xml);
        default:
          return parseScalar(xml, shape);
      }
    }
    function parseStructure(xml, shape) {
      var data = {};
      if (xml === null) return data;
      util.each(shape.members, function (memberName, memberShape) {
        var xmlName = memberShape.name;
        if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {
          var xmlChild = xml[xmlName];
          if (!memberShape.flattened) xmlChild = xmlChild[0];
          data[memberName] = parseXml(xmlChild, memberShape);
        } else if (memberShape.isXmlAttribute && xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {
          data[memberName] = parseScalar(xml.$[xmlName], memberShape);
        } else if (memberShape.type === 'list' && !shape.api.xmlNoDefaultLists) {
          data[memberName] = memberShape.defaultValue;
        }
      });
      return data;
    }
    function parseMap(xml, shape) {
      var data = {};
      if (xml === null) return data;
      var xmlKey = shape.key.name || 'key';
      var xmlValue = shape.value.name || 'value';
      var iterable = shape.flattened ? xml : xml.entry;
      if (Array.isArray(iterable)) {
        util.arrayEach(iterable, function (child) {
          data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);
        });
      }
      return data;
    }
    function parseList(xml, shape) {
      var data = [];
      var name = shape.member.name || 'member';
      if (shape.flattened) {
        util.arrayEach(xml, function (xmlChild) {
          data.push(parseXml(xmlChild, shape.member));
        });
      } else if (xml && Array.isArray(xml[name])) {
        util.arrayEach(xml[name], function (child) {
          data.push(parseXml(child, shape.member));
        });
      }
      return data;
    }
    function parseScalar(text, shape) {
      if (text && text.$ && text.$.encoding === 'base64') {
        shape = new Shape.create({ type: text.$.encoding });
      }
      if (text && text._) text = text._;
      if (typeof shape.toType === 'function') {
        return shape.toType(text);
      } else {
        return text;
      }
    }
    function parseUnknown(xml) {
      if (xml === void 0 || xml === null) return '';
      if (typeof xml === 'string') return xml;
      if (Array.isArray(xml)) {
        var arr = [];
        for (i = 0; i < xml.length; i++) {
          arr.push(parseXml(xml[i], {}));
        }
        return arr;
      }
      var keys = Object.keys(xml),
        i;
      if (keys.length === 0 || (keys.length === 1 && keys[0] === '$')) {
        return {};
      }
      var data = {};
      for (i = 0; i < keys.length; i++) {
        var key = keys[i],
          value = xml[key];
        if (key === '$') continue;
        if (value.length > 1) {
          data[key] = parseList(value, { member: {} });
        } else {
          data[key] = parseXml(value[0], {});
        }
      }
      return data;
    }
    module2.exports = NodeXmlParser;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/http/node.js
var require_node = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/http/node.js'() {
    var AWS3 = require_core();
    var Stream = AWS3.util.stream.Stream;
    var TransformStream = AWS3.util.stream.Transform;
    var ReadableStream = AWS3.util.stream.Readable;
    require_http();
    var CONNECTION_REUSE_ENV_NAME = 'AWS_NODEJS_CONNECTION_REUSE_ENABLED';
    AWS3.NodeHttpClient = AWS3.util.inherit({
      handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
        var self = this;
        var endpoint = httpRequest.endpoint;
        var pathPrefix = '';
        if (!httpOptions) httpOptions = {};
        if (httpOptions.proxy) {
          pathPrefix = endpoint.protocol + '//' + endpoint.hostname;
          if (endpoint.port !== 80 && endpoint.port !== 443) {
            pathPrefix += ':' + endpoint.port;
          }
          endpoint = new AWS3.Endpoint(httpOptions.proxy);
        }
        var useSSL = endpoint.protocol === 'https:';
        var http = useSSL ? require('https') : require('http');
        var options = {
          host: endpoint.hostname,
          port: endpoint.port,
          method: httpRequest.method,
          headers: httpRequest.headers,
          path: pathPrefix + httpRequest.path,
        };
        AWS3.util.update(options, httpOptions);
        if (!httpOptions.agent) {
          options.agent = this.getAgent(useSSL, {
            keepAlive: process.env[CONNECTION_REUSE_ENV_NAME] === '1' ? true : false,
          });
        }
        delete options.proxy;
        delete options.timeout;
        var stream = http.request(options, function (httpResp) {
          if (stream.didCallback) return;
          callback(httpResp);
          httpResp.emit('headers', httpResp.statusCode, httpResp.headers, httpResp.statusMessage);
        });
        httpRequest.stream = stream;
        stream.didCallback = false;
        if (httpOptions.connectTimeout) {
          var connectTimeoutId;
          stream.on('socket', function (socket) {
            if (socket.connecting) {
              connectTimeoutId = setTimeout(function connectTimeout() {
                if (stream.didCallback) return;
                stream.didCallback = true;
                stream.abort();
                errCallback(
                  AWS3.util.error(new Error('Socket timed out without establishing a connection'), {
                    code: 'TimeoutError',
                  })
                );
              }, httpOptions.connectTimeout);
              socket.on('connect', function () {
                clearTimeout(connectTimeoutId);
                connectTimeoutId = null;
              });
            }
          });
        }
        stream.setTimeout(httpOptions.timeout || 0, function () {
          if (stream.didCallback) return;
          stream.didCallback = true;
          var msg = 'Connection timed out after ' + httpOptions.timeout + 'ms';
          errCallback(AWS3.util.error(new Error(msg), { code: 'TimeoutError' }));
          stream.abort();
        });
        stream.on('error', function (err) {
          if (connectTimeoutId) {
            clearTimeout(connectTimeoutId);
            connectTimeoutId = null;
          }
          if (stream.didCallback) return;
          stream.didCallback = true;
          if (err.code === 'ECONNRESET' || err.code === 'EPIPE' || err.code === 'ETIMEDOUT') {
            errCallback(AWS3.util.error(err, { code: 'TimeoutError' }));
          } else {
            errCallback(err);
          }
        });
        var expect = httpRequest.headers.Expect || httpRequest.headers.expect;
        if (expect === '100-continue') {
          stream.once('continue', function () {
            self.writeBody(stream, httpRequest);
          });
        } else {
          this.writeBody(stream, httpRequest);
        }
        return stream;
      },
      writeBody: function writeBody(stream, httpRequest) {
        var body = httpRequest.body;
        var totalBytes = parseInt(httpRequest.headers['Content-Length'], 10);
        if (body instanceof Stream) {
          var progressStream = this.progressStream(stream, totalBytes);
          if (progressStream) {
            body.pipe(progressStream).pipe(stream);
          } else {
            body.pipe(stream);
          }
        } else if (body) {
          stream.once('finish', function () {
            stream.emit('sendProgress', {
              loaded: totalBytes,
              total: totalBytes,
            });
          });
          stream.end(body);
        } else {
          stream.end();
        }
      },
      getAgent: function getAgent(useSSL, agentOptions) {
        var http = useSSL ? require('https') : require('http');
        if (useSSL) {
          if (!AWS3.NodeHttpClient.sslAgent) {
            AWS3.NodeHttpClient.sslAgent = new http.Agent(
              AWS3.util.merge(
                {
                  rejectUnauthorized: process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0' ? false : true,
                },
                agentOptions || {}
              )
            );
            AWS3.NodeHttpClient.sslAgent.setMaxListeners(0);
            Object.defineProperty(AWS3.NodeHttpClient.sslAgent, 'maxSockets', {
              enumerable: true,
              get: function () {
                var defaultMaxSockets = 50;
                var globalAgent = http.globalAgent;
                if (globalAgent && globalAgent.maxSockets !== Infinity && typeof globalAgent.maxSockets === 'number') {
                  return globalAgent.maxSockets;
                }
                return defaultMaxSockets;
              },
            });
          }
          return AWS3.NodeHttpClient.sslAgent;
        } else {
          if (!AWS3.NodeHttpClient.agent) {
            AWS3.NodeHttpClient.agent = new http.Agent(agentOptions);
          }
          return AWS3.NodeHttpClient.agent;
        }
      },
      progressStream: function progressStream(stream, totalBytes) {
        if (typeof TransformStream === 'undefined') {
          return;
        }
        var loadedBytes = 0;
        var reporter = new TransformStream();
        reporter._transform = function (chunk, encoding, callback) {
          if (chunk) {
            loadedBytes += chunk.length;
            stream.emit('sendProgress', {
              loaded: loadedBytes,
              total: totalBytes,
            });
          }
          callback(null, chunk);
        };
        return reporter;
      },
      emitter: null,
    });
    AWS3.HttpClient.prototype = AWS3.NodeHttpClient.prototype;
    AWS3.HttpClient.streamsApiVersion = ReadableStream ? 2 : 1;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js
var require_token_file_web_identity_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js'() {
    var AWS3 = require_core();
    var fs = require('fs');
    var STS = require_sts2();
    var iniLoader = AWS3.util.iniLoader;
    AWS3.TokenFileWebIdentityCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function TokenFileWebIdentityCredentials(clientConfig) {
        AWS3.Credentials.call(this);
        this.data = null;
        this.clientConfig = AWS3.util.copy(clientConfig || {});
      },
      getParamsFromEnv: function getParamsFromEnv() {
        var ENV_TOKEN_FILE = 'AWS_WEB_IDENTITY_TOKEN_FILE',
          ENV_ROLE_ARN = 'AWS_ROLE_ARN';
        if (process.env[ENV_TOKEN_FILE] && process.env[ENV_ROLE_ARN]) {
          return [
            {
              envTokenFile: process.env[ENV_TOKEN_FILE],
              roleArn: process.env[ENV_ROLE_ARN],
              roleSessionName: process.env['AWS_ROLE_SESSION_NAME'],
            },
          ];
        }
      },
      getParamsFromSharedConfig: function getParamsFromSharedConfig() {
        var profiles = AWS3.util.getProfilesFromSharedConfig(iniLoader);
        var profileName = process.env.AWS_PROFILE || AWS3.util.defaultProfile;
        var profile = profiles[profileName] || {};
        if (Object.keys(profile).length === 0) {
          throw AWS3.util.error(new Error('Profile ' + profileName + ' not found'), {
            code: 'TokenFileWebIdentityCredentialsProviderFailure',
          });
        }
        var paramsArray = [];
        while (!profile['web_identity_token_file'] && profile['source_profile']) {
          paramsArray.unshift({
            roleArn: profile['role_arn'],
            roleSessionName: profile['role_session_name'],
          });
          var sourceProfile = profile['source_profile'];
          profile = profiles[sourceProfile];
        }
        paramsArray.unshift({
          envTokenFile: profile['web_identity_token_file'],
          roleArn: profile['role_arn'],
          roleSessionName: profile['role_session_name'],
        });
        return paramsArray;
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
      assumeRoleChaining: function assumeRoleChaining(paramsArray, callback) {
        var self = this;
        if (paramsArray.length === 0) {
          self.service.credentialsFrom(self.data, self);
          callback();
        } else {
          var params = paramsArray.shift();
          self.service.config.credentials = self.service.credentialsFrom(self.data, self);
          self.service.assumeRole(
            {
              RoleArn: params.roleArn,
              RoleSessionName: params.roleSessionName || 'token-file-web-identity',
            },
            function (err, data) {
              self.data = null;
              if (err) {
                callback(err);
              } else {
                self.data = data;
                self.assumeRoleChaining(paramsArray, callback);
              }
            }
          );
        }
      },
      load: function load(callback) {
        var self = this;
        try {
          var paramsArray = self.getParamsFromEnv();
          if (!paramsArray) {
            paramsArray = self.getParamsFromSharedConfig();
          }
          if (paramsArray) {
            var params = paramsArray.shift();
            var oidcToken = fs.readFileSync(params.envTokenFile, { encoding: 'ascii' });
            if (!self.service) {
              self.createClients();
            }
            self.service.assumeRoleWithWebIdentity(
              {
                WebIdentityToken: oidcToken,
                RoleArn: params.roleArn,
                RoleSessionName: params.roleSessionName || 'token-file-web-identity',
              },
              function (err, data) {
                self.data = null;
                if (err) {
                  callback(err);
                } else {
                  self.data = data;
                  self.assumeRoleChaining(paramsArray, callback);
                }
              }
            );
          }
        } catch (err) {
          callback(err);
        }
      },
      createClients: function () {
        if (!this.service) {
          var stsConfig = AWS3.util.merge({}, this.clientConfig);
          this.service = new STS(stsConfig);
          this.service.retryableError = function (error) {
            if (error.code === 'IDPCommunicationErrorException' || error.code === 'InvalidIdentityToken') {
              return true;
            } else {
              return AWS3.Service.prototype.retryableError.call(this, error);
            }
          };
        }
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service/get_endpoint.js
var require_get_endpoint = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service/get_endpoint.js'(exports, module2) {
    var getEndpoint = function () {
      return {
        IPv4: 'http://169.254.169.254',
        IPv6: 'http://[fd00:ec2::254]',
      };
    };
    module2.exports = getEndpoint;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js
var require_get_endpoint_mode = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js'(
    exports,
    module2
  ) {
    var getEndpointMode = function () {
      return {
        IPv4: 'IPv4',
        IPv6: 'IPv6',
      };
    };
    module2.exports = getEndpointMode;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js
var require_get_endpoint_config_options = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js'(
    exports,
    module2
  ) {
    var ENV_ENDPOINT_NAME = 'AWS_EC2_METADATA_SERVICE_ENDPOINT';
    var CONFIG_ENDPOINT_NAME = 'ec2_metadata_service_endpoint';
    var getEndpointConfigOptions = function () {
      return {
        environmentVariableSelector: function (env) {
          return env[ENV_ENDPOINT_NAME];
        },
        configFileSelector: function (profile) {
          return profile[CONFIG_ENDPOINT_NAME];
        },
        default: void 0,
      };
    };
    module2.exports = getEndpointConfigOptions;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js
var require_get_endpoint_mode_config_options = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js'(
    exports,
    module2
  ) {
    var EndpointMode = require_get_endpoint_mode()();
    var ENV_ENDPOINT_MODE_NAME = 'AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE';
    var CONFIG_ENDPOINT_MODE_NAME = 'ec2_metadata_service_endpoint_mode';
    var getEndpointModeConfigOptions = function () {
      return {
        environmentVariableSelector: function (env) {
          return env[ENV_ENDPOINT_MODE_NAME];
        },
        configFileSelector: function (profile) {
          return profile[CONFIG_ENDPOINT_MODE_NAME];
        },
        default: EndpointMode.IPv4,
      };
    };
    module2.exports = getEndpointModeConfigOptions;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js
var require_get_metadata_service_endpoint = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js'(
    exports,
    module2
  ) {
    var AWS3 = require_core();
    var Endpoint = require_get_endpoint()();
    var EndpointMode = require_get_endpoint_mode()();
    var ENDPOINT_CONFIG_OPTIONS = require_get_endpoint_config_options()();
    var ENDPOINT_MODE_CONFIG_OPTIONS = require_get_endpoint_mode_config_options()();
    var getMetadataServiceEndpoint = function () {
      var endpoint = AWS3.util.loadConfig(ENDPOINT_CONFIG_OPTIONS);
      if (endpoint !== void 0) return endpoint;
      var endpointMode = AWS3.util.loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS);
      switch (endpointMode) {
        case EndpointMode.IPv4:
          return Endpoint.IPv4;
        case EndpointMode.IPv6:
          return Endpoint.IPv6;
        default:
          throw new Error('Unsupported endpoint mode: ' + endpointMode);
      }
    };
    module2.exports = getMetadataServiceEndpoint;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service.js
var require_metadata_service = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/metadata_service.js'(exports, module2) {
    var AWS3 = require_core();
    require_http();
    var inherit = AWS3.util.inherit;
    var getMetadataServiceEndpoint = require_get_metadata_service_endpoint();
    var URL2 = require('url').URL;
    AWS3.MetadataService = inherit({
      endpoint: getMetadataServiceEndpoint(),
      httpOptions: { timeout: 0 },
      disableFetchToken: false,
      constructor: function MetadataService(options) {
        if (options && options.host) {
          options.endpoint = 'http://' + options.host;
          delete options.host;
        }
        AWS3.util.update(this, options);
      },
      request: function request(path, options, callback) {
        if (arguments.length === 2) {
          callback = options;
          options = {};
        }
        if (process.env[AWS3.util.imdsDisabledEnv]) {
          callback(new Error('EC2 Instance Metadata Service access disabled'));
          return;
        }
        path = path || '/';
        if (URL2) {
          new URL2(this.endpoint);
        }
        var httpRequest = new AWS3.HttpRequest(this.endpoint + path);
        httpRequest.method = options.method || 'GET';
        if (options.headers) {
          httpRequest.headers = options.headers;
        }
        AWS3.util.handleRequestWithRetries(httpRequest, this, callback);
      },
      loadCredentialsCallbacks: [],
      fetchMetadataToken: function fetchMetadataToken(callback) {
        var self = this;
        var tokenFetchPath = '/latest/api/token';
        self.request(
          tokenFetchPath,
          {
            method: 'PUT',
            headers: {
              'x-aws-ec2-metadata-token-ttl-seconds': '21600',
            },
          },
          callback
        );
      },
      fetchCredentials: function fetchCredentials(options, cb) {
        var self = this;
        var basePath = '/latest/meta-data/iam/security-credentials/';
        self.request(basePath, options, function (err, roleName) {
          if (err) {
            self.disableFetchToken = !(err.statusCode === 401);
            cb(
              AWS3.util.error(err, {
                message: 'EC2 Metadata roleName request returned error',
              })
            );
            return;
          }
          roleName = roleName.split('\n')[0];
          self.request(basePath + roleName, options, function (credErr, credData) {
            if (credErr) {
              self.disableFetchToken = !(credErr.statusCode === 401);
              cb(
                AWS3.util.error(credErr, {
                  message: 'EC2 Metadata creds request returned error',
                })
              );
              return;
            }
            try {
              var credentials = JSON.parse(credData);
              cb(null, credentials);
            } catch (parseError) {
              cb(parseError);
            }
          });
        });
      },
      loadCredentials: function loadCredentials(callback) {
        var self = this;
        self.loadCredentialsCallbacks.push(callback);
        if (self.loadCredentialsCallbacks.length > 1) {
          return;
        }
        function callbacks(err, creds) {
          var cb;
          while ((cb = self.loadCredentialsCallbacks.shift()) !== void 0) {
            cb(err, creds);
          }
        }
        if (self.disableFetchToken) {
          self.fetchCredentials({}, callbacks);
        } else {
          self.fetchMetadataToken(function (tokenError, token) {
            if (tokenError) {
              if (tokenError.code === 'TimeoutError') {
                self.disableFetchToken = true;
              } else if (tokenError.retryable === true) {
                callbacks(
                  AWS3.util.error(tokenError, {
                    message: 'EC2 Metadata token request returned error',
                  })
                );
                return;
              } else if (tokenError.statusCode === 400) {
                callbacks(
                  AWS3.util.error(tokenError, {
                    message: 'EC2 Metadata token request returned 400',
                  })
                );
                return;
              }
            }
            var options = {};
            if (token) {
              options.headers = {
                'x-aws-ec2-metadata-token': token,
              };
            }
            self.fetchCredentials(options, callbacks);
          });
        }
      },
    });
    module2.exports = AWS3.MetadataService;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js
var require_ec2_metadata_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js'() {
    var AWS3 = require_core();
    require_metadata_service();
    AWS3.EC2MetadataCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function EC2MetadataCredentials(options) {
        AWS3.Credentials.call(this);
        options = options ? AWS3.util.copy(options) : {};
        options = AWS3.util.merge({ maxRetries: this.defaultMaxRetries }, options);
        if (!options.httpOptions) options.httpOptions = {};
        options.httpOptions = AWS3.util.merge(
          {
            timeout: this.defaultTimeout,
            connectTimeout: this.defaultConnectTimeout,
          },
          options.httpOptions
        );
        this.metadataService = new AWS3.MetadataService(options);
        this.logger = options.logger || (AWS3.config && AWS3.config.logger);
      },
      defaultTimeout: 1e3,
      defaultConnectTimeout: 1e3,
      defaultMaxRetries: 3,
      originalExpiration: void 0,
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
      load: function load(callback) {
        var self = this;
        self.metadataService.loadCredentials(function (err, creds) {
          if (err) {
            if (self.hasLoadedCredentials()) {
              self.extendExpirationIfExpired();
              callback();
            } else {
              callback(err);
            }
          } else {
            self.setCredentials(creds);
            self.extendExpirationIfExpired();
            callback();
          }
        });
      },
      hasLoadedCredentials: function hasLoadedCredentials() {
        return this.AccessKeyId && this.secretAccessKey;
      },
      extendExpirationIfExpired: function extendExpirationIfExpired() {
        if (this.needsRefresh()) {
          this.originalExpiration = this.originalExpiration || this.expireTime;
          this.expired = false;
          var nextTimeout = 15 * 60 + Math.floor(Math.random() * 5 * 60);
          var currentTime = AWS3.util.date.getDate().getTime();
          this.expireTime = new Date(currentTime + nextTimeout * 1e3);
          this.logger.warn(
            'Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted again at ' +
              this.expireTime +
              '\nFor more information, please visit: https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html'
          );
        }
      },
      setCredentials: function setCredentials(creds) {
        var currentTime = AWS3.util.date.getDate().getTime();
        var expireTime = new Date(creds.Expiration);
        this.expired = currentTime >= expireTime ? true : false;
        this.metadata = creds;
        this.accessKeyId = creds.AccessKeyId;
        this.secretAccessKey = creds.SecretAccessKey;
        this.sessionToken = creds.Token;
        this.expireTime = expireTime;
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/remote_credentials.js
var require_remote_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/remote_credentials.js'() {
    var AWS3 = require_core();
    var ENV_RELATIVE_URI = 'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI';
    var ENV_FULL_URI = 'AWS_CONTAINER_CREDENTIALS_FULL_URI';
    var ENV_AUTH_TOKEN = 'AWS_CONTAINER_AUTHORIZATION_TOKEN';
    var FULL_URI_UNRESTRICTED_PROTOCOLS = ['https:'];
    var FULL_URI_ALLOWED_PROTOCOLS = ['http:', 'https:'];
    var FULL_URI_ALLOWED_HOSTNAMES = ['localhost', '127.0.0.1'];
    var RELATIVE_URI_HOST = '169.254.170.2';
    AWS3.RemoteCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function RemoteCredentials(options) {
        AWS3.Credentials.call(this);
        options = options ? AWS3.util.copy(options) : {};
        if (!options.httpOptions) options.httpOptions = {};
        options.httpOptions = AWS3.util.merge(this.httpOptions, options.httpOptions);
        AWS3.util.update(this, options);
      },
      httpOptions: { timeout: 1e3 },
      maxRetries: 3,
      isConfiguredForEcsCredentials: function isConfiguredForEcsCredentials() {
        return Boolean(process && process.env && (process.env[ENV_RELATIVE_URI] || process.env[ENV_FULL_URI]));
      },
      getECSFullUri: function getECSFullUri() {
        if (process && process.env) {
          var relative = process.env[ENV_RELATIVE_URI],
            full = process.env[ENV_FULL_URI];
          if (relative) {
            return 'http://' + RELATIVE_URI_HOST + relative;
          } else if (full) {
            var parsed = AWS3.util.urlParse(full);
            if (FULL_URI_ALLOWED_PROTOCOLS.indexOf(parsed.protocol) < 0) {
              throw AWS3.util.error(
                new Error(
                  'Unsupported protocol:  AWS.RemoteCredentials supports ' +
                    FULL_URI_ALLOWED_PROTOCOLS.join(',') +
                    ' only; ' +
                    parsed.protocol +
                    ' requested.'
                ),
                { code: 'ECSCredentialsProviderFailure' }
              );
            }
            if (
              FULL_URI_UNRESTRICTED_PROTOCOLS.indexOf(parsed.protocol) < 0 &&
              FULL_URI_ALLOWED_HOSTNAMES.indexOf(parsed.hostname) < 0
            ) {
              throw AWS3.util.error(
                new Error(
                  'Unsupported hostname: AWS.RemoteCredentials only supports ' +
                    FULL_URI_ALLOWED_HOSTNAMES.join(',') +
                    ' for ' +
                    parsed.protocol +
                    '; ' +
                    parsed.protocol +
                    '//' +
                    parsed.hostname +
                    ' requested.'
                ),
                { code: 'ECSCredentialsProviderFailure' }
              );
            }
            return full;
          } else {
            throw AWS3.util.error(
              new Error(
                'Variable ' + ENV_RELATIVE_URI + ' or ' + ENV_FULL_URI + ' must be set to use AWS.RemoteCredentials.'
              ),
              { code: 'ECSCredentialsProviderFailure' }
            );
          }
        } else {
          throw AWS3.util.error(new Error('No process info available'), { code: 'ECSCredentialsProviderFailure' });
        }
      },
      getECSAuthToken: function getECSAuthToken() {
        if (process && process.env && process.env[ENV_FULL_URI]) {
          return process.env[ENV_AUTH_TOKEN];
        }
      },
      credsFormatIsValid: function credsFormatIsValid(credData) {
        return !!credData.accessKeyId && !!credData.secretAccessKey && !!credData.sessionToken && !!credData.expireTime;
      },
      formatCreds: function formatCreds(credData) {
        if (!!credData.credentials) {
          credData = credData.credentials;
        }
        return {
          expired: false,
          accessKeyId: credData.accessKeyId || credData.AccessKeyId,
          secretAccessKey: credData.secretAccessKey || credData.SecretAccessKey,
          sessionToken: credData.sessionToken || credData.Token,
          expireTime: new Date(credData.expiration || credData.Expiration),
        };
      },
      request: function request(url, callback) {
        var httpRequest = new AWS3.HttpRequest(url);
        httpRequest.method = 'GET';
        httpRequest.headers.Accept = 'application/json';
        var token = this.getECSAuthToken();
        if (token) {
          httpRequest.headers.Authorization = token;
        }
        AWS3.util.handleRequestWithRetries(httpRequest, this, callback);
      },
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
      load: function load(callback) {
        var self = this;
        var fullUri;
        try {
          fullUri = this.getECSFullUri();
        } catch (err) {
          callback(err);
          return;
        }
        this.request(fullUri, function (err, data) {
          if (!err) {
            try {
              data = JSON.parse(data);
              var creds = self.formatCreds(data);
              if (!self.credsFormatIsValid(creds)) {
                throw AWS3.util.error(new Error('Response data is not in valid format'), {
                  code: 'ECSCredentialsProviderFailure',
                });
              }
              AWS3.util.update(self, creds);
            } catch (dataError) {
              err = dataError;
            }
          }
          callback(err, creds);
        });
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/ecs_credentials.js
var require_ecs_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/ecs_credentials.js'() {
    var AWS3 = require_core();
    AWS3.ECSCredentials = AWS3.RemoteCredentials;
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/environment_credentials.js
var require_environment_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/environment_credentials.js'() {
    var AWS3 = require_core();
    AWS3.EnvironmentCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function EnvironmentCredentials(envPrefix) {
        AWS3.Credentials.call(this);
        this.envPrefix = envPrefix;
        this.get(function () {});
      },
      refresh: function refresh(callback) {
        if (!callback) callback = AWS3.util.fn.callback;
        if (!process || !process.env) {
          callback(
            AWS3.util.error(new Error('No process info or environment variables available'), {
              code: 'EnvironmentCredentialsProviderFailure',
            })
          );
          return;
        }
        var keys = ['ACCESS_KEY_ID', 'SECRET_ACCESS_KEY', 'SESSION_TOKEN'];
        var values = [];
        for (var i = 0; i < keys.length; i++) {
          var prefix = '';
          if (this.envPrefix) prefix = this.envPrefix + '_';
          values[i] = process.env[prefix + keys[i]];
          if (!values[i] && keys[i] !== 'SESSION_TOKEN') {
            callback(
              AWS3.util.error(new Error('Variable ' + prefix + keys[i] + ' not set.'), {
                code: 'EnvironmentCredentialsProviderFailure',
              })
            );
            return;
          }
        }
        this.expired = false;
        AWS3.Credentials.apply(this, values);
        callback();
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/file_system_credentials.js
var require_file_system_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/file_system_credentials.js'() {
    var AWS3 = require_core();
    AWS3.FileSystemCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function FileSystemCredentials(filename) {
        AWS3.Credentials.call(this);
        this.filename = filename;
        this.get(function () {});
      },
      refresh: function refresh(callback) {
        if (!callback) callback = AWS3.util.fn.callback;
        try {
          var creds = JSON.parse(AWS3.util.readFileSync(this.filename));
          AWS3.Credentials.call(this, creds);
          if (!this.accessKeyId || !this.secretAccessKey) {
            throw AWS3.util.error(new Error('Credentials not set in ' + this.filename), {
              code: 'FileSystemCredentialsProviderFailure',
            });
          }
          this.expired = false;
          callback();
        } catch (err) {
          callback(err);
        }
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js
var require_shared_ini_file_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js'() {
    var AWS3 = require_core();
    var STS = require_sts2();
    var iniLoader = AWS3.util.iniLoader;
    var ASSUME_ROLE_DEFAULT_REGION = 'us-east-1';
    AWS3.SharedIniFileCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function SharedIniFileCredentials(options) {
        AWS3.Credentials.call(this);
        options = options || {};
        this.filename = options.filename;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS3.util.defaultProfile;
        this.disableAssumeRole = Boolean(options.disableAssumeRole);
        this.preferStaticCredentials = Boolean(options.preferStaticCredentials);
        this.tokenCodeFn = options.tokenCodeFn || null;
        this.httpOptions = options.httpOptions || null;
        this.get(options.callback || AWS3.util.fn.noop);
      },
      load: function load(callback) {
        var self = this;
        try {
          var profiles = AWS3.util.getProfilesFromSharedConfig(iniLoader, this.filename);
          var profile = profiles[this.profile] || {};
          if (Object.keys(profile).length === 0) {
            throw AWS3.util.error(new Error('Profile ' + this.profile + ' not found'), {
              code: 'SharedIniFileCredentialsProviderFailure',
            });
          }
          var preferStaticCredentialsToRoleArn = Boolean(
            this.preferStaticCredentials && profile['aws_access_key_id'] && profile['aws_secret_access_key']
          );
          if (profile['role_arn'] && !preferStaticCredentialsToRoleArn) {
            this.loadRoleProfile(profiles, profile, function (err, data) {
              if (err) {
                callback(err);
              } else {
                self.expired = false;
                self.accessKeyId = data.Credentials.AccessKeyId;
                self.secretAccessKey = data.Credentials.SecretAccessKey;
                self.sessionToken = data.Credentials.SessionToken;
                self.expireTime = data.Credentials.Expiration;
                callback(null);
              }
            });
            return;
          }
          this.accessKeyId = profile['aws_access_key_id'];
          this.secretAccessKey = profile['aws_secret_access_key'];
          this.sessionToken = profile['aws_session_token'];
          if (!this.accessKeyId || !this.secretAccessKey) {
            throw AWS3.util.error(new Error('Credentials not set for profile ' + this.profile), {
              code: 'SharedIniFileCredentialsProviderFailure',
            });
          }
          this.expired = false;
          callback(null);
        } catch (err) {
          callback(err);
        }
      },
      refresh: function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(callback || AWS3.util.fn.callback, this.disableAssumeRole);
      },
      loadRoleProfile: function loadRoleProfile(creds, roleProfile, callback) {
        if (this.disableAssumeRole) {
          throw AWS3.util.error(
            new Error(
              'Role assumption profiles are disabled. Failed to load profile ' +
                this.profile +
                ' from ' +
                creds.filename
            ),
            { code: 'SharedIniFileCredentialsProviderFailure' }
          );
        }
        var self = this;
        var roleArn = roleProfile['role_arn'];
        var roleSessionName = roleProfile['role_session_name'];
        var externalId = roleProfile['external_id'];
        var mfaSerial = roleProfile['mfa_serial'];
        var sourceProfileName = roleProfile['source_profile'];
        var durationSeconds = parseInt(roleProfile['duration_seconds'], 10) || void 0;
        var profileRegion = roleProfile['region'] || ASSUME_ROLE_DEFAULT_REGION;
        if (!sourceProfileName) {
          throw AWS3.util.error(new Error('source_profile is not set using profile ' + this.profile), {
            code: 'SharedIniFileCredentialsProviderFailure',
          });
        }
        var sourceProfileExistanceTest = creds[sourceProfileName];
        if (typeof sourceProfileExistanceTest !== 'object') {
          throw AWS3.util.error(
            new Error('source_profile ' + sourceProfileName + ' using profile ' + this.profile + ' does not exist'),
            { code: 'SharedIniFileCredentialsProviderFailure' }
          );
        }
        var sourceCredentials = new AWS3.SharedIniFileCredentials(
          AWS3.util.merge(this.options || {}, {
            profile: sourceProfileName,
            preferStaticCredentials: true,
          })
        );
        this.roleArn = roleArn;
        var sts = new STS({
          credentials: sourceCredentials,
          region: profileRegion,
          httpOptions: this.httpOptions,
        });
        var roleParams = {
          DurationSeconds: durationSeconds,
          RoleArn: roleArn,
          RoleSessionName: roleSessionName || 'aws-sdk-js-' + Date.now(),
        };
        if (externalId) {
          roleParams.ExternalId = externalId;
        }
        if (mfaSerial && self.tokenCodeFn) {
          roleParams.SerialNumber = mfaSerial;
          self.tokenCodeFn(mfaSerial, function (err, token) {
            if (err) {
              var message;
              if (err instanceof Error) {
                message = err.message;
              } else {
                message = err;
              }
              callback(
                AWS3.util.error(new Error('Error fetching MFA token: ' + message), {
                  code: 'SharedIniFileCredentialsProviderFailure',
                })
              );
              return;
            }
            roleParams.TokenCode = token;
            sts.assumeRole(roleParams, callback);
          });
          return;
        }
        sts.assumeRole(roleParams, callback);
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/sso_credentials.js
var require_sso_credentials = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/credentials/sso_credentials.js'() {
    var AWS3 = require_core();
    var path = require('path');
    var crypto = require('crypto');
    var iniLoader = AWS3.util.iniLoader;
    AWS3.SsoCredentials = AWS3.util.inherit(AWS3.Credentials, {
      constructor: function SsoCredentials(options) {
        AWS3.Credentials.call(this);
        options = options || {};
        this.errorCode = 'SsoCredentialsProviderFailure';
        this.expired = true;
        this.filename = options.filename;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS3.util.defaultProfile;
        this.service = options.ssoClient;
        this.httpOptions = options.httpOptions || null;
        this.get(options.callback || AWS3.util.fn.noop);
      },
      load: function load(callback) {
        var self = this;
        try {
          var profiles = AWS3.util.getProfilesFromSharedConfig(iniLoader, this.filename);
          var profile = profiles[this.profile] || {};
          if (Object.keys(profile).length === 0) {
            throw AWS3.util.error(new Error('Profile ' + this.profile + ' not found'), { code: self.errorCode });
          }
          if (profile.sso_session) {
            if (!profile.sso_account_id || !profile.sso_role_name) {
              throw AWS3.util.error(
                new Error(
                  'Profile ' +
                    this.profile +
                    ' with session ' +
                    profile.sso_session +
                    ' does not have valid SSO credentials. Required parameters "sso_account_id", "sso_session", "sso_role_name". Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html'
                ),
                { code: self.errorCode }
              );
            }
          } else {
            if (!profile.sso_start_url || !profile.sso_account_id || !profile.sso_region || !profile.sso_role_name) {
              throw AWS3.util.error(
                new Error(
                  'Profile ' +
                    this.profile +
                    ' does not have valid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html'
                ),
                { code: self.errorCode }
              );
            }
          }
          this.getToken(this.profile, profile, function (err, token) {
            if (err) {
              return callback(err);
            }
            var request = {
              accessToken: token,
              accountId: profile.sso_account_id,
              roleName: profile.sso_role_name,
            };
            if (!self.service || self.service.config.region !== profile.sso_region) {
              self.service = new AWS3.SSO({
                region: profile.sso_region,
                httpOptions: self.httpOptions,
              });
            }
            self.service.getRoleCredentials(request, function (err2, data) {
              if (err2 || !data || !data.roleCredentials) {
                callback(
                  AWS3.util.error(err2 || new Error('Please log in using "aws sso login"'), { code: self.errorCode }),
                  null
                );
              } else if (
                !data.roleCredentials.accessKeyId ||
                !data.roleCredentials.secretAccessKey ||
                !data.roleCredentials.sessionToken ||
                !data.roleCredentials.expiration
              ) {
                throw AWS3.util.error(new Error('SSO returns an invalid temporary credential.'));
              } else {
                self.expired = false;
                self.accessKeyId = data.roleCredentials.accessKeyId;
                self.secretAccessKey = data.roleCredentials.secretAccessKey;
                self.sessionToken = data.roleCredentials.sessionToken;
                self.expireTime = new Date(data.roleCredentials.expiration);
                callback(null);
              }
            });
          });
        } catch (err) {
          callback(err);
        }
      },
      getToken: function getToken(profileName, profile, callback) {
        var self = this;
        if (profile.sso_session) {
          var _iniLoader = AWS3.util.iniLoader;
          var ssoSessions = _iniLoader.loadSsoSessionsFrom();
          var ssoSession = ssoSessions[profile.sso_session];
          Object.assign(profile, ssoSession);
          var ssoTokenProvider = new AWS3.SSOTokenProvider({
            profile: profileName,
          });
          ssoTokenProvider.load(function (err) {
            if (err) {
              return callback(err);
            }
            return callback(null, ssoTokenProvider.token);
          });
          return;
        }
        try {
          var EXPIRE_WINDOW_MS = 15 * 60 * 1e3;
          var hasher = crypto.createHash('sha1');
          var fileName = hasher.update(profile.sso_start_url).digest('hex') + '.json';
          var cachePath = path.join(iniLoader.getHomeDir(), '.aws', 'sso', 'cache', fileName);
          var cacheFile = AWS3.util.readFileSync(cachePath);
          var cacheContent = null;
          if (cacheFile) {
            cacheContent = JSON.parse(cacheFile);
          }
          if (!cacheContent) {
            throw AWS3.util.error(
              new Error(
                'Cached credentials not found under ' +
                  this.profile +
                  ' profile. Please make sure you log in with aws sso login first'
              ),
              { code: self.errorCode }
            );
          }
          if (!cacheContent.startUrl || !cacheContent.region || !cacheContent.accessToken || !cacheContent.expiresAt) {
            throw AWS3.util.error(
              new Error('Cached credentials are missing required properties. Try running aws sso login.')
            );
          }
          if (new Date(cacheContent.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS) {
            throw AWS3.util.error(
              new Error(
                'The SSO session associated with this profile has expired. To refresh this SSO session run aws sso login with the corresponding profile.'
              )
            );
          }
          return callback(null, cacheContent.accessToken);
        } catch (err) {
          return callback(err, null);
        }
      },
      refresh: function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/token.js
var require_token = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/token.js'() {
    var AWS3 = require_core();
    AWS3.Token = AWS3.util.inherit({
      constructor: function Token(options) {
        AWS3.util.hideProperties(this, ['token']);
        this.expired = false;
        this.expireTime = null;
        this.refreshCallbacks = [];
        if (arguments.length === 1) {
          var options = arguments[0];
          this.token = options.token;
          this.expireTime = options.expireTime;
        }
      },
      expiryWindow: 15,
      needsRefresh: function needsRefresh() {
        var currentTime = AWS3.util.date.getDate().getTime();
        var adjustedTime = new Date(currentTime + this.expiryWindow * 1e3);
        if (this.expireTime && adjustedTime > this.expireTime) return true;
        return this.expired || !this.token;
      },
      get: function get(callback) {
        var self = this;
        if (this.needsRefresh()) {
          this.refresh(function (err) {
            if (!err) self.expired = false;
            if (callback) callback(err);
          });
        } else if (callback) {
          callback();
        }
      },
      refresh: function refresh(callback) {
        this.expired = false;
        callback();
      },
      coalesceRefresh: function coalesceRefresh(callback, sync) {
        var self = this;
        if (self.refreshCallbacks.push(callback) === 1) {
          self.load(function onLoad(err) {
            AWS3.util.arrayEach(self.refreshCallbacks, function (callback2) {
              if (sync) {
                callback2(err);
              } else {
                AWS3.util.defer(function () {
                  callback2(err);
                });
              }
            });
            self.refreshCallbacks.length = 0;
          });
        }
      },
      load: function load(callback) {
        callback();
      },
    });
    AWS3.Token.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.getPromise = AWS3.util.promisifyMethod('get', PromiseDependency);
      this.prototype.refreshPromise = AWS3.util.promisifyMethod('refresh', PromiseDependency);
    };
    AWS3.Token.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.getPromise;
      delete this.prototype.refreshPromise;
    };
    AWS3.util.addPromises(AWS3.Token);
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/token/token_provider_chain.js
var require_token_provider_chain = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/token/token_provider_chain.js'() {
    var AWS3 = require_core();
    AWS3.TokenProviderChain = AWS3.util.inherit(AWS3.Token, {
      constructor: function TokenProviderChain(providers) {
        if (providers) {
          this.providers = providers;
        } else {
          this.providers = AWS3.TokenProviderChain.defaultProviders.slice(0);
        }
        this.resolveCallbacks = [];
      },
      resolve: function resolve(callback) {
        var self = this;
        if (self.providers.length === 0) {
          callback(new Error('No providers'));
          return self;
        }
        if (self.resolveCallbacks.push(callback) === 1) {
          let resolveNext2 = function (err, token) {
            if ((!err && token) || index === providers.length) {
              AWS3.util.arrayEach(self.resolveCallbacks, function (callback2) {
                callback2(err, token);
              });
              self.resolveCallbacks.length = 0;
              return;
            }
            var provider = providers[index++];
            if (typeof provider === 'function') {
              token = provider.call();
            } else {
              token = provider;
            }
            if (token.get) {
              token.get(function (getErr) {
                resolveNext2(getErr, getErr ? null : token);
              });
            } else {
              resolveNext2(null, token);
            }
          };
          var resolveNext = resolveNext2;
          var index = 0;
          var providers = self.providers.slice(0);
          resolveNext2();
        }
        return self;
      },
    });
    AWS3.TokenProviderChain.defaultProviders = [];
    AWS3.TokenProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.resolvePromise = AWS3.util.promisifyMethod('resolve', PromiseDependency);
    };
    AWS3.TokenProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.resolvePromise;
    };
    AWS3.util.addPromises(AWS3.TokenProviderChain);
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/token/sso_token_provider.js
var require_sso_token_provider = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/token/sso_token_provider.js'() {
    var AWS3 = require_core();
    var crypto = require('crypto');
    var fs = require('fs');
    var path = require('path');
    var iniLoader = AWS3.util.iniLoader;
    var lastRefreshAttemptTime = 0;
    var validateTokenKey = function validateTokenKey2(token, key) {
      if (!token[key]) {
        throw AWS3.util.error(new Error('Key "' + key + '" not present in SSO Token'), {
          code: 'SSOTokenProviderFailure',
        });
      }
    };
    var refreshUnsuccessful = function refreshUnsuccessful2(currentTime, tokenExpireTime, callback) {
      if (tokenExpireTime > currentTime) {
        callback(null);
      } else {
        throw AWS3.util.error(new Error('SSO Token refresh failed. Please log in using "aws sso login"'), {
          code: 'SSOTokenProviderFailure',
        });
      }
    };
    AWS3.SSOTokenProvider = AWS3.util.inherit(AWS3.Token, {
      expiryWindow: 5 * 60,
      constructor: function SSOTokenProvider(options) {
        AWS3.Token.call(this);
        options = options || {};
        this.expired = true;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS3.util.defaultProfile;
        this.get(options.callback || AWS3.util.fn.noop);
      },
      load: function load(callback) {
        var self = this;
        var profiles = iniLoader.loadFrom({ isConfig: true });
        var profile = profiles[this.profile] || {};
        if (Object.keys(profile).length === 0) {
          throw AWS3.util.error(new Error('Profile "' + this.profile + '" not found'), {
            code: 'SSOTokenProviderFailure',
          });
        } else if (!profile['sso_session']) {
          throw AWS3.util.error(
            new Error('Profile "' + this.profile + '" is missing required property "sso_session".'),
            { code: 'SSOTokenProviderFailure' }
          );
        }
        var ssoSessionName = profile['sso_session'];
        var ssoSessions = iniLoader.loadSsoSessionsFrom();
        var ssoSession = ssoSessions[ssoSessionName];
        if (!ssoSession) {
          throw AWS3.util.error(new Error('Sso session "' + ssoSessionName + '" not found'), {
            code: 'SSOTokenProviderFailure',
          });
        } else if (!ssoSession['sso_start_url']) {
          throw AWS3.util.error(
            new Error('Sso session "' + this.profile + '" is missing required property "sso_start_url".'),
            { code: 'SSOTokenProviderFailure' }
          );
        } else if (!ssoSession['sso_region']) {
          throw AWS3.util.error(
            new Error('Sso session "' + this.profile + '" is missing required property "sso_region".'),
            { code: 'SSOTokenProviderFailure' }
          );
        }
        var hasher = crypto.createHash('sha1');
        var fileName = hasher.update(ssoSessionName).digest('hex') + '.json';
        var cachePath = path.join(iniLoader.getHomeDir(), '.aws', 'sso', 'cache', fileName);
        var tokenFromCache = JSON.parse(fs.readFileSync(cachePath));
        if (!tokenFromCache) {
          throw AWS3.util.error(
            new Error(
              'Cached token not found. Please log in using "aws sso login" for profile "' + this.profile + '".'
            ),
            { code: 'SSOTokenProviderFailure' }
          );
        }
        validateTokenKey(tokenFromCache, 'accessToken');
        validateTokenKey(tokenFromCache, 'expiresAt');
        var currentTime = AWS3.util.date.getDate().getTime();
        var adjustedTime = new Date(currentTime + this.expiryWindow * 1e3);
        var tokenExpireTime = new Date(tokenFromCache['expiresAt']);
        if (tokenExpireTime > adjustedTime) {
          self.token = tokenFromCache.accessToken;
          self.expireTime = tokenExpireTime;
          self.expired = false;
          callback(null);
          return;
        }
        if (currentTime - lastRefreshAttemptTime < 30 * 1e3) {
          refreshUnsuccessful(currentTime, tokenExpireTime, callback);
          return;
        }
        validateTokenKey(tokenFromCache, 'clientId');
        validateTokenKey(tokenFromCache, 'clientSecret');
        validateTokenKey(tokenFromCache, 'refreshToken');
        if (!self.service || self.service.config.region !== ssoSession.sso_region) {
          self.service = new AWS3.SSOOIDC({ region: ssoSession.sso_region });
        }
        var params = {
          clientId: tokenFromCache.clientId,
          clientSecret: tokenFromCache.clientSecret,
          refreshToken: tokenFromCache.refreshToken,
          grantType: 'refresh_token',
        };
        lastRefreshAttemptTime = AWS3.util.date.getDate().getTime();
        self.service.createToken(params, function (err, data) {
          if (err || !data) {
            refreshUnsuccessful(currentTime, tokenExpireTime, callback);
          } else {
            try {
              validateTokenKey(data, 'accessToken');
              validateTokenKey(data, 'expiresIn');
              self.expired = false;
              self.token = data.accessToken;
              self.expireTime = new Date(Date.now() + data.expiresIn * 1e3);
              callback(null);
              try {
                tokenFromCache.accessToken = data.accessToken;
                tokenFromCache.expiresAt = self.expireTime.toISOString();
                tokenFromCache.refreshToken = data.refreshToken;
                fs.writeFileSync(cachePath, JSON.stringify(tokenFromCache, null, 2));
              } catch (error) {}
            } catch (error) {
              refreshUnsuccessful(currentTime, tokenExpireTime, callback);
            }
          }
        });
      },
      refresh: function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(callback || AWS3.util.fn.callback);
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/node_loader.js
var require_node_loader = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/node_loader.js'(exports, module2) {
    var util = require_util();
    var region_utils = require_utils();
    var isFipsRegion = region_utils.isFipsRegion;
    var getRealRegion = region_utils.getRealRegion;
    util.isBrowser = function () {
      return false;
    };
    util.isNode = function () {
      return true;
    };
    util.crypto.lib = require('crypto');
    util.Buffer = require('buffer').Buffer;
    util.domain = require('domain');
    util.stream = require('stream');
    util.url = require('url');
    util.querystring = require('querystring');
    util.environment = 'nodejs';
    util.createEventStream = util.stream.Readable
      ? require_streaming_create_event_stream().createEventStream
      : require_buffered_create_event_stream().createEventStream;
    util.realClock = require_nodeClock();
    util.clientSideMonitoring = {
      Publisher: require_publisher().Publisher,
      configProvider: require_configuration(),
    };
    util.iniLoader = require_shared_ini().iniLoader;
    util.getSystemErrorName = require('util').getSystemErrorName;
    util.loadConfig = function (options) {
      var envValue = options.environmentVariableSelector(process.env);
      if (envValue !== void 0) {
        return envValue;
      }
      var configFile = {};
      try {
        configFile = util.iniLoader
          ? util.iniLoader.loadFrom({
              isConfig: true,
              filename: process.env[util.sharedConfigFileEnv],
            })
          : {};
      } catch (e) {}
      var sharedFileConfig = configFile[process.env.AWS_PROFILE || util.defaultProfile] || {};
      var configValue = options.configFileSelector(sharedFileConfig);
      if (configValue !== void 0) {
        return configValue;
      }
      if (typeof options.default === 'function') {
        return options.default();
      }
      return options.default;
    };
    var AWS3;
    module2.exports = AWS3 = require_core();
    require_credentials();
    require_credential_provider_chain();
    require_temporary_credentials();
    require_chainable_temporary_credentials();
    require_web_identity_credentials();
    require_cognito_identity_credentials();
    require_saml_credentials();
    require_process_credentials();
    AWS3.XML.Parser = require_node_parser();
    require_node();
    require_ini_loader();
    require_token_file_web_identity_credentials();
    require_ec2_metadata_credentials();
    require_remote_credentials();
    require_ecs_credentials();
    require_environment_credentials();
    require_file_system_credentials();
    require_shared_ini_file_credentials();
    require_process_credentials();
    require_sso_credentials();
    AWS3.CredentialProviderChain.defaultProviders = [
      function () {
        return new AWS3.EnvironmentCredentials('AWS');
      },
      function () {
        return new AWS3.EnvironmentCredentials('AMAZON');
      },
      function () {
        return new AWS3.SsoCredentials();
      },
      function () {
        return new AWS3.SharedIniFileCredentials();
      },
      function () {
        return new AWS3.ECSCredentials();
      },
      function () {
        return new AWS3.ProcessCredentials();
      },
      function () {
        return new AWS3.TokenFileWebIdentityCredentials();
      },
      function () {
        return new AWS3.EC2MetadataCredentials();
      },
    ];
    require_token();
    require_token_provider_chain();
    require_sso_token_provider();
    AWS3.TokenProviderChain.defaultProviders = [
      function () {
        return new AWS3.SSOTokenProvider();
      },
    ];
    var getRegion = function () {
      var env = process.env;
      var region = env.AWS_REGION || env.AMAZON_REGION;
      if (env[AWS3.util.configOptInEnv]) {
        var toCheck = [
          { filename: env[AWS3.util.sharedCredentialsFileEnv] },
          { isConfig: true, filename: env[AWS3.util.sharedConfigFileEnv] },
        ];
        var iniLoader = AWS3.util.iniLoader;
        while (!region && toCheck.length) {
          var configFile = {};
          var fileInfo = toCheck.shift();
          try {
            configFile = iniLoader.loadFrom(fileInfo);
          } catch (err) {
            if (fileInfo.isConfig) throw err;
          }
          var profile = configFile[env.AWS_PROFILE || AWS3.util.defaultProfile];
          region = profile && profile.region;
        }
      }
      return region;
    };
    var getBooleanValue = function (value) {
      return value === 'true' ? true : value === 'false' ? false : void 0;
    };
    var USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: function (env) {
        return getBooleanValue(env['AWS_USE_FIPS_ENDPOINT']);
      },
      configFileSelector: function (profile) {
        return getBooleanValue(profile['use_fips_endpoint']);
      },
      default: false,
    };
    var USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: function (env) {
        return getBooleanValue(env['AWS_USE_DUALSTACK_ENDPOINT']);
      },
      configFileSelector: function (profile) {
        return getBooleanValue(profile['use_dualstack_endpoint']);
      },
      default: false,
    };
    AWS3.util.update(AWS3.Config.prototype.keys, {
      credentials: function () {
        var credentials = null;
        new AWS3.CredentialProviderChain([
          function () {
            return new AWS3.EnvironmentCredentials('AWS');
          },
          function () {
            return new AWS3.EnvironmentCredentials('AMAZON');
          },
          function () {
            return new AWS3.SharedIniFileCredentials({ disableAssumeRole: true });
          },
        ]).resolve(function (err, creds) {
          if (!err) credentials = creds;
        });
        return credentials;
      },
      credentialProvider: function () {
        return new AWS3.CredentialProviderChain();
      },
      logger: function () {
        return process.env.AWSJS_DEBUG ? console : null;
      },
      region: function () {
        var region = getRegion();
        return region ? getRealRegion(region) : void 0;
      },
      tokenProvider: function () {
        return new AWS3.TokenProviderChain();
      },
      useFipsEndpoint: function () {
        var region = getRegion();
        return isFipsRegion(region) ? true : util.loadConfig(USE_FIPS_ENDPOINT_CONFIG_OPTIONS);
      },
      useDualstackEndpoint: function () {
        return util.loadConfig(USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS);
      },
    });
    AWS3.config = new AWS3.Config();
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/global.js
var require_global = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/global.js'(exports, module2) {
    require_node_loader();
    module2.exports = require_core();
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/services/lambda.js
var require_lambda = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/lib/services/lambda.js'() {
    var AWS3 = require_core();
    AWS3.util.update(AWS3.Lambda.prototype, {
      setupRequestListeners: function setupRequestListeners(request) {
        if (request.operation === 'invoke') {
          request.addListener('extractData', AWS3.util.convertPayloadToString);
        }
      },
    });
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/lambda-2014-11-11.min.json
var require_lambda_2014_11_11_min = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/lambda-2014-11-11.min.json'(exports, module2) {
    module2.exports = {
      metadata: {
        apiVersion: '2014-11-11',
        endpointPrefix: 'lambda',
        serviceFullName: 'AWS Lambda',
        serviceId: 'Lambda',
        signatureVersion: 'v4',
        protocol: 'rest-json',
      },
      operations: {
        AddEventSource: {
          http: {
            requestUri: '/2014-11-13/event-source-mappings/',
          },
          input: {
            type: 'structure',
            required: ['EventSource', 'FunctionName', 'Role'],
            members: {
              EventSource: {},
              FunctionName: {},
              Role: {},
              BatchSize: {
                type: 'integer',
              },
              Parameters: {
                shape: 'S6',
              },
            },
          },
          output: {
            shape: 'S7',
          },
        },
        DeleteFunction: {
          http: {
            method: 'DELETE',
            requestUri: '/2014-11-13/functions/{FunctionName}',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
            },
          },
        },
        GetEventSource: {
          http: {
            method: 'GET',
            requestUri: '/2014-11-13/event-source-mappings/{UUID}',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['UUID'],
            members: {
              UUID: {
                location: 'uri',
                locationName: 'UUID',
              },
            },
          },
          output: {
            shape: 'S7',
          },
        },
        GetFunction: {
          http: {
            method: 'GET',
            requestUri: '/2014-11-13/functions/{FunctionName}',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              Configuration: {
                shape: 'Se',
              },
              Code: {
                type: 'structure',
                members: {
                  RepositoryType: {},
                  Location: {},
                },
              },
            },
          },
        },
        GetFunctionConfiguration: {
          http: {
            method: 'GET',
            requestUri: '/2014-11-13/functions/{FunctionName}/configuration',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
            },
          },
          output: {
            shape: 'Se',
          },
        },
        InvokeAsync: {
          http: {
            requestUri: '/2014-11-13/functions/{FunctionName}/invoke-async/',
            responseCode: 202,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'InvokeArgs'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              InvokeArgs: {
                shape: 'Sq',
              },
            },
            payload: 'InvokeArgs',
          },
          output: {
            type: 'structure',
            members: {
              Status: {
                location: 'statusCode',
                type: 'integer',
              },
            },
          },
        },
        ListEventSources: {
          http: {
            method: 'GET',
            requestUri: '/2014-11-13/event-source-mappings/',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            members: {
              EventSourceArn: {
                location: 'querystring',
                locationName: 'EventSource',
              },
              FunctionName: {
                location: 'querystring',
                locationName: 'FunctionName',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              NextMarker: {},
              EventSources: {
                type: 'list',
                member: {
                  shape: 'S7',
                },
              },
            },
          },
        },
        ListFunctions: {
          http: {
            method: 'GET',
            requestUri: '/2014-11-13/functions/',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            members: {
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              NextMarker: {},
              Functions: {
                type: 'list',
                member: {
                  shape: 'Se',
                },
              },
            },
          },
        },
        RemoveEventSource: {
          http: {
            method: 'DELETE',
            requestUri: '/2014-11-13/event-source-mappings/{UUID}',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['UUID'],
            members: {
              UUID: {
                location: 'uri',
                locationName: 'UUID',
              },
            },
          },
        },
        UpdateFunctionConfiguration: {
          http: {
            method: 'PUT',
            requestUri: '/2014-11-13/functions/{FunctionName}/configuration',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Role: {
                location: 'querystring',
                locationName: 'Role',
              },
              Handler: {
                location: 'querystring',
                locationName: 'Handler',
              },
              Description: {
                location: 'querystring',
                locationName: 'Description',
              },
              Timeout: {
                location: 'querystring',
                locationName: 'Timeout',
                type: 'integer',
              },
              MemorySize: {
                location: 'querystring',
                locationName: 'MemorySize',
                type: 'integer',
              },
            },
          },
          output: {
            shape: 'Se',
          },
        },
        UploadFunction: {
          http: {
            method: 'PUT',
            requestUri: '/2014-11-13/functions/{FunctionName}',
            responseCode: 201,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'FunctionZip', 'Runtime', 'Role', 'Handler', 'Mode'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              FunctionZip: {
                shape: 'Sq',
              },
              Runtime: {
                location: 'querystring',
                locationName: 'Runtime',
              },
              Role: {
                location: 'querystring',
                locationName: 'Role',
              },
              Handler: {
                location: 'querystring',
                locationName: 'Handler',
              },
              Mode: {
                location: 'querystring',
                locationName: 'Mode',
              },
              Description: {
                location: 'querystring',
                locationName: 'Description',
              },
              Timeout: {
                location: 'querystring',
                locationName: 'Timeout',
                type: 'integer',
              },
              MemorySize: {
                location: 'querystring',
                locationName: 'MemorySize',
                type: 'integer',
              },
            },
            payload: 'FunctionZip',
          },
          output: {
            shape: 'Se',
          },
        },
      },
      shapes: {
        S6: {
          type: 'map',
          key: {},
          value: {},
        },
        S7: {
          type: 'structure',
          members: {
            UUID: {},
            BatchSize: {
              type: 'integer',
            },
            EventSource: {},
            FunctionName: {},
            Parameters: {
              shape: 'S6',
            },
            Role: {},
            LastModified: {
              type: 'timestamp',
            },
            IsActive: {
              type: 'boolean',
            },
            Status: {},
          },
        },
        Se: {
          type: 'structure',
          members: {
            FunctionName: {},
            FunctionARN: {},
            ConfigurationId: {},
            Runtime: {},
            Role: {},
            Handler: {},
            Mode: {},
            CodeSize: {
              type: 'long',
            },
            Description: {},
            Timeout: {
              type: 'integer',
            },
            MemorySize: {
              type: 'integer',
            },
            LastModified: {
              type: 'timestamp',
            },
          },
        },
        Sq: {
          type: 'blob',
          streaming: true,
        },
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/lambda-2014-11-11.paginators.json
var require_lambda_2014_11_11_paginators = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/lambda-2014-11-11.paginators.json'(exports, module2) {
    module2.exports = {
      pagination: {
        ListEventSources: {
          input_token: 'Marker',
          output_token: 'NextMarker',
          limit_key: 'MaxItems',
          result_key: 'EventSources',
        },
        ListFunctions: {
          input_token: 'Marker',
          output_token: 'NextMarker',
          limit_key: 'MaxItems',
          result_key: 'Functions',
        },
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/lambda-2015-03-31.min.json
var require_lambda_2015_03_31_min = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/lambda-2015-03-31.min.json'(exports, module2) {
    module2.exports = {
      version: '2.0',
      metadata: {
        apiVersion: '2015-03-31',
        endpointPrefix: 'lambda',
        protocol: 'rest-json',
        serviceFullName: 'AWS Lambda',
        serviceId: 'Lambda',
        signatureVersion: 'v4',
        uid: 'lambda-2015-03-31',
      },
      operations: {
        AddLayerVersionPermission: {
          http: {
            requestUri: '/2018-10-31/layers/{LayerName}/versions/{VersionNumber}/policy',
            responseCode: 201,
          },
          input: {
            type: 'structure',
            required: ['LayerName', 'VersionNumber', 'StatementId', 'Action', 'Principal'],
            members: {
              LayerName: {
                location: 'uri',
                locationName: 'LayerName',
              },
              VersionNumber: {
                location: 'uri',
                locationName: 'VersionNumber',
                type: 'long',
              },
              StatementId: {},
              Action: {},
              Principal: {},
              OrganizationId: {},
              RevisionId: {
                location: 'querystring',
                locationName: 'RevisionId',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              Statement: {},
              RevisionId: {},
            },
          },
        },
        AddPermission: {
          http: {
            requestUri: '/2015-03-31/functions/{FunctionName}/policy',
            responseCode: 201,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'StatementId', 'Action', 'Principal'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              StatementId: {},
              Action: {},
              Principal: {},
              SourceArn: {},
              SourceAccount: {},
              EventSourceToken: {},
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
              RevisionId: {},
              PrincipalOrgID: {},
              FunctionUrlAuthType: {},
            },
          },
          output: {
            type: 'structure',
            members: {
              Statement: {},
            },
          },
        },
        CreateAlias: {
          http: {
            requestUri: '/2015-03-31/functions/{FunctionName}/aliases',
            responseCode: 201,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'Name', 'FunctionVersion'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Name: {},
              FunctionVersion: {},
              Description: {},
              RoutingConfig: {
                shape: 'Sp',
              },
            },
          },
          output: {
            shape: 'St',
          },
        },
        CreateCodeSigningConfig: {
          http: {
            requestUri: '/2020-04-22/code-signing-configs/',
            responseCode: 201,
          },
          input: {
            type: 'structure',
            required: ['AllowedPublishers'],
            members: {
              Description: {},
              AllowedPublishers: {
                shape: 'Sw',
              },
              CodeSigningPolicies: {
                shape: 'Sy',
              },
            },
          },
          output: {
            type: 'structure',
            required: ['CodeSigningConfig'],
            members: {
              CodeSigningConfig: {
                shape: 'S11',
              },
            },
          },
        },
        CreateEventSourceMapping: {
          http: {
            requestUri: '/2015-03-31/event-source-mappings/',
            responseCode: 202,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              EventSourceArn: {},
              FunctionName: {},
              Enabled: {
                type: 'boolean',
              },
              BatchSize: {
                type: 'integer',
              },
              FilterCriteria: {
                shape: 'S18',
              },
              MaximumBatchingWindowInSeconds: {
                type: 'integer',
              },
              ParallelizationFactor: {
                type: 'integer',
              },
              StartingPosition: {},
              StartingPositionTimestamp: {
                type: 'timestamp',
              },
              DestinationConfig: {
                shape: 'S1g',
              },
              MaximumRecordAgeInSeconds: {
                type: 'integer',
              },
              BisectBatchOnFunctionError: {
                type: 'boolean',
              },
              MaximumRetryAttempts: {
                type: 'integer',
              },
              TumblingWindowInSeconds: {
                type: 'integer',
              },
              Topics: {
                shape: 'S1o',
              },
              Queues: {
                shape: 'S1q',
              },
              SourceAccessConfigurations: {
                shape: 'S1s',
              },
              SelfManagedEventSource: {
                shape: 'S1w',
              },
              FunctionResponseTypes: {
                shape: 'S21',
              },
              AmazonManagedKafkaEventSourceConfig: {
                shape: 'S23',
              },
              SelfManagedKafkaEventSourceConfig: {
                shape: 'S24',
              },
              ScalingConfig: {
                shape: 'S25',
              },
              DocumentDBEventSourceConfig: {
                shape: 'S27',
              },
            },
          },
          output: {
            shape: 'S2b',
          },
        },
        CreateFunction: {
          http: {
            requestUri: '/2015-03-31/functions',
            responseCode: 201,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'Role', 'Code'],
            members: {
              FunctionName: {},
              Runtime: {},
              Role: {},
              Handler: {},
              Code: {
                type: 'structure',
                members: {
                  ZipFile: {
                    shape: 'S2h',
                  },
                  S3Bucket: {},
                  S3Key: {},
                  S3ObjectVersion: {},
                  ImageUri: {},
                },
              },
              Description: {},
              Timeout: {
                type: 'integer',
              },
              MemorySize: {
                type: 'integer',
              },
              Publish: {
                type: 'boolean',
              },
              VpcConfig: {
                shape: 'S2o',
              },
              PackageType: {},
              DeadLetterConfig: {
                shape: 'S2v',
              },
              Environment: {
                shape: 'S2x',
              },
              KMSKeyArn: {},
              TracingConfig: {
                shape: 'S32',
              },
              Tags: {
                shape: 'S34',
              },
              Layers: {
                shape: 'S37',
              },
              FileSystemConfigs: {
                shape: 'S39',
              },
              ImageConfig: {
                shape: 'S3d',
              },
              CodeSigningConfigArn: {},
              Architectures: {
                shape: 'S3g',
              },
              EphemeralStorage: {
                shape: 'S3i',
              },
              SnapStart: {
                shape: 'S3k',
              },
            },
          },
          output: {
            shape: 'S3m',
          },
        },
        CreateFunctionUrlConfig: {
          http: {
            requestUri: '/2021-10-31/functions/{FunctionName}/url',
            responseCode: 201,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'AuthType'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
              AuthType: {},
              Cors: {
                shape: 'S4d',
              },
              InvokeMode: {},
            },
          },
          output: {
            type: 'structure',
            required: ['FunctionUrl', 'FunctionArn', 'AuthType', 'CreationTime'],
            members: {
              FunctionUrl: {},
              FunctionArn: {},
              AuthType: {},
              Cors: {
                shape: 'S4d',
              },
              CreationTime: {},
              InvokeMode: {},
            },
          },
        },
        DeleteAlias: {
          http: {
            method: 'DELETE',
            requestUri: '/2015-03-31/functions/{FunctionName}/aliases/{Name}',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'Name'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Name: {
                location: 'uri',
                locationName: 'Name',
              },
            },
          },
        },
        DeleteCodeSigningConfig: {
          http: {
            method: 'DELETE',
            requestUri: '/2020-04-22/code-signing-configs/{CodeSigningConfigArn}',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['CodeSigningConfigArn'],
            members: {
              CodeSigningConfigArn: {
                location: 'uri',
                locationName: 'CodeSigningConfigArn',
              },
            },
          },
          output: {
            type: 'structure',
            members: {},
          },
        },
        DeleteEventSourceMapping: {
          http: {
            method: 'DELETE',
            requestUri: '/2015-03-31/event-source-mappings/{UUID}',
            responseCode: 202,
          },
          input: {
            type: 'structure',
            required: ['UUID'],
            members: {
              UUID: {
                location: 'uri',
                locationName: 'UUID',
              },
            },
          },
          output: {
            shape: 'S2b',
          },
        },
        DeleteFunction: {
          http: {
            method: 'DELETE',
            requestUri: '/2015-03-31/functions/{FunctionName}',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
        },
        DeleteFunctionCodeSigningConfig: {
          http: {
            method: 'DELETE',
            requestUri: '/2020-06-30/functions/{FunctionName}/code-signing-config',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
            },
          },
        },
        DeleteFunctionConcurrency: {
          http: {
            method: 'DELETE',
            requestUri: '/2017-10-31/functions/{FunctionName}/concurrency',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
            },
          },
        },
        DeleteFunctionEventInvokeConfig: {
          http: {
            method: 'DELETE',
            requestUri: '/2019-09-25/functions/{FunctionName}/event-invoke-config',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
        },
        DeleteFunctionUrlConfig: {
          http: {
            method: 'DELETE',
            requestUri: '/2021-10-31/functions/{FunctionName}/url',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
        },
        DeleteLayerVersion: {
          http: {
            method: 'DELETE',
            requestUri: '/2018-10-31/layers/{LayerName}/versions/{VersionNumber}',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['LayerName', 'VersionNumber'],
            members: {
              LayerName: {
                location: 'uri',
                locationName: 'LayerName',
              },
              VersionNumber: {
                location: 'uri',
                locationName: 'VersionNumber',
                type: 'long',
              },
            },
          },
        },
        DeleteProvisionedConcurrencyConfig: {
          http: {
            method: 'DELETE',
            requestUri: '/2019-09-30/functions/{FunctionName}/provisioned-concurrency',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'Qualifier'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
        },
        GetAccountSettings: {
          http: {
            method: 'GET',
            requestUri: '/2016-08-19/account-settings/',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            members: {},
          },
          output: {
            type: 'structure',
            members: {
              AccountLimit: {
                type: 'structure',
                members: {
                  TotalCodeSize: {
                    type: 'long',
                  },
                  CodeSizeUnzipped: {
                    type: 'long',
                  },
                  CodeSizeZipped: {
                    type: 'long',
                  },
                  ConcurrentExecutions: {
                    type: 'integer',
                  },
                  UnreservedConcurrentExecutions: {
                    type: 'integer',
                  },
                },
              },
              AccountUsage: {
                type: 'structure',
                members: {
                  TotalCodeSize: {
                    type: 'long',
                  },
                  FunctionCount: {
                    type: 'long',
                  },
                },
              },
            },
          },
        },
        GetAlias: {
          http: {
            method: 'GET',
            requestUri: '/2015-03-31/functions/{FunctionName}/aliases/{Name}',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'Name'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Name: {
                location: 'uri',
                locationName: 'Name',
              },
            },
          },
          output: {
            shape: 'St',
          },
        },
        GetCodeSigningConfig: {
          http: {
            method: 'GET',
            requestUri: '/2020-04-22/code-signing-configs/{CodeSigningConfigArn}',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['CodeSigningConfigArn'],
            members: {
              CodeSigningConfigArn: {
                location: 'uri',
                locationName: 'CodeSigningConfigArn',
              },
            },
          },
          output: {
            type: 'structure',
            required: ['CodeSigningConfig'],
            members: {
              CodeSigningConfig: {
                shape: 'S11',
              },
            },
          },
        },
        GetEventSourceMapping: {
          http: {
            method: 'GET',
            requestUri: '/2015-03-31/event-source-mappings/{UUID}',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['UUID'],
            members: {
              UUID: {
                location: 'uri',
                locationName: 'UUID',
              },
            },
          },
          output: {
            shape: 'S2b',
          },
        },
        GetFunction: {
          http: {
            method: 'GET',
            requestUri: '/2015-03-31/functions/{FunctionName}',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              Configuration: {
                shape: 'S3m',
              },
              Code: {
                type: 'structure',
                members: {
                  RepositoryType: {},
                  Location: {},
                  ImageUri: {},
                  ResolvedImageUri: {},
                },
              },
              Tags: {
                shape: 'S34',
              },
              Concurrency: {
                shape: 'S5d',
              },
            },
          },
        },
        GetFunctionCodeSigningConfig: {
          http: {
            method: 'GET',
            requestUri: '/2020-06-30/functions/{FunctionName}/code-signing-config',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
            },
          },
          output: {
            type: 'structure',
            required: ['CodeSigningConfigArn', 'FunctionName'],
            members: {
              CodeSigningConfigArn: {},
              FunctionName: {},
            },
          },
        },
        GetFunctionConcurrency: {
          http: {
            method: 'GET',
            requestUri: '/2019-09-30/functions/{FunctionName}/concurrency',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              ReservedConcurrentExecutions: {
                type: 'integer',
              },
            },
          },
        },
        GetFunctionConfiguration: {
          http: {
            method: 'GET',
            requestUri: '/2015-03-31/functions/{FunctionName}/configuration',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
          output: {
            shape: 'S3m',
          },
        },
        GetFunctionEventInvokeConfig: {
          http: {
            method: 'GET',
            requestUri: '/2019-09-25/functions/{FunctionName}/event-invoke-config',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
          output: {
            shape: 'S5l',
          },
        },
        GetFunctionUrlConfig: {
          http: {
            method: 'GET',
            requestUri: '/2021-10-31/functions/{FunctionName}/url',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
          output: {
            type: 'structure',
            required: ['FunctionUrl', 'FunctionArn', 'AuthType', 'CreationTime', 'LastModifiedTime'],
            members: {
              FunctionUrl: {},
              FunctionArn: {},
              AuthType: {},
              Cors: {
                shape: 'S4d',
              },
              CreationTime: {},
              LastModifiedTime: {},
              InvokeMode: {},
            },
          },
        },
        GetLayerVersion: {
          http: {
            method: 'GET',
            requestUri: '/2018-10-31/layers/{LayerName}/versions/{VersionNumber}',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['LayerName', 'VersionNumber'],
            members: {
              LayerName: {
                location: 'uri',
                locationName: 'LayerName',
              },
              VersionNumber: {
                location: 'uri',
                locationName: 'VersionNumber',
                type: 'long',
              },
            },
          },
          output: {
            shape: 'S5r',
          },
        },
        GetLayerVersionByArn: {
          http: {
            method: 'GET',
            requestUri: '/2018-10-31/layers?find=LayerVersion',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['Arn'],
            members: {
              Arn: {
                location: 'querystring',
                locationName: 'Arn',
              },
            },
          },
          output: {
            shape: 'S5r',
          },
        },
        GetLayerVersionPolicy: {
          http: {
            method: 'GET',
            requestUri: '/2018-10-31/layers/{LayerName}/versions/{VersionNumber}/policy',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['LayerName', 'VersionNumber'],
            members: {
              LayerName: {
                location: 'uri',
                locationName: 'LayerName',
              },
              VersionNumber: {
                location: 'uri',
                locationName: 'VersionNumber',
                type: 'long',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              Policy: {},
              RevisionId: {},
            },
          },
        },
        GetPolicy: {
          http: {
            method: 'GET',
            requestUri: '/2015-03-31/functions/{FunctionName}/policy',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              Policy: {},
              RevisionId: {},
            },
          },
        },
        GetProvisionedConcurrencyConfig: {
          http: {
            method: 'GET',
            requestUri: '/2019-09-30/functions/{FunctionName}/provisioned-concurrency',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'Qualifier'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              RequestedProvisionedConcurrentExecutions: {
                type: 'integer',
              },
              AvailableProvisionedConcurrentExecutions: {
                type: 'integer',
              },
              AllocatedProvisionedConcurrentExecutions: {
                type: 'integer',
              },
              Status: {},
              StatusReason: {},
              LastModified: {},
            },
          },
        },
        GetRuntimeManagementConfig: {
          http: {
            method: 'GET',
            requestUri: '/2021-07-20/functions/{FunctionName}/runtime-management-config',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              UpdateRuntimeOn: {},
              RuntimeVersionArn: {},
              FunctionArn: {},
            },
          },
        },
        Invoke: {
          http: {
            requestUri: '/2015-03-31/functions/{FunctionName}/invocations',
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              InvocationType: {
                location: 'header',
                locationName: 'X-Amz-Invocation-Type',
              },
              LogType: {
                location: 'header',
                locationName: 'X-Amz-Log-Type',
              },
              ClientContext: {
                location: 'header',
                locationName: 'X-Amz-Client-Context',
              },
              Payload: {
                shape: 'S2h',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
            },
            payload: 'Payload',
          },
          output: {
            type: 'structure',
            members: {
              StatusCode: {
                location: 'statusCode',
                type: 'integer',
              },
              FunctionError: {
                location: 'header',
                locationName: 'X-Amz-Function-Error',
              },
              LogResult: {
                location: 'header',
                locationName: 'X-Amz-Log-Result',
              },
              Payload: {
                shape: 'S2h',
              },
              ExecutedVersion: {
                location: 'header',
                locationName: 'X-Amz-Executed-Version',
              },
            },
            payload: 'Payload',
          },
        },
        InvokeAsync: {
          http: {
            requestUri: '/2014-11-13/functions/{FunctionName}/invoke-async/',
            responseCode: 202,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'InvokeArgs'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              InvokeArgs: {
                type: 'blob',
                streaming: true,
              },
            },
            deprecated: true,
            payload: 'InvokeArgs',
          },
          output: {
            type: 'structure',
            members: {
              Status: {
                location: 'statusCode',
                type: 'integer',
              },
            },
            deprecated: true,
          },
          deprecated: true,
        },
        InvokeWithResponseStream: {
          http: {
            requestUri: '/2021-11-15/functions/{FunctionName}/response-streaming-invocations',
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              InvocationType: {
                location: 'header',
                locationName: 'X-Amz-Invocation-Type',
              },
              LogType: {
                location: 'header',
                locationName: 'X-Amz-Log-Type',
              },
              ClientContext: {
                location: 'header',
                locationName: 'X-Amz-Client-Context',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
              Payload: {
                shape: 'S2h',
              },
            },
            payload: 'Payload',
          },
          output: {
            type: 'structure',
            members: {
              StatusCode: {
                location: 'statusCode',
                type: 'integer',
              },
              ExecutedVersion: {
                location: 'header',
                locationName: 'X-Amz-Executed-Version',
              },
              EventStream: {
                type: 'structure',
                members: {
                  PayloadChunk: {
                    type: 'structure',
                    members: {
                      Payload: {
                        shape: 'S2h',
                        eventpayload: true,
                      },
                    },
                    event: true,
                  },
                  InvokeComplete: {
                    type: 'structure',
                    members: {
                      ErrorCode: {},
                      ErrorDetails: {},
                      LogResult: {},
                    },
                    event: true,
                  },
                },
                eventstream: true,
              },
              ResponseStreamContentType: {
                location: 'header',
                locationName: 'Content-Type',
              },
            },
            payload: 'EventStream',
          },
        },
        ListAliases: {
          http: {
            method: 'GET',
            requestUri: '/2015-03-31/functions/{FunctionName}/aliases',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              FunctionVersion: {
                location: 'querystring',
                locationName: 'FunctionVersion',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              NextMarker: {},
              Aliases: {
                type: 'list',
                member: {
                  shape: 'St',
                },
              },
            },
          },
        },
        ListCodeSigningConfigs: {
          http: {
            method: 'GET',
            requestUri: '/2020-04-22/code-signing-configs/',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            members: {
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              NextMarker: {},
              CodeSigningConfigs: {
                type: 'list',
                member: {
                  shape: 'S11',
                },
              },
            },
          },
        },
        ListEventSourceMappings: {
          http: {
            method: 'GET',
            requestUri: '/2015-03-31/event-source-mappings/',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            members: {
              EventSourceArn: {
                location: 'querystring',
                locationName: 'EventSourceArn',
              },
              FunctionName: {
                location: 'querystring',
                locationName: 'FunctionName',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              NextMarker: {},
              EventSourceMappings: {
                type: 'list',
                member: {
                  shape: 'S2b',
                },
              },
            },
          },
        },
        ListFunctionEventInvokeConfigs: {
          http: {
            method: 'GET',
            requestUri: '/2019-09-25/functions/{FunctionName}/event-invoke-config/list',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              FunctionEventInvokeConfigs: {
                type: 'list',
                member: {
                  shape: 'S5l',
                },
              },
              NextMarker: {},
            },
          },
        },
        ListFunctionUrlConfigs: {
          http: {
            method: 'GET',
            requestUri: '/2021-10-31/functions/{FunctionName}/urls',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            required: ['FunctionUrlConfigs'],
            members: {
              FunctionUrlConfigs: {
                type: 'list',
                member: {
                  type: 'structure',
                  required: ['FunctionUrl', 'FunctionArn', 'CreationTime', 'LastModifiedTime', 'AuthType'],
                  members: {
                    FunctionUrl: {},
                    FunctionArn: {},
                    CreationTime: {},
                    LastModifiedTime: {},
                    Cors: {
                      shape: 'S4d',
                    },
                    AuthType: {},
                    InvokeMode: {},
                  },
                },
              },
              NextMarker: {},
            },
          },
        },
        ListFunctions: {
          http: {
            method: 'GET',
            requestUri: '/2015-03-31/functions/',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            members: {
              MasterRegion: {
                location: 'querystring',
                locationName: 'MasterRegion',
              },
              FunctionVersion: {
                location: 'querystring',
                locationName: 'FunctionVersion',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              NextMarker: {},
              Functions: {
                shape: 'S7b',
              },
            },
          },
        },
        ListFunctionsByCodeSigningConfig: {
          http: {
            method: 'GET',
            requestUri: '/2020-04-22/code-signing-configs/{CodeSigningConfigArn}/functions',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['CodeSigningConfigArn'],
            members: {
              CodeSigningConfigArn: {
                location: 'uri',
                locationName: 'CodeSigningConfigArn',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              NextMarker: {},
              FunctionArns: {
                type: 'list',
                member: {},
              },
            },
          },
        },
        ListLayerVersions: {
          http: {
            method: 'GET',
            requestUri: '/2018-10-31/layers/{LayerName}/versions',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['LayerName'],
            members: {
              CompatibleRuntime: {
                location: 'querystring',
                locationName: 'CompatibleRuntime',
              },
              LayerName: {
                location: 'uri',
                locationName: 'LayerName',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
              CompatibleArchitecture: {
                location: 'querystring',
                locationName: 'CompatibleArchitecture',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              NextMarker: {},
              LayerVersions: {
                type: 'list',
                member: {
                  shape: 'S7j',
                },
              },
            },
          },
        },
        ListLayers: {
          http: {
            method: 'GET',
            requestUri: '/2018-10-31/layers',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            members: {
              CompatibleRuntime: {
                location: 'querystring',
                locationName: 'CompatibleRuntime',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
              CompatibleArchitecture: {
                location: 'querystring',
                locationName: 'CompatibleArchitecture',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              NextMarker: {},
              Layers: {
                type: 'list',
                member: {
                  type: 'structure',
                  members: {
                    LayerName: {},
                    LayerArn: {},
                    LatestMatchingVersion: {
                      shape: 'S7j',
                    },
                  },
                },
              },
            },
          },
        },
        ListProvisionedConcurrencyConfigs: {
          http: {
            method: 'GET',
            requestUri: '/2019-09-30/functions/{FunctionName}/provisioned-concurrency?List=ALL',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              ProvisionedConcurrencyConfigs: {
                type: 'list',
                member: {
                  type: 'structure',
                  members: {
                    FunctionArn: {},
                    RequestedProvisionedConcurrentExecutions: {
                      type: 'integer',
                    },
                    AvailableProvisionedConcurrentExecutions: {
                      type: 'integer',
                    },
                    AllocatedProvisionedConcurrentExecutions: {
                      type: 'integer',
                    },
                    Status: {},
                    StatusReason: {},
                    LastModified: {},
                  },
                },
              },
              NextMarker: {},
            },
          },
        },
        ListTags: {
          http: {
            method: 'GET',
            requestUri: '/2017-03-31/tags/{ARN}',
          },
          input: {
            type: 'structure',
            required: ['Resource'],
            members: {
              Resource: {
                location: 'uri',
                locationName: 'ARN',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              Tags: {
                shape: 'S34',
              },
            },
          },
        },
        ListVersionsByFunction: {
          http: {
            method: 'GET',
            requestUri: '/2015-03-31/functions/{FunctionName}/versions',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Marker: {
                location: 'querystring',
                locationName: 'Marker',
              },
              MaxItems: {
                location: 'querystring',
                locationName: 'MaxItems',
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              NextMarker: {},
              Versions: {
                shape: 'S7b',
              },
            },
          },
        },
        PublishLayerVersion: {
          http: {
            requestUri: '/2018-10-31/layers/{LayerName}/versions',
            responseCode: 201,
          },
          input: {
            type: 'structure',
            required: ['LayerName', 'Content'],
            members: {
              LayerName: {
                location: 'uri',
                locationName: 'LayerName',
              },
              Description: {},
              Content: {
                type: 'structure',
                members: {
                  S3Bucket: {},
                  S3Key: {},
                  S3ObjectVersion: {},
                  ZipFile: {
                    shape: 'S2h',
                  },
                },
              },
              CompatibleRuntimes: {
                shape: 'S5u',
              },
              LicenseInfo: {},
              CompatibleArchitectures: {
                shape: 'S5w',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              Content: {
                shape: 'S5s',
              },
              LayerArn: {},
              LayerVersionArn: {},
              Description: {},
              CreatedDate: {},
              Version: {
                type: 'long',
              },
              CompatibleRuntimes: {
                shape: 'S5u',
              },
              LicenseInfo: {},
              CompatibleArchitectures: {
                shape: 'S5w',
              },
            },
          },
        },
        PublishVersion: {
          http: {
            requestUri: '/2015-03-31/functions/{FunctionName}/versions',
            responseCode: 201,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              CodeSha256: {},
              Description: {},
              RevisionId: {},
            },
          },
          output: {
            shape: 'S3m',
          },
        },
        PutFunctionCodeSigningConfig: {
          http: {
            method: 'PUT',
            requestUri: '/2020-06-30/functions/{FunctionName}/code-signing-config',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['CodeSigningConfigArn', 'FunctionName'],
            members: {
              CodeSigningConfigArn: {},
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
            },
          },
          output: {
            type: 'structure',
            required: ['CodeSigningConfigArn', 'FunctionName'],
            members: {
              CodeSigningConfigArn: {},
              FunctionName: {},
            },
          },
        },
        PutFunctionConcurrency: {
          http: {
            method: 'PUT',
            requestUri: '/2017-10-31/functions/{FunctionName}/concurrency',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'ReservedConcurrentExecutions'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              ReservedConcurrentExecutions: {
                type: 'integer',
              },
            },
          },
          output: {
            shape: 'S5d',
          },
        },
        PutFunctionEventInvokeConfig: {
          http: {
            method: 'PUT',
            requestUri: '/2019-09-25/functions/{FunctionName}/event-invoke-config',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
              MaximumRetryAttempts: {
                type: 'integer',
              },
              MaximumEventAgeInSeconds: {
                type: 'integer',
              },
              DestinationConfig: {
                shape: 'S1g',
              },
            },
          },
          output: {
            shape: 'S5l',
          },
        },
        PutProvisionedConcurrencyConfig: {
          http: {
            method: 'PUT',
            requestUri: '/2019-09-30/functions/{FunctionName}/provisioned-concurrency',
            responseCode: 202,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'Qualifier', 'ProvisionedConcurrentExecutions'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
              ProvisionedConcurrentExecutions: {
                type: 'integer',
              },
            },
          },
          output: {
            type: 'structure',
            members: {
              RequestedProvisionedConcurrentExecutions: {
                type: 'integer',
              },
              AvailableProvisionedConcurrentExecutions: {
                type: 'integer',
              },
              AllocatedProvisionedConcurrentExecutions: {
                type: 'integer',
              },
              Status: {},
              StatusReason: {},
              LastModified: {},
            },
          },
        },
        PutRuntimeManagementConfig: {
          http: {
            method: 'PUT',
            requestUri: '/2021-07-20/functions/{FunctionName}/runtime-management-config',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'UpdateRuntimeOn'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
              UpdateRuntimeOn: {},
              RuntimeVersionArn: {},
            },
          },
          output: {
            type: 'structure',
            required: ['UpdateRuntimeOn', 'FunctionArn'],
            members: {
              UpdateRuntimeOn: {},
              FunctionArn: {},
              RuntimeVersionArn: {},
            },
          },
        },
        RemoveLayerVersionPermission: {
          http: {
            method: 'DELETE',
            requestUri: '/2018-10-31/layers/{LayerName}/versions/{VersionNumber}/policy/{StatementId}',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['LayerName', 'VersionNumber', 'StatementId'],
            members: {
              LayerName: {
                location: 'uri',
                locationName: 'LayerName',
              },
              VersionNumber: {
                location: 'uri',
                locationName: 'VersionNumber',
                type: 'long',
              },
              StatementId: {
                location: 'uri',
                locationName: 'StatementId',
              },
              RevisionId: {
                location: 'querystring',
                locationName: 'RevisionId',
              },
            },
          },
        },
        RemovePermission: {
          http: {
            method: 'DELETE',
            requestUri: '/2015-03-31/functions/{FunctionName}/policy/{StatementId}',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'StatementId'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              StatementId: {
                location: 'uri',
                locationName: 'StatementId',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
              RevisionId: {
                location: 'querystring',
                locationName: 'RevisionId',
              },
            },
          },
        },
        TagResource: {
          http: {
            requestUri: '/2017-03-31/tags/{ARN}',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['Resource', 'Tags'],
            members: {
              Resource: {
                location: 'uri',
                locationName: 'ARN',
              },
              Tags: {
                shape: 'S34',
              },
            },
          },
        },
        UntagResource: {
          http: {
            method: 'DELETE',
            requestUri: '/2017-03-31/tags/{ARN}',
            responseCode: 204,
          },
          input: {
            type: 'structure',
            required: ['Resource', 'TagKeys'],
            members: {
              Resource: {
                location: 'uri',
                locationName: 'ARN',
              },
              TagKeys: {
                location: 'querystring',
                locationName: 'tagKeys',
                type: 'list',
                member: {},
              },
            },
          },
        },
        UpdateAlias: {
          http: {
            method: 'PUT',
            requestUri: '/2015-03-31/functions/{FunctionName}/aliases/{Name}',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName', 'Name'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Name: {
                location: 'uri',
                locationName: 'Name',
              },
              FunctionVersion: {},
              Description: {},
              RoutingConfig: {
                shape: 'Sp',
              },
              RevisionId: {},
            },
          },
          output: {
            shape: 'St',
          },
        },
        UpdateCodeSigningConfig: {
          http: {
            method: 'PUT',
            requestUri: '/2020-04-22/code-signing-configs/{CodeSigningConfigArn}',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['CodeSigningConfigArn'],
            members: {
              CodeSigningConfigArn: {
                location: 'uri',
                locationName: 'CodeSigningConfigArn',
              },
              Description: {},
              AllowedPublishers: {
                shape: 'Sw',
              },
              CodeSigningPolicies: {
                shape: 'Sy',
              },
            },
          },
          output: {
            type: 'structure',
            required: ['CodeSigningConfig'],
            members: {
              CodeSigningConfig: {
                shape: 'S11',
              },
            },
          },
        },
        UpdateEventSourceMapping: {
          http: {
            method: 'PUT',
            requestUri: '/2015-03-31/event-source-mappings/{UUID}',
            responseCode: 202,
          },
          input: {
            type: 'structure',
            required: ['UUID'],
            members: {
              UUID: {
                location: 'uri',
                locationName: 'UUID',
              },
              FunctionName: {},
              Enabled: {
                type: 'boolean',
              },
              BatchSize: {
                type: 'integer',
              },
              FilterCriteria: {
                shape: 'S18',
              },
              MaximumBatchingWindowInSeconds: {
                type: 'integer',
              },
              DestinationConfig: {
                shape: 'S1g',
              },
              MaximumRecordAgeInSeconds: {
                type: 'integer',
              },
              BisectBatchOnFunctionError: {
                type: 'boolean',
              },
              MaximumRetryAttempts: {
                type: 'integer',
              },
              ParallelizationFactor: {
                type: 'integer',
              },
              SourceAccessConfigurations: {
                shape: 'S1s',
              },
              TumblingWindowInSeconds: {
                type: 'integer',
              },
              FunctionResponseTypes: {
                shape: 'S21',
              },
              ScalingConfig: {
                shape: 'S25',
              },
              DocumentDBEventSourceConfig: {
                shape: 'S27',
              },
            },
          },
          output: {
            shape: 'S2b',
          },
        },
        UpdateFunctionCode: {
          http: {
            method: 'PUT',
            requestUri: '/2015-03-31/functions/{FunctionName}/code',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              ZipFile: {
                shape: 'S2h',
              },
              S3Bucket: {},
              S3Key: {},
              S3ObjectVersion: {},
              ImageUri: {},
              Publish: {
                type: 'boolean',
              },
              DryRun: {
                type: 'boolean',
              },
              RevisionId: {},
              Architectures: {
                shape: 'S3g',
              },
            },
          },
          output: {
            shape: 'S3m',
          },
        },
        UpdateFunctionConfiguration: {
          http: {
            method: 'PUT',
            requestUri: '/2015-03-31/functions/{FunctionName}/configuration',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Role: {},
              Handler: {},
              Description: {},
              Timeout: {
                type: 'integer',
              },
              MemorySize: {
                type: 'integer',
              },
              VpcConfig: {
                shape: 'S2o',
              },
              Environment: {
                shape: 'S2x',
              },
              Runtime: {},
              DeadLetterConfig: {
                shape: 'S2v',
              },
              KMSKeyArn: {},
              TracingConfig: {
                shape: 'S32',
              },
              RevisionId: {},
              Layers: {
                shape: 'S37',
              },
              FileSystemConfigs: {
                shape: 'S39',
              },
              ImageConfig: {
                shape: 'S3d',
              },
              EphemeralStorage: {
                shape: 'S3i',
              },
              SnapStart: {
                shape: 'S3k',
              },
            },
          },
          output: {
            shape: 'S3m',
          },
        },
        UpdateFunctionEventInvokeConfig: {
          http: {
            requestUri: '/2019-09-25/functions/{FunctionName}/event-invoke-config',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
              MaximumRetryAttempts: {
                type: 'integer',
              },
              MaximumEventAgeInSeconds: {
                type: 'integer',
              },
              DestinationConfig: {
                shape: 'S1g',
              },
            },
          },
          output: {
            shape: 'S5l',
          },
        },
        UpdateFunctionUrlConfig: {
          http: {
            method: 'PUT',
            requestUri: '/2021-10-31/functions/{FunctionName}/url',
            responseCode: 200,
          },
          input: {
            type: 'structure',
            required: ['FunctionName'],
            members: {
              FunctionName: {
                location: 'uri',
                locationName: 'FunctionName',
              },
              Qualifier: {
                location: 'querystring',
                locationName: 'Qualifier',
              },
              AuthType: {},
              Cors: {
                shape: 'S4d',
              },
              InvokeMode: {},
            },
          },
          output: {
            type: 'structure',
            required: ['FunctionUrl', 'FunctionArn', 'AuthType', 'CreationTime', 'LastModifiedTime'],
            members: {
              FunctionUrl: {},
              FunctionArn: {},
              AuthType: {},
              Cors: {
                shape: 'S4d',
              },
              CreationTime: {},
              LastModifiedTime: {},
              InvokeMode: {},
            },
          },
        },
      },
      shapes: {
        Sp: {
          type: 'structure',
          members: {
            AdditionalVersionWeights: {
              type: 'map',
              key: {},
              value: {
                type: 'double',
              },
            },
          },
        },
        St: {
          type: 'structure',
          members: {
            AliasArn: {},
            Name: {},
            FunctionVersion: {},
            Description: {},
            RoutingConfig: {
              shape: 'Sp',
            },
            RevisionId: {},
          },
        },
        Sw: {
          type: 'structure',
          required: ['SigningProfileVersionArns'],
          members: {
            SigningProfileVersionArns: {
              type: 'list',
              member: {},
            },
          },
        },
        Sy: {
          type: 'structure',
          members: {
            UntrustedArtifactOnDeployment: {},
          },
        },
        S11: {
          type: 'structure',
          required: [
            'CodeSigningConfigId',
            'CodeSigningConfigArn',
            'AllowedPublishers',
            'CodeSigningPolicies',
            'LastModified',
          ],
          members: {
            CodeSigningConfigId: {},
            CodeSigningConfigArn: {},
            Description: {},
            AllowedPublishers: {
              shape: 'Sw',
            },
            CodeSigningPolicies: {
              shape: 'Sy',
            },
            LastModified: {},
          },
        },
        S18: {
          type: 'structure',
          members: {
            Filters: {
              type: 'list',
              member: {
                type: 'structure',
                members: {
                  Pattern: {},
                },
              },
            },
          },
        },
        S1g: {
          type: 'structure',
          members: {
            OnSuccess: {
              type: 'structure',
              members: {
                Destination: {},
              },
            },
            OnFailure: {
              type: 'structure',
              members: {
                Destination: {},
              },
            },
          },
        },
        S1o: {
          type: 'list',
          member: {},
        },
        S1q: {
          type: 'list',
          member: {},
        },
        S1s: {
          type: 'list',
          member: {
            type: 'structure',
            members: {
              Type: {},
              URI: {},
            },
          },
        },
        S1w: {
          type: 'structure',
          members: {
            Endpoints: {
              type: 'map',
              key: {},
              value: {
                type: 'list',
                member: {},
              },
            },
          },
        },
        S21: {
          type: 'list',
          member: {},
        },
        S23: {
          type: 'structure',
          members: {
            ConsumerGroupId: {},
          },
        },
        S24: {
          type: 'structure',
          members: {
            ConsumerGroupId: {},
          },
        },
        S25: {
          type: 'structure',
          members: {
            MaximumConcurrency: {
              type: 'integer',
            },
          },
        },
        S27: {
          type: 'structure',
          members: {
            DatabaseName: {},
            CollectionName: {},
            FullDocument: {},
          },
        },
        S2b: {
          type: 'structure',
          members: {
            UUID: {},
            StartingPosition: {},
            StartingPositionTimestamp: {
              type: 'timestamp',
            },
            BatchSize: {
              type: 'integer',
            },
            MaximumBatchingWindowInSeconds: {
              type: 'integer',
            },
            ParallelizationFactor: {
              type: 'integer',
            },
            EventSourceArn: {},
            FilterCriteria: {
              shape: 'S18',
            },
            FunctionArn: {},
            LastModified: {
              type: 'timestamp',
            },
            LastProcessingResult: {},
            State: {},
            StateTransitionReason: {},
            DestinationConfig: {
              shape: 'S1g',
            },
            Topics: {
              shape: 'S1o',
            },
            Queues: {
              shape: 'S1q',
            },
            SourceAccessConfigurations: {
              shape: 'S1s',
            },
            SelfManagedEventSource: {
              shape: 'S1w',
            },
            MaximumRecordAgeInSeconds: {
              type: 'integer',
            },
            BisectBatchOnFunctionError: {
              type: 'boolean',
            },
            MaximumRetryAttempts: {
              type: 'integer',
            },
            TumblingWindowInSeconds: {
              type: 'integer',
            },
            FunctionResponseTypes: {
              shape: 'S21',
            },
            AmazonManagedKafkaEventSourceConfig: {
              shape: 'S23',
            },
            SelfManagedKafkaEventSourceConfig: {
              shape: 'S24',
            },
            ScalingConfig: {
              shape: 'S25',
            },
            DocumentDBEventSourceConfig: {
              shape: 'S27',
            },
          },
        },
        S2h: {
          type: 'blob',
          sensitive: true,
        },
        S2o: {
          type: 'structure',
          members: {
            SubnetIds: {
              shape: 'S2p',
            },
            SecurityGroupIds: {
              shape: 'S2r',
            },
            Ipv6AllowedForDualStack: {
              type: 'boolean',
            },
          },
        },
        S2p: {
          type: 'list',
          member: {},
        },
        S2r: {
          type: 'list',
          member: {},
        },
        S2v: {
          type: 'structure',
          members: {
            TargetArn: {},
          },
        },
        S2x: {
          type: 'structure',
          members: {
            Variables: {
              shape: 'S2y',
            },
          },
        },
        S2y: {
          type: 'map',
          key: {
            type: 'string',
            sensitive: true,
          },
          value: {
            type: 'string',
            sensitive: true,
          },
          sensitive: true,
        },
        S32: {
          type: 'structure',
          members: {
            Mode: {},
          },
        },
        S34: {
          type: 'map',
          key: {},
          value: {},
        },
        S37: {
          type: 'list',
          member: {},
        },
        S39: {
          type: 'list',
          member: {
            type: 'structure',
            required: ['Arn', 'LocalMountPath'],
            members: {
              Arn: {},
              LocalMountPath: {},
            },
          },
        },
        S3d: {
          type: 'structure',
          members: {
            EntryPoint: {
              shape: 'S3e',
            },
            Command: {
              shape: 'S3e',
            },
            WorkingDirectory: {},
          },
        },
        S3e: {
          type: 'list',
          member: {},
        },
        S3g: {
          type: 'list',
          member: {},
        },
        S3i: {
          type: 'structure',
          required: ['Size'],
          members: {
            Size: {
              type: 'integer',
            },
          },
        },
        S3k: {
          type: 'structure',
          members: {
            ApplyOn: {},
          },
        },
        S3m: {
          type: 'structure',
          members: {
            FunctionName: {},
            FunctionArn: {},
            Runtime: {},
            Role: {},
            Handler: {},
            CodeSize: {
              type: 'long',
            },
            Description: {},
            Timeout: {
              type: 'integer',
            },
            MemorySize: {
              type: 'integer',
            },
            LastModified: {},
            CodeSha256: {},
            Version: {},
            VpcConfig: {
              type: 'structure',
              members: {
                SubnetIds: {
                  shape: 'S2p',
                },
                SecurityGroupIds: {
                  shape: 'S2r',
                },
                VpcId: {},
                Ipv6AllowedForDualStack: {
                  type: 'boolean',
                },
              },
            },
            DeadLetterConfig: {
              shape: 'S2v',
            },
            Environment: {
              type: 'structure',
              members: {
                Variables: {
                  shape: 'S2y',
                },
                Error: {
                  type: 'structure',
                  members: {
                    ErrorCode: {},
                    Message: {
                      shape: 'S3u',
                    },
                  },
                },
              },
            },
            KMSKeyArn: {},
            TracingConfig: {
              type: 'structure',
              members: {
                Mode: {},
              },
            },
            MasterArn: {},
            RevisionId: {},
            Layers: {
              type: 'list',
              member: {
                type: 'structure',
                members: {
                  Arn: {},
                  CodeSize: {
                    type: 'long',
                  },
                  SigningProfileVersionArn: {},
                  SigningJobArn: {},
                },
              },
            },
            State: {},
            StateReason: {},
            StateReasonCode: {},
            LastUpdateStatus: {},
            LastUpdateStatusReason: {},
            LastUpdateStatusReasonCode: {},
            FileSystemConfigs: {
              shape: 'S39',
            },
            PackageType: {},
            ImageConfigResponse: {
              type: 'structure',
              members: {
                ImageConfig: {
                  shape: 'S3d',
                },
                Error: {
                  type: 'structure',
                  members: {
                    ErrorCode: {},
                    Message: {
                      shape: 'S3u',
                    },
                  },
                },
              },
            },
            SigningProfileVersionArn: {},
            SigningJobArn: {},
            Architectures: {
              shape: 'S3g',
            },
            EphemeralStorage: {
              shape: 'S3i',
            },
            SnapStart: {
              type: 'structure',
              members: {
                ApplyOn: {},
                OptimizationStatus: {},
              },
            },
            RuntimeVersionConfig: {
              type: 'structure',
              members: {
                RuntimeVersionArn: {},
                Error: {
                  type: 'structure',
                  members: {
                    ErrorCode: {},
                    Message: {
                      shape: 'S3u',
                    },
                  },
                },
              },
            },
          },
        },
        S3u: {
          type: 'string',
          sensitive: true,
        },
        S4d: {
          type: 'structure',
          members: {
            AllowCredentials: {
              type: 'boolean',
            },
            AllowHeaders: {
              shape: 'S4f',
            },
            AllowMethods: {
              type: 'list',
              member: {},
            },
            AllowOrigins: {
              type: 'list',
              member: {},
            },
            ExposeHeaders: {
              shape: 'S4f',
            },
            MaxAge: {
              type: 'integer',
            },
          },
        },
        S4f: {
          type: 'list',
          member: {},
        },
        S5d: {
          type: 'structure',
          members: {
            ReservedConcurrentExecutions: {
              type: 'integer',
            },
          },
        },
        S5l: {
          type: 'structure',
          members: {
            LastModified: {
              type: 'timestamp',
            },
            FunctionArn: {},
            MaximumRetryAttempts: {
              type: 'integer',
            },
            MaximumEventAgeInSeconds: {
              type: 'integer',
            },
            DestinationConfig: {
              shape: 'S1g',
            },
          },
        },
        S5r: {
          type: 'structure',
          members: {
            Content: {
              shape: 'S5s',
            },
            LayerArn: {},
            LayerVersionArn: {},
            Description: {},
            CreatedDate: {},
            Version: {
              type: 'long',
            },
            CompatibleRuntimes: {
              shape: 'S5u',
            },
            LicenseInfo: {},
            CompatibleArchitectures: {
              shape: 'S5w',
            },
          },
        },
        S5s: {
          type: 'structure',
          members: {
            Location: {},
            CodeSha256: {},
            CodeSize: {
              type: 'long',
            },
            SigningProfileVersionArn: {},
            SigningJobArn: {},
          },
        },
        S5u: {
          type: 'list',
          member: {},
        },
        S5w: {
          type: 'list',
          member: {},
        },
        S7b: {
          type: 'list',
          member: {
            shape: 'S3m',
          },
        },
        S7j: {
          type: 'structure',
          members: {
            LayerVersionArn: {},
            Version: {
              type: 'long',
            },
            Description: {},
            CreatedDate: {},
            CompatibleRuntimes: {
              shape: 'S5u',
            },
            LicenseInfo: {},
            CompatibleArchitectures: {
              shape: 'S5w',
            },
          },
        },
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/lambda-2015-03-31.paginators.json
var require_lambda_2015_03_31_paginators = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/lambda-2015-03-31.paginators.json'(exports, module2) {
    module2.exports = {
      pagination: {
        ListAliases: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'Aliases',
        },
        ListCodeSigningConfigs: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'CodeSigningConfigs',
        },
        ListEventSourceMappings: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'EventSourceMappings',
        },
        ListFunctionEventInvokeConfigs: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'FunctionEventInvokeConfigs',
        },
        ListFunctionUrlConfigs: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'FunctionUrlConfigs',
        },
        ListFunctions: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'Functions',
        },
        ListFunctionsByCodeSigningConfig: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'FunctionArns',
        },
        ListLayerVersions: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'LayerVersions',
        },
        ListLayers: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'Layers',
        },
        ListProvisionedConcurrencyConfigs: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'ProvisionedConcurrencyConfigs',
        },
        ListVersionsByFunction: {
          input_token: 'Marker',
          limit_key: 'MaxItems',
          output_token: 'NextMarker',
          result_key: 'Versions',
        },
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/lambda-2015-03-31.waiters2.json
var require_lambda_2015_03_31_waiters2 = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/apis/lambda-2015-03-31.waiters2.json'(exports, module2) {
    module2.exports = {
      version: 2,
      waiters: {
        FunctionExists: {
          delay: 1,
          operation: 'GetFunction',
          maxAttempts: 20,
          acceptors: [
            {
              state: 'success',
              matcher: 'status',
              expected: 200,
            },
            {
              state: 'retry',
              matcher: 'error',
              expected: 'ResourceNotFoundException',
            },
          ],
        },
        FunctionActive: {
          delay: 5,
          maxAttempts: 60,
          operation: 'GetFunctionConfiguration',
          description:
            "Waits for the function's State to be Active. This waiter uses GetFunctionConfiguration API. This should be used after new function creation.",
          acceptors: [
            {
              state: 'success',
              matcher: 'path',
              argument: 'State',
              expected: 'Active',
            },
            {
              state: 'failure',
              matcher: 'path',
              argument: 'State',
              expected: 'Failed',
            },
            {
              state: 'retry',
              matcher: 'path',
              argument: 'State',
              expected: 'Pending',
            },
          ],
        },
        FunctionUpdated: {
          delay: 5,
          maxAttempts: 60,
          operation: 'GetFunctionConfiguration',
          description:
            "Waits for the function's LastUpdateStatus to be Successful. This waiter uses GetFunctionConfiguration API. This should be used after function updates.",
          acceptors: [
            {
              state: 'success',
              matcher: 'path',
              argument: 'LastUpdateStatus',
              expected: 'Successful',
            },
            {
              state: 'failure',
              matcher: 'path',
              argument: 'LastUpdateStatus',
              expected: 'Failed',
            },
            {
              state: 'retry',
              matcher: 'path',
              argument: 'LastUpdateStatus',
              expected: 'InProgress',
            },
          ],
        },
        FunctionActiveV2: {
          delay: 1,
          maxAttempts: 300,
          operation: 'GetFunction',
          description:
            "Waits for the function's State to be Active. This waiter uses GetFunction API. This should be used after new function creation.",
          acceptors: [
            {
              state: 'success',
              matcher: 'path',
              argument: 'Configuration.State',
              expected: 'Active',
            },
            {
              state: 'failure',
              matcher: 'path',
              argument: 'Configuration.State',
              expected: 'Failed',
            },
            {
              state: 'retry',
              matcher: 'path',
              argument: 'Configuration.State',
              expected: 'Pending',
            },
          ],
        },
        FunctionUpdatedV2: {
          delay: 1,
          maxAttempts: 300,
          operation: 'GetFunction',
          description:
            "Waits for the function's LastUpdateStatus to be Successful. This waiter uses GetFunction API. This should be used after function updates.",
          acceptors: [
            {
              state: 'success',
              matcher: 'path',
              argument: 'Configuration.LastUpdateStatus',
              expected: 'Successful',
            },
            {
              state: 'failure',
              matcher: 'path',
              argument: 'Configuration.LastUpdateStatus',
              expected: 'Failed',
            },
            {
              state: 'retry',
              matcher: 'path',
              argument: 'Configuration.LastUpdateStatus',
              expected: 'InProgress',
            },
          ],
        },
        PublishedVersionActive: {
          delay: 5,
          maxAttempts: 312,
          operation: 'GetFunctionConfiguration',
          description:
            "Waits for the published version's State to be Active. This waiter uses GetFunctionConfiguration API. This should be used after new version is published.",
          acceptors: [
            {
              state: 'success',
              matcher: 'path',
              argument: 'State',
              expected: 'Active',
            },
            {
              state: 'failure',
              matcher: 'path',
              argument: 'State',
              expected: 'Failed',
            },
            {
              state: 'retry',
              matcher: 'path',
              argument: 'State',
              expected: 'Pending',
            },
          ],
        },
      },
    };
  },
});

// node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/clients/lambda.js
var require_lambda2 = __commonJS({
  'node_modules/.pnpm/aws-sdk@2.1483.0/node_modules/aws-sdk/clients/lambda.js'(exports, module2) {
    require_node_loader();
    var AWS3 = require_core();
    var Service = AWS3.Service;
    var apiLoader = AWS3.apiLoader;
    apiLoader.services['lambda'] = {};
    AWS3.Lambda = Service.defineService('lambda', ['2014-11-11', '2015-03-31']);
    require_lambda();
    Object.defineProperty(apiLoader.services['lambda'], '2014-11-11', {
      get: function get() {
        var model = require_lambda_2014_11_11_min();
        model.paginators = require_lambda_2014_11_11_paginators().pagination;
        return model;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(apiLoader.services['lambda'], '2015-03-31', {
      get: function get() {
        var model = require_lambda_2015_03_31_min();
        model.paginators = require_lambda_2015_03_31_paginators().pagination;
        model.waiters = require_lambda_2015_03_31_waiters2().waiters;
        return model;
      },
      enumerable: true,
      configurable: true,
    });
    module2.exports = AWS3.Lambda;
  },
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/utils.js
var require_utils2 = __commonJS({
  'node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/utils.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.toCommandProperties = exports.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return '';
      } else if (typeof input === 'string' || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn,
      };
    }
    exports.toCommandProperties = toCommandProperties;
  },
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  'node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/command.js'(exports) {
    'use strict';
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            Object.defineProperty(o, k2, {
              enumerable: true,
              get: function () {
                return m[k];
              },
            });
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports && exports.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, 'default', { enumerable: true, value: v });
          }
        : function (o, v) {
            o['default'] = v;
          });
    var __importStar =
      (exports && exports.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== 'default' && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.issue = exports.issueCommand = void 0;
    var os = __importStar(require('os'));
    var utils_1 = require_utils2();
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os.EOL);
    }
    exports.issueCommand = issueCommand;
    function issue(name, message = '') {
      issueCommand(name, {}, message);
    }
    exports.issue = issue;
    var CMD_STRING = '::';
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += ' ';
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ',';
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s) {
      return utils_1.toCommandValue(s).replace(/%/g, '%25').replace(/\r/g, '%0D').replace(/\n/g, '%0A');
    }
    function escapeProperty(s) {
      return utils_1
        .toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
    }
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/rng.js
var require_rng2 = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/rng.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = rng;
    var _crypto = _interopRequireDefault(require('crypto'));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, (poolPtr += 16));
    }
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/regex.js
var require_regex = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/regex.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _default =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/validate.js
var require_validate = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/validate.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === 'string' && _regex.default.test(uuid);
    }
    var _default = validate;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/stringify.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    function stringify(arr, offset = 0) {
      const uuid = (
        byteToHex[arr[offset + 0]] +
        byteToHex[arr[offset + 1]] +
        byteToHex[arr[offset + 2]] +
        byteToHex[arr[offset + 3]] +
        '-' +
        byteToHex[arr[offset + 4]] +
        byteToHex[arr[offset + 5]] +
        '-' +
        byteToHex[arr[offset + 6]] +
        byteToHex[arr[offset + 7]] +
        '-' +
        byteToHex[arr[offset + 8]] +
        byteToHex[arr[offset + 9]] +
        '-' +
        byteToHex[arr[offset + 10]] +
        byteToHex[arr[offset + 11]] +
        byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] +
        byteToHex[arr[offset + 14]] +
        byteToHex[arr[offset + 15]]
      ).toLowerCase();
      if (!(0, _validate.default)(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }
      return uuid;
    }
    var _default = stringify;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v1.js
var require_v12 = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v1.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng2());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = (buf && offset) || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = ((seedBytes[6] << 8) | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = (clockseq + 1) & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = (tl >>> 24) & 255;
      b[i++] = (tl >>> 16) & 255;
      b[i++] = (tl >>> 8) & 255;
      b[i++] = tl & 255;
      const tmh = ((msecs / 4294967296) * 1e4) & 268435455;
      b[i++] = (tmh >>> 8) & 255;
      b[i++] = tmh & 255;
      b[i++] = ((tmh >>> 24) & 15) | 16;
      b[i++] = (tmh >>> 16) & 255;
      b[i++] = (clockseq >>> 8) | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.default)(b);
    }
    var _default = v1;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/parse.js
var require_parse = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/parse.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError('Invalid UUID');
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = (v >>> 16) & 255;
      arr[2] = (v >>> 8) & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776) & 255;
      arr[11] = (v / 4294967296) & 255;
      arr[12] = (v >>> 24) & 255;
      arr[13] = (v >>> 16) & 255;
      arr[14] = (v >>> 8) & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v35.js
var require_v352 = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v35.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = _default;
    exports.URL = exports.DNS = void 0;
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    exports.DNS = DNS;
    var URL2 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
    exports.URL = URL2;
    function _default(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === 'string') {
          value = stringToBytes(value);
        }
        if (typeof namespace === 'string') {
          namespace = (0, _parse.default)(namespace);
        }
        if (namespace.length !== 16) {
          throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = (bytes[6] & 15) | version;
        bytes[8] = (bytes[8] & 63) | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.default)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {}
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/md5.js
var require_md52 = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/md5.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require('crypto'));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
      }
      return _crypto.default.createHash('md5').update(bytes).digest();
    }
    var _default = md5;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v3.js
var require_v33 = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v3.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v352());
    var _md = _interopRequireDefault(require_md52());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)('v3', 48, _md.default);
    var _default = v3;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v4.js
var require_v43 = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v4.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng2());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = (rnds[6] & 15) | 64;
      rnds[8] = (rnds[8] & 63) | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.default)(rnds);
    }
    var _default = v4;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/sha1.js
var require_sha12 = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/sha1.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require('crypto'));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
      }
      return _crypto.default.createHash('sha1').update(bytes).digest();
    }
    var _default = sha1;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v5.js
var require_v52 = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/v5.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v352());
    var _sha = _interopRequireDefault(require_sha12());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)('v5', 80, _sha.default);
    var _default = v5;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/nil.js
var require_nil = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/nil.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _default = '00000000-0000-0000-0000-000000000000';
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/version.js
var require_version = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/version.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError('Invalid UUID');
      }
      return parseInt(uuid.substr(14, 1), 16);
    }
    var _default = version;
    exports.default = _default;
  },
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/index.js
var require_dist2 = __commonJS({
  'node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/index.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'v1', {
      enumerable: true,
      get: function () {
        return _v.default;
      },
    });
    Object.defineProperty(exports, 'v3', {
      enumerable: true,
      get: function () {
        return _v2.default;
      },
    });
    Object.defineProperty(exports, 'v4', {
      enumerable: true,
      get: function () {
        return _v3.default;
      },
    });
    Object.defineProperty(exports, 'v5', {
      enumerable: true,
      get: function () {
        return _v4.default;
      },
    });
    Object.defineProperty(exports, 'NIL', {
      enumerable: true,
      get: function () {
        return _nil.default;
      },
    });
    Object.defineProperty(exports, 'version', {
      enumerable: true,
      get: function () {
        return _version.default;
      },
    });
    Object.defineProperty(exports, 'validate', {
      enumerable: true,
      get: function () {
        return _validate.default;
      },
    });
    Object.defineProperty(exports, 'stringify', {
      enumerable: true,
      get: function () {
        return _stringify.default;
      },
    });
    Object.defineProperty(exports, 'parse', {
      enumerable: true,
      get: function () {
        return _parse.default;
      },
    });
    var _v = _interopRequireDefault(require_v12());
    var _v2 = _interopRequireDefault(require_v33());
    var _v3 = _interopRequireDefault(require_v43());
    var _v4 = _interopRequireDefault(require_v52());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  },
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  'node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/file-command.js'(exports) {
    'use strict';
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            Object.defineProperty(o, k2, {
              enumerable: true,
              get: function () {
                return m[k];
              },
            });
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports && exports.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, 'default', { enumerable: true, value: v });
          }
        : function (o, v) {
            o['default'] = v;
          });
    var __importStar =
      (exports && exports.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== 'default' && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
    var fs = __importStar(require('fs'));
    var os = __importStar(require('os'));
    var uuid_1 = require_dist2();
    var utils_1 = require_utils2();
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8',
      });
    }
    exports.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${uuid_1.v4()}`;
      const convertedValue = utils_1.toCommandValue(value);
      if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      }
      return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
    }
    exports.prepareKeyValueMessage = prepareKeyValueMessage;
  },
});

// node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  'node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/proxy.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.checkBypass = exports.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === 'https:';
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        } else {
          return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
      })();
      if (proxyVar) {
        try {
          return new URL(proxyVar);
        } catch (_a) {
          if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://')) return new URL(`http://${proxyVar}`);
        }
      } else {
        return void 0;
      }
    }
    exports.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
      } else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy
        .split(',')
        .map((x) => x.trim().toUpperCase())
        .filter((x) => x)) {
        if (
          upperNoProxyItem === '*' ||
          upperReqHosts.some(
            (x) =>
              x === upperNoProxyItem ||
              x.endsWith(`.${upperNoProxyItem}`) ||
              (upperNoProxyItem.startsWith('.') && x.endsWith(`${upperNoProxyItem}`))
          )
        ) {
          return true;
        }
      }
      return false;
    }
    exports.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return (
        hostLower === 'localhost' ||
        hostLower.startsWith('127.') ||
        hostLower.startsWith('[::1]') ||
        hostLower.startsWith('[0:0:0:0:0:0:0:1]')
      );
    }
  },
});

// node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  'node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js'(exports) {
    'use strict';
    var net = require('net');
    var tls = require('tls');
    var http = require('http');
    var https2 = require('https');
    var events = require('events');
    var assert = require('assert');
    var util = require('util');
    exports.httpOverHttp = httpOverHttp;
    exports.httpsOverHttp = httpsOverHttp;
    exports.httpOverHttps = httpOverHttps;
    exports.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https2.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https2.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self = this;
      self.options = options || {};
      self.proxyOptions = self.options.proxy || {};
      self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
      self.requests = [];
      self.sockets = [];
      self.on('free', function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i = 0, len = self.requests.length; i < len; ++i) {
          var pending = self.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self = this;
      var options = mergeOptions({ request: req }, self.options, toOptions(host, port, localAddress));
      if (self.sockets.length >= this.maxSockets) {
        self.requests.push(options);
        return;
      }
      self.createSocket(options, function (socket) {
        socket.on('free', onFree);
        socket.on('close', onCloseOrRemove);
        socket.on('agentRemove', onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self.emit('free', socket, options);
        }
        function onCloseOrRemove(err) {
          self.removeSocket(socket);
          socket.removeListener('free', onFree);
          socket.removeListener('close', onCloseOrRemove);
          socket.removeListener('agentRemove', onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self = this;
      var placeholder = {};
      self.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self.proxyOptions, {
        method: 'CONNECT',
        path: options.host + ':' + options.port,
        agent: false,
        headers: {
          host: options.host + ':' + options.port,
        },
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers['Proxy-Authorization'] =
          'Basic ' + new Buffer(connectOptions.proxyAuth).toString('base64');
      }
      debug('making CONNECT request');
      var connectReq = self.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once('response', onResponse);
      connectReq.once('upgrade', onUpgrade);
      connectReq.once('connect', onConnect);
      connectReq.once('error', onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function () {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug('tunneling socket could not be established, statusCode=%d', res.statusCode);
          socket.destroy();
          var error = new Error('tunneling socket could not be established, statusCode=' + res.statusCode);
          error.code = 'ECONNRESET';
          options.request.emit('error', error);
          self.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug('got illegal response body from proxy');
          socket.destroy();
          var error = new Error('got illegal response body from proxy');
          error.code = 'ECONNRESET';
          options.request.emit('error', error);
          self.removeSocket(placeholder);
          return;
        }
        debug('tunneling connection has established');
        self.sockets[self.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack);
        var error = new Error('tunneling socket could not be established, cause=' + cause.message);
        error.code = 'ECONNRESET';
        options.request.emit('error', error);
        self.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function (socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self = this;
      TunnelingAgent.prototype.createSocket.call(self, options, function (socket) {
        var hostHeader = options.request.getHeader('host');
        var tlsOptions = mergeOptions({}, self.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host,
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self.sockets[self.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === 'string') {
        return {
          host,
          port,
          localAddress,
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === 'object') {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function () {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === 'string') {
          args[0] = 'TUNNEL: ' + args[0];
        } else {
          args.unshift('TUNNEL:');
        }
        console.error.apply(console, args);
      };
    } else {
      debug = function () {};
    }
    exports.debug = debug;
  },
});

// node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  'node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js'(exports, module2) {
    module2.exports = require_tunnel();
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/core/symbols.js'(exports, module2) {
    module2.exports = {
      kClose: Symbol('close'),
      kDestroy: Symbol('destroy'),
      kDispatch: Symbol('dispatch'),
      kUrl: Symbol('url'),
      kWriting: Symbol('writing'),
      kResuming: Symbol('resuming'),
      kQueue: Symbol('queue'),
      kConnect: Symbol('connect'),
      kConnecting: Symbol('connecting'),
      kHeadersList: Symbol('headers list'),
      kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),
      kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),
      kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),
      kKeepAliveTimeoutValue: Symbol('keep alive timeout'),
      kKeepAlive: Symbol('keep alive'),
      kHeadersTimeout: Symbol('headers timeout'),
      kBodyTimeout: Symbol('body timeout'),
      kServerName: Symbol('server name'),
      kLocalAddress: Symbol('local address'),
      kHost: Symbol('host'),
      kNoRef: Symbol('no ref'),
      kBodyUsed: Symbol('used'),
      kRunning: Symbol('running'),
      kBlocking: Symbol('blocking'),
      kPending: Symbol('pending'),
      kSize: Symbol('size'),
      kBusy: Symbol('busy'),
      kQueued: Symbol('queued'),
      kFree: Symbol('free'),
      kConnected: Symbol('connected'),
      kClosed: Symbol('closed'),
      kNeedDrain: Symbol('need drain'),
      kReset: Symbol('reset'),
      kDestroyed: Symbol.for('nodejs.stream.destroyed'),
      kMaxHeadersSize: Symbol('max headers size'),
      kRunningIdx: Symbol('running index'),
      kPendingIdx: Symbol('pending index'),
      kError: Symbol('error'),
      kClients: Symbol('clients'),
      kClient: Symbol('client'),
      kParser: Symbol('parser'),
      kOnDestroyed: Symbol('destroy callbacks'),
      kPipelining: Symbol('pipelining'),
      kSocket: Symbol('socket'),
      kHostHeader: Symbol('host header'),
      kConnector: Symbol('connector'),
      kStrictContentLength: Symbol('strict content length'),
      kMaxRedirections: Symbol('maxRedirections'),
      kMaxRequests: Symbol('maxRequestsPerClient'),
      kProxy: Symbol('proxy agent options'),
      kCounter: Symbol('socket request counter'),
      kInterceptors: Symbol('dispatch interceptors'),
      kMaxResponseSize: Symbol('max response size'),
      kHTTP2Session: Symbol('http2Session'),
      kHTTP2SessionState: Symbol('http2Session state'),
      kHTTP2BuildRequest: Symbol('http2 build request'),
      kHTTP1BuildRequest: Symbol('http1 build request'),
      kHTTP2CopyHeaders: Symbol('http2 copy headers'),
      kHTTPConnVersion: Symbol('http connection version'),
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/core/errors.js'(exports, module2) {
    'use strict';
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = 'UndiciError';
        this.code = 'UND_ERR';
      }
    };
    var ConnectTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ConnectTimeoutError);
        this.name = 'ConnectTimeoutError';
        this.message = message || 'Connect Timeout Error';
        this.code = 'UND_ERR_CONNECT_TIMEOUT';
      }
    };
    var HeadersTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersTimeoutError);
        this.name = 'HeadersTimeoutError';
        this.message = message || 'Headers Timeout Error';
        this.code = 'UND_ERR_HEADERS_TIMEOUT';
      }
    };
    var HeadersOverflowError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersOverflowError);
        this.name = 'HeadersOverflowError';
        this.message = message || 'Headers Overflow Error';
        this.code = 'UND_ERR_HEADERS_OVERFLOW';
      }
    };
    var BodyTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, BodyTimeoutError);
        this.name = 'BodyTimeoutError';
        this.message = message || 'Body Timeout Error';
        this.code = 'UND_ERR_BODY_TIMEOUT';
      }
    };
    var ResponseStatusCodeError = class extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, ResponseStatusCodeError);
        this.name = 'ResponseStatusCodeError';
        this.message = message || 'Response Status Code Error';
        this.code = 'UND_ERR_RESPONSE_STATUS_CODE';
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidArgumentError);
        this.name = 'InvalidArgumentError';
        this.message = message || 'Invalid Argument Error';
        this.code = 'UND_ERR_INVALID_ARG';
      }
    };
    var InvalidReturnValueError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidReturnValueError);
        this.name = 'InvalidReturnValueError';
        this.message = message || 'Invalid Return Value Error';
        this.code = 'UND_ERR_INVALID_RETURN_VALUE';
      }
    };
    var RequestAbortedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestAbortedError);
        this.name = 'AbortError';
        this.message = message || 'Request aborted';
        this.code = 'UND_ERR_ABORTED';
      }
    };
    var InformationalError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InformationalError);
        this.name = 'InformationalError';
        this.message = message || 'Request information';
        this.code = 'UND_ERR_INFO';
      }
    };
    var RequestContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestContentLengthMismatchError);
        this.name = 'RequestContentLengthMismatchError';
        this.message = message || 'Request body length does not match content-length header';
        this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH';
      }
    };
    var ResponseContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ResponseContentLengthMismatchError);
        this.name = 'ResponseContentLengthMismatchError';
        this.message = message || 'Response body length does not match content-length header';
        this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH';
      }
    };
    var ClientDestroyedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientDestroyedError);
        this.name = 'ClientDestroyedError';
        this.message = message || 'The client is destroyed';
        this.code = 'UND_ERR_DESTROYED';
      }
    };
    var ClientClosedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientClosedError);
        this.name = 'ClientClosedError';
        this.message = message || 'The client is closed';
        this.code = 'UND_ERR_CLOSED';
      }
    };
    var SocketError = class extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, SocketError);
        this.name = 'SocketError';
        this.message = message || 'Socket error';
        this.code = 'UND_ERR_SOCKET';
        this.socket = socket;
      }
    };
    var NotSupportedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = 'NotSupportedError';
        this.message = message || 'Not supported error';
        this.code = 'UND_ERR_NOT_SUPPORTED';
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = 'MissingUpstreamError';
        this.message = message || 'No upstream has been added to the BalancedPool';
        this.code = 'UND_ERR_BPL_MISSING_UPSTREAM';
      }
    };
    var HTTPParserError = class extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, HTTPParserError);
        this.name = 'HTTPParserError';
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ResponseExceededMaxSizeError);
        this.name = 'ResponseExceededMaxSizeError';
        this.message = message || 'Response content exceeded max size';
        this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE';
      }
    };
    module2.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/core/util.js
var require_util2 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/core/util.js'(exports, module2) {
    'use strict';
    var assert = require('assert');
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = require('http');
    var stream = require('stream');
    var net = require('net');
    var { InvalidArgumentError } = require_errors();
    var { Blob: Blob2 } = require('buffer');
    var nodeUtil = require('util');
    var { stringify } = require('querystring');
    var [nodeMajor, nodeMinor] = process.versions.node.split('.').map((v) => Number(v));
    function nop() {}
    function isStream(obj) {
      return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function';
    }
    function isBlobLike(object) {
      return (
        (Blob2 && object instanceof Blob2) ||
        (object &&
          typeof object === 'object' &&
          (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') &&
          /^(Blob|File)$/.test(object[Symbol.toStringTag]))
      );
    }
    function buildURL(url, queryParams) {
      if (url.includes('?') || url.includes('#')) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url += '?' + stringified;
      }
      return url;
    }
    function parseURL(url) {
      if (typeof url === 'string') {
        url = new URL(url);
        if (!/^https?:/.test(url.origin || url.protocol)) {
          throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.');
        }
        return url;
      }
      if (!url || typeof url !== 'object') {
        throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.');
      }
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.');
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {
          throw new InvalidArgumentError(
            'Invalid URL: port must be a valid integer or a string representation of an integer.'
          );
        }
        if (url.path != null && typeof url.path !== 'string') {
          throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.');
        }
        if (url.pathname != null && typeof url.pathname !== 'string') {
          throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.');
        }
        if (url.hostname != null && typeof url.hostname !== 'string') {
          throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.');
        }
        if (url.origin != null && typeof url.origin !== 'string') {
          throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.');
        }
        const port = url.port != null ? url.port : url.protocol === 'https:' ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
        let path = url.path != null ? url.path : `${url.pathname || ''}${url.search || ''}`;
        if (origin.endsWith('/')) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path && !path.startsWith('/')) {
          path = `/${path}`;
        }
        url = new URL(origin + path);
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== '/' || url.search || url.hash) {
        throw new InvalidArgumentError('invalid url');
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === '[') {
        const idx2 = host.indexOf(']');
        assert(idx2 !== -1);
        return host.substr(1, idx2 - 1);
      }
      const idx = host.indexOf(':');
      if (idx === -1) return host;
      return host.substr(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert.strictEqual(typeof host, 'string');
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return '';
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function');
    }
    function isIterable(obj) {
      return !!(
        obj != null &&
        (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function')
      );
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)
          ? state.length
          : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      if (!isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === 'function') {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        process.nextTick(
          (stream3, err2) => {
            stream3.emit('error', err2);
          },
          stream2,
          err
        );
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers)) return headers;
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1];
          } else {
            obj[key] = headers[i + 1].toString('utf8');
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString('utf8'));
        }
      }
      if ('content-length' in obj && 'content-disposition' in obj) {
        obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1');
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0].toString();
        const val = headers[n + 1].toString('utf8');
        if (key.length === 14 && (key === 'content-length' || key.toLowerCase() === 'content-length')) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (
          key.length === 19 &&
          (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')
        ) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1');
      }
      return ret;
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== 'object') {
        throw new InvalidArgumentError('handler must be an object');
      }
      if (typeof handler.onConnect !== 'function') {
        throw new InvalidArgumentError('invalid onConnect method');
      }
      if (typeof handler.onError !== 'function') {
        throw new InvalidArgumentError('invalid onError method');
      }
      if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError('invalid onBodySent method');
      }
      if (upgrade || method === 'CONNECT') {
        if (typeof handler.onUpgrade !== 'function') {
          throw new InvalidArgumentError('invalid onUpgrade method');
        }
      } else {
        if (typeof handler.onHeaders !== 'function') {
          throw new InvalidArgumentError('invalid onHeaders method');
        }
        if (typeof handler.onData !== 'function') {
          throw new InvalidArgumentError('invalid onData method');
        }
        if (typeof handler.onComplete !== 'function') {
          throw new InvalidArgumentError('invalid onComplete method');
        }
      }
    }
    function isDisturbed(body) {
      return !!(
        body &&
        (stream.isDisturbed
          ? stream.isDisturbed(body) || body[kBodyUsed]
          : body[kBodyUsed] ||
            body.readableDidRead ||
            (body._readableState && body._readableState.dataEmitted) ||
            isReadableAborted(body))
      );
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
    }
    function isReadable(body) {
      return !!(
        body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body)))
      );
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead,
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (const chunk of iterable) {
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = require('stream/web').ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(convertIterableToBuffer(iterable));
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
        },
        0
      );
    }
    function isFormDataLike(object) {
      return (
        object &&
        typeof object === 'object' &&
        typeof object.append === 'function' &&
        typeof object.delete === 'function' &&
        typeof object.get === 'function' &&
        typeof object.getAll === 'function' &&
        typeof object.has === 'function' &&
        typeof object.set === 'function' &&
        object[Symbol.toStringTag] === 'FormData'
      );
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === 'function') {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error('The operation was aborted');
          err.name = 'AbortError';
          throw err;
        }
      }
    }
    var events;
    function addAbortListener(signal, listener) {
      if (typeof Symbol.dispose === 'symbol') {
        if (!events) {
          events = require('events');
        }
        if (typeof events.addAbortListener === 'function' && 'aborted' in signal) {
          return events.addAbortListener(signal, listener);
        }
      }
      if ('addEventListener' in signal) {
        signal.addEventListener('abort', listener, { once: true });
        return () => signal.removeEventListener('abort', listener);
      }
      signal.addListener('abort', listener);
      return () => signal.removeListener('abort', listener);
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil.toUSVString) {
        return nodeUtil.toUSVString(val);
      }
      return `${val}`;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 13),
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/timers.js'(exports, module2) {
    'use strict';
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }
        if (timer.state === -1) {
          timer.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module2.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      },
    };
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js'(exports, module2) {
    'use strict';
    var EventEmitter = require('events').EventEmitter;
    var inherits = require('util').inherits;
    function SBMH(needle) {
      if (typeof needle === 'string') {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError('The needle has to be a String or a Buffer.');
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error('The needle cannot be an empty String/Buffer.');
      }
      if (needleLength > 256) {
        throw new Error('The needle cannot have a length bigger than 256.');
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i = 0; i < needleLength - 1; ++i) {
        this._occ[needle[i]] = needleLength - 1 - i;
      }
    }
    inherits(SBMH, EventEmitter);
    SBMH.prototype.reset = function () {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function (chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, 'binary');
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk);
      }
      return r;
    };
    SBMH.prototype._sbmh_feed = function (data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit('info', true);
            return (this._bufpos = pos + needleLength);
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit('info', false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit('info', false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit('info', true, data, this._bufpos, pos);
        } else {
          this.emit('info', true);
        }
        return (this._bufpos = pos + needleLength);
      } else {
        pos = len - needleLength;
      }
      while (
        pos < len &&
        (data[pos] !== needle[0] ||
          Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0)
      ) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit('info', false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function (data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function (data, pos, len) {
      for (var i = 0; i < len; ++i) {
        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
          return false;
        }
      }
      return true;
    };
    module2.exports = SBMH;
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js'(
    exports,
    module2
  ) {
    'use strict';
    var inherits = require('util').inherits;
    var ReadableStream = require('stream').Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function (n) {};
    module2.exports = PartStream;
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/utils/getLimit.js'(exports, module2) {
    'use strict';
    module2.exports = function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === void 0 || limits[name] === null) {
        return defaultLimit;
      }
      if (typeof limits[name] !== 'number' || isNaN(limits[name])) {
        throw new TypeError('Limit ' + name + ' is not a valid number');
      }
      return limits[name];
    };
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js'(
    exports,
    module2
  ) {
    'use strict';
    var EventEmitter = require('events').EventEmitter;
    var inherits = require('util').inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from('\r\n\r\n');
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter.call(this);
      cfg = cfg || {};
      const self = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2e3);
      this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 80 * 1024);
      this.buffer = '';
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on('info', function (isMatch, data, start, end) {
        if (data && !self.maxed) {
          if (self.nread + end - start >= self.maxHeaderSize) {
            end = self.maxHeaderSize - self.nread + start;
            self.nread = self.maxHeaderSize;
            self.maxed = true;
          } else {
            self.nread += end - start;
          }
          self.buffer += data.toString('binary', start, end);
        }
        if (isMatch) {
          self._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter);
    HeaderParser.prototype.push = function (data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };
    HeaderParser.prototype.reset = function () {
      this.finished = false;
      this.buffer = '';
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function () {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = '';
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit('header', header);
    };
    HeaderParser.prototype._parseHeader = function () {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h;
      for (var i = 0; i < len; ++i) {
        if (lines[i].length === 0) {
          continue;
        }
        if (lines[i][0] === '	' || lines[i][0] === ' ') {
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i];
            continue;
          }
        }
        const posColon = lines[i].indexOf(':');
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i]);
        h = m[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m[2] || '');
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module2.exports = HeaderParser;
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js'(exports, module2) {
    'use strict';
    var WritableStream = require('stream').Writable;
    var inherits = require('util').inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from('-');
    var B_CRLF = Buffer.from('\r\n');
    var EMPTY_FN = function () {};
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string')) {
        throw new TypeError('Boundary required');
      }
      if (typeof cfg.boundary === 'string') {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on('header', function (header) {
        self._inHeader = false;
        self._part.emit('header', header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function (ev) {
      if (ev === 'finish' && !this._realFinish) {
        if (!this._finished) {
          const self = this;
          process.nextTick(function () {
            self.emit('error', new Error('Unexpected end of multipart data'));
            if (self._part && !self._ignoreData) {
              const type = self._isPreamble ? 'Preamble' : 'Part';
              self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));
              self._part.push(null);
              process.nextTick(function () {
                self._realFinish = true;
                self.emit('finish');
                self._realFinish = false;
              });
              return;
            }
            self._realFinish = true;
            self.emit('finish');
            self._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function (data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this._events.preamble) {
            this.emit('preamble', this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function () {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function (boundary) {
      const self = this;
      this._bparser = new StreamSearch('\r\n--' + boundary);
      this._bparser.on('info', function (isMatch, data, start, end) {
        self._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function () {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on('error', EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function (isMatch, data, start, end) {
      let buf;
      const self = this;
      let i = 0;
      let r;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i < end) {
          if (data[start + i] === DASH) {
            ++i;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i < end && this._events.trailer) {
            this.emit('trailer', data.slice(start + i, end));
          }
          this.reset();
          this._finished = true;
          if (self._parts === 0) {
            self._realFinish = true;
            self.emit('finish');
            self._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function (n) {
          self._unpause();
        };
        if (this._isPreamble && this._events.preamble) {
          this.emit('preamble', this._part);
        } else if (this._isPreamble !== true && this._events.part) {
          this.emit('part', this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== void 0 && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on('end', function () {
              if (--self._parts === 0) {
                if (self._finished) {
                  self._realFinish = true;
                  self.emit('finish');
                  self._realFinish = false;
                } else {
                  self._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function () {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module2.exports = Dicer;
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/utils/decodeText.js'(exports, module2) {
    'use strict';
    var utf8Decoder = new TextDecoder('utf-8');
    var textDecoders = /* @__PURE__ */ new Map([
      ['utf-8', utf8Decoder],
      ['utf8', utf8Decoder],
    ]);
    function decodeText(text, textEncoding, destEncoding) {
      if (text) {
        if (textDecoders.has(destEncoding)) {
          try {
            return textDecoders.get(destEncoding).decode(Buffer.from(text, textEncoding));
          } catch (e) {}
        } else {
          try {
            textDecoders.set(destEncoding, new TextDecoder(destEncoding));
            return textDecoders.get(destEncoding).decode(Buffer.from(text, textEncoding));
          } catch (e) {}
        }
      }
      return text;
    }
    module2.exports = decodeText;
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/utils/parseParams.js'(exports, module2) {
    'use strict';
    var decodeText = require_decodeText();
    var RE_ENCODED = /%([a-fA-F0-9]{2})/g;
    function encodedReplacer(match, byte) {
      return String.fromCharCode(parseInt(byte, 16));
    }
    function parseParams(str) {
      const res = [];
      let state = 'key';
      let charset = '';
      let inquote = false;
      let escaping = false;
      let p = 0;
      let tmp = '';
      for (var i = 0, len = str.length; i < len; ++i) {
        const char = str[i];
        if (char === '\\' && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = 'key';
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += '\\';
          }
          escaping = false;
          if ((state === 'charset' || state === 'lang') && char === "'") {
            if (state === 'charset') {
              state = 'lang';
              charset = tmp.substring(1);
            } else {
              state = 'value';
            }
            tmp = '';
            continue;
          } else if (state === 'key' && (char === '*' || char === '=') && res.length) {
            if (char === '*') {
              state = 'charset';
            } else {
              state = 'value';
            }
            res[p] = [tmp, void 0];
            tmp = '';
            continue;
          } else if (!inquote && char === ';') {
            state = 'key';
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), 'binary', charset);
              }
              charset = '';
            } else if (tmp.length) {
              tmp = decodeText(tmp, 'binary', 'utf8');
            }
            if (res[p] === void 0) {
              res[p] = tmp;
            } else {
              res[p][1] = tmp;
            }
            tmp = '';
            ++p;
            continue;
          } else if (!inquote && (char === ' ' || char === '	')) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), 'binary', charset);
      } else if (tmp) {
        tmp = decodeText(tmp, 'binary', 'utf8');
      }
      if (res[p] === void 0) {
        if (tmp) {
          res[p] = tmp;
        }
      } else {
        res[p][1] = tmp;
      }
      return res;
    }
    module2.exports = parseParams;
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/utils/basename.js'(exports, module2) {
    'use strict';
    module2.exports = function basename(path) {
      if (typeof path !== 'string') {
        return '';
      }
      for (var i = path.length - 1; i >= 0; --i) {
        switch (path.charCodeAt(i)) {
          case 47:
          case 92:
            path = path.slice(i + 1);
            return path === '..' || path === '.' ? '' : path;
        }
      }
      return path === '..' || path === '.' ? '' : path;
    };
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/types/multipart.js'(exports, module2) {
    'use strict';
    var { Readable } = require('stream');
    var { inherits } = require('util');
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i;
      let len;
      const self = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile =
        cfg.isPartAFile ||
        ((fieldName, contentType, fileName) => contentType === 'application/octet-stream' || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || 'utf8';
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
          boundary = parsedConType[i][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self.end();
        }
      }
      if (typeof boundary !== 'string') {
        throw new Error('Multipart: Boundary not found');
      }
      const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, 'fileSize', Infinity);
      const filesLimit = getLimit(limits, 'files', Infinity);
      const fieldsLimit = getLimit(limits, 'fields', Infinity);
      const partsLimit = getLimit(limits, 'parts', Infinity);
      const headerPairsLimit = getLimit(limits, 'headerPairs', 2e3);
      const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark,
      };
      this.parser = new Dicer(parserCfg);
      this.parser
        .on('drain', function () {
          self._needDrain = false;
          if (self._cb && !self._pause) {
            const cb = self._cb;
            self._cb = void 0;
            cb();
          }
        })
        .on('part', function onPart(part) {
          if (++self._nparts > partsLimit) {
            self.parser.removeListener('part', onPart);
            self.parser.on('part', skipPart);
            boy.hitPartsLimit = true;
            boy.emit('partsLimit');
            return skipPart(part);
          }
          if (curField) {
            const field = curField;
            field.emit('end');
            field.removeAllListeners('end');
          }
          part
            .on('header', function (header) {
              let contype;
              let fieldname;
              let parsed;
              let charset;
              let encoding;
              let filename;
              let nsize = 0;
              if (header['content-type']) {
                parsed = parseParams(header['content-type'][0]);
                if (parsed[0]) {
                  contype = parsed[0].toLowerCase();
                  for (i = 0, len = parsed.length; i < len; ++i) {
                    if (RE_CHARSET.test(parsed[i][0])) {
                      charset = parsed[i][1].toLowerCase();
                      break;
                    }
                  }
                }
              }
              if (contype === void 0) {
                contype = 'text/plain';
              }
              if (charset === void 0) {
                charset = defCharset;
              }
              if (header['content-disposition']) {
                parsed = parseParams(header['content-disposition'][0]);
                if (!RE_FIELD.test(parsed[0])) {
                  return skipPart(part);
                }
                for (i = 0, len = parsed.length; i < len; ++i) {
                  if (RE_NAME.test(parsed[i][0])) {
                    fieldname = parsed[i][1];
                  } else if (RE_FILENAME.test(parsed[i][0])) {
                    filename = parsed[i][1];
                    if (!preservePath) {
                      filename = basename(filename);
                    }
                  }
                }
              } else {
                return skipPart(part);
              }
              if (header['content-transfer-encoding']) {
                encoding = header['content-transfer-encoding'][0].toLowerCase();
              } else {
                encoding = '7bit';
              }
              let onData, onEnd;
              if (isPartAFile(fieldname, contype, filename)) {
                if (nfiles === filesLimit) {
                  if (!boy.hitFilesLimit) {
                    boy.hitFilesLimit = true;
                    boy.emit('filesLimit');
                  }
                  return skipPart(part);
                }
                ++nfiles;
                if (!boy._events.file) {
                  self.parser._ignore();
                  return;
                }
                ++nends;
                const file = new FileStream(fileOpts);
                curFile = file;
                file.on('end', function () {
                  --nends;
                  self._pause = false;
                  checkFinished();
                  if (self._cb && !self._needDrain) {
                    const cb = self._cb;
                    self._cb = void 0;
                    cb();
                  }
                });
                file._read = function (n) {
                  if (!self._pause) {
                    return;
                  }
                  self._pause = false;
                  if (self._cb && !self._needDrain) {
                    const cb = self._cb;
                    self._cb = void 0;
                    cb();
                  }
                };
                boy.emit('file', fieldname, file, filename, encoding, contype);
                onData = function (data) {
                  if ((nsize += data.length) > fileSizeLimit) {
                    const extralen = fileSizeLimit - nsize + data.length;
                    if (extralen > 0) {
                      file.push(data.slice(0, extralen));
                    }
                    file.truncated = true;
                    file.bytesRead = fileSizeLimit;
                    part.removeAllListeners('data');
                    file.emit('limit');
                    return;
                  } else if (!file.push(data)) {
                    self._pause = true;
                  }
                  file.bytesRead = nsize;
                };
                onEnd = function () {
                  curFile = void 0;
                  file.push(null);
                };
              } else {
                if (nfields === fieldsLimit) {
                  if (!boy.hitFieldsLimit) {
                    boy.hitFieldsLimit = true;
                    boy.emit('fieldsLimit');
                  }
                  return skipPart(part);
                }
                ++nfields;
                ++nends;
                let buffer = '';
                let truncated = false;
                curField = part;
                onData = function (data) {
                  if ((nsize += data.length) > fieldSizeLimit) {
                    const extralen = fieldSizeLimit - (nsize - data.length);
                    buffer += data.toString('binary', 0, extralen);
                    truncated = true;
                    part.removeAllListeners('data');
                  } else {
                    buffer += data.toString('binary');
                  }
                };
                onEnd = function () {
                  curField = void 0;
                  if (buffer.length) {
                    buffer = decodeText(buffer, 'binary', charset);
                  }
                  boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);
                  --nends;
                  checkFinished();
                };
              }
              part._readableState.sync = false;
              part.on('data', onData);
              part.on('end', onEnd);
            })
            .on('error', function (err) {
              if (curFile) {
                curFile.emit('error', err);
              }
            });
        })
        .on('error', function (err) {
          boy.emit('error', err);
        })
        .on('finish', function () {
          finished = true;
          checkFinished();
        });
    }
    Multipart.prototype.write = function (chunk, cb) {
      const r = this.parser.write(chunk);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function () {
      const self = this;
      if (self.parser.writable) {
        self.parser.end();
      } else if (!self._boy._done) {
        process.nextTick(function () {
          self._boy._done = true;
          self._boy.emit('finish');
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable);
    FileStream.prototype._read = function (n) {};
    module2.exports = Multipart;
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/utils/Decoder.js'(exports, module2) {
    'use strict';
    var RE_PLUS = /\+/g;
    var HEX = [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function (str) {
      str = str.replace(RE_PLUS, ' ');
      let res = '';
      let i = 0;
      let p = 0;
      const len = str.length;
      for (; i < len; ++i) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i)]) {
            res += '%' + this.buffer;
            this.buffer = void 0;
            --i;
          } else {
            this.buffer += str[i];
            ++p;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i] === '%') {
          if (i > p) {
            res += str.substring(p, i);
            p = i;
          }
          this.buffer = '';
          ++p;
        }
      }
      if (p < len && this.buffer === void 0) {
        res += str.substring(p);
      }
      return res;
    };
    Decoder.prototype.reset = function () {
      this.buffer = void 0;
    };
    module2.exports = Decoder;
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/types/urlencoded.js'(exports, module2) {
    'use strict';
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100);
      this.fieldsLimit = getLimit(limits, 'fields', Infinity);
      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || 'utf8';
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = 'key';
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = '';
      this._val = '';
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function (data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit('fieldsLimit');
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i;
      let p = 0;
      const len = data.length;
      while (p < len) {
        if (this._state === 'key') {
          idxeq = idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 61) {
              idxeq = i;
              break;
            } else if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p) {
              this._key += this.decoder.write(data.toString('binary', p, idxeq));
            }
            this._state = 'val';
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = '';
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p) {
              key = this._key += this.decoder.write(data.toString('binary', p, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = '';
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit('field', decodeText(key, 'binary', this.charset), '', keyTrunc, false);
            }
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._key += this.decoder.write(data.toString('binary', p, i));
            }
            p = i;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p < len) {
              this._key += this.decoder.write(data.toString('binary', p));
            }
            p = len;
          }
        } else {
          idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p) {
              this._val += this.decoder.write(data.toString('binary', p, idxamp));
            }
            this.boy.emit(
              'field',
              decodeText(this._key, 'binary', this.charset),
              decodeText(this._val, 'binary', this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = 'key';
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = '';
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._val += this.decoder.write(data.toString('binary', p, i));
            }
            p = i;
            if (
              (this._val === '' && this.fieldSizeLimit === 0) ||
              (this._bytesVal = this._val.length) === this.fieldSizeLimit
            ) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p < len) {
              this._val += this.decoder.write(data.toString('binary', p));
            }
            p = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function () {
      if (this.boy._done) {
        return;
      }
      if (this._state === 'key' && this._key.length > 0) {
        this.boy.emit('field', decodeText(this._key, 'binary', this.charset), '', this._keyTrunc, false);
      } else if (this._state === 'val') {
        this.boy.emit(
          'field',
          decodeText(this._key, 'binary', this.charset),
          decodeText(this._val, 'binary', this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit('finish');
    };
    module2.exports = UrlEncoded;
  },
});

// node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  'node_modules/.pnpm/@fastify+busboy@2.0.0/node_modules/@fastify/busboy/lib/main.js'(exports, module2) {
    'use strict';
    var WritableStream = require('stream').Writable;
    var { inherits } = require('util');
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== 'object') {
        throw new TypeError('Busboy expected an options-Object.');
      }
      if (typeof opts.headers !== 'object') {
        throw new TypeError('Busboy expected an options-Object with headers-attribute.');
      }
      if (typeof opts.headers['content-type'] !== 'string') {
        throw new TypeError('Missing Content-Type-header.');
      }
      const _a = opts,
        { headers } = _a,
        streamOptions = __objRest(_a, ['headers']);
      this.opts = __spreadValues(
        {
          autoDestroy: false,
        },
        streamOptions
      );
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function (ev) {
      var _a;
      if (ev === 'finish') {
        if (!this._done) {
          (_a = this._parser) == null ? void 0 : _a.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function (headers) {
      const parsed = parseParams(headers['content-type']);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath,
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error('Unsupported Content-Type.');
    };
    Busboy.prototype._write = function (chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module2.exports = Busboy;
    module2.exports.default = Busboy;
    module2.exports.Busboy = Busboy;
    module2.exports.Dicer = Dicer;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/constants.js
var require_constants = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/constants.js'(exports, module2) {
    'use strict';
    var { MessageChannel, receiveMessageOnPort } = require('worker_threads');
    var corsSafeListedMethods = ['GET', 'HEAD', 'POST'];
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = [
      '1',
      '7',
      '9',
      '11',
      '13',
      '15',
      '17',
      '19',
      '20',
      '21',
      '22',
      '23',
      '25',
      '37',
      '42',
      '43',
      '53',
      '69',
      '77',
      '79',
      '87',
      '95',
      '101',
      '102',
      '103',
      '104',
      '109',
      '110',
      '111',
      '113',
      '115',
      '117',
      '119',
      '123',
      '135',
      '137',
      '139',
      '143',
      '161',
      '179',
      '389',
      '427',
      '465',
      '512',
      '513',
      '514',
      '515',
      '526',
      '530',
      '531',
      '532',
      '540',
      '548',
      '554',
      '556',
      '563',
      '587',
      '601',
      '636',
      '989',
      '990',
      '993',
      '995',
      '1719',
      '1720',
      '1723',
      '2049',
      '3659',
      '4045',
      '5060',
      '5061',
      '6000',
      '6566',
      '6665',
      '6666',
      '6667',
      '6668',
      '6669',
      '6697',
      '10080',
    ];
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = [
      '',
      'no-referrer',
      'no-referrer-when-downgrade',
      'same-origin',
      'origin',
      'strict-origin',
      'origin-when-cross-origin',
      'strict-origin-when-cross-origin',
      'unsafe-url',
    ];
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = ['follow', 'manual', 'error'];
    var safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE'];
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = ['navigate', 'same-origin', 'no-cors', 'cors'];
    var requestCredentials = ['omit', 'same-origin', 'include'];
    var requestCache = ['default', 'no-store', 'reload', 'no-cache', 'force-cache', 'only-if-cached'];
    var requestBodyHeader = [
      'content-encoding',
      'content-language',
      'content-location',
      'content-type',
      'content-length',
    ];
    var requestDuplex = ['half'];
    var forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK'];
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = [
      'audio',
      'audioworklet',
      'font',
      'image',
      'manifest',
      'paintworklet',
      'script',
      'style',
      'track',
      'video',
      'xslt',
      '',
    ];
    var subresourceSet = new Set(subresource);
    var _a;
    var DOMException2 =
      (_a = globalThis.DOMException) != null
        ? _a
        : (() => {
            try {
              atob('~');
            } catch (err) {
              return Object.getPrototypeOf(err).constructor;
            }
          })();
    var channel;
    var _a2;
    var structuredClone =
      (_a2 = globalThis.structuredClone) != null
        ? _a2
        : function structuredClone2(value, options = void 0) {
            if (arguments.length === 0) {
              throw new TypeError('missing argument');
            }
            if (!channel) {
              channel = new MessageChannel();
            }
            channel.port1.unref();
            channel.port2.unref();
            channel.port1.postMessage(value, options == null ? void 0 : options.transfer);
            return receiveMessageOnPort(channel.port2).message;
          };
    module2.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/global.js
var require_global2 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/global.js'(exports, module2) {
    'use strict';
    var globalOrigin = Symbol.for('undici.globalOrigin.1');
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false,
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false,
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/util.js
var require_util3 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/util.js'(exports, module2) {
    'use strict';
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants();
    var { getGlobalOrigin } = require_global2();
    var { performance: performance2 } = require('perf_hooks');
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util2();
    var assert = require('assert');
    var { isUint8Array } = require('util/types');
    var crypto;
    try {
      crypto = require('crypto');
    } catch {}
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get('location');
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return 'blocked';
      }
      return 'allowed';
    }
    function isErrorLike(object) {
      var _a, _b;
      return (
        object instanceof Error ||
        ((_a = object == null ? void 0 : object.constructor) == null ? void 0 : _a.name) === 'Error' ||
        ((_b = object == null ? void 0 : object.constructor) == null ? void 0 : _b.name) === 'DOMException'
      );
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || (c >= 32 && c <= 126) || (c >= 128 && c <= 255))) {
          return false;
        }
      }
      return true;
    }
    function isTokenChar(c) {
      return !(
        c >= 127 ||
        c <= 32 ||
        c === '(' ||
        c === ')' ||
        c === '<' ||
        c === '>' ||
        c === '@' ||
        c === ',' ||
        c === ';' ||
        c === ':' ||
        c === '\\' ||
        c === '"' ||
        c === '/' ||
        c === '[' ||
        c === ']' ||
        c === '?' ||
        c === '=' ||
        c === '{' ||
        c === '}'
      );
    }
    function isValidHTTPToken(characters) {
      if (!characters || typeof characters !== 'string') {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        const c = characters.charCodeAt(i);
        if (c > 127 || !isTokenChar(c)) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      if (potentialValue.length === 0) {
        return false;
      }
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (
        potentialValue.startsWith('	') ||
        potentialValue.startsWith(' ') ||
        potentialValue.endsWith('	') ||
        potentialValue.endsWith(' ')
      ) {
        return false;
      }
      if (potentialValue.includes('\0') || potentialValue.includes('\r') || potentialValue.includes('\n')) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      var _a;
      const { headersList } = actualResponse;
      const policyHeader = ((_a = headersList.get('referrer-policy')) != null ? _a : '').split(',');
      let policy = '';
      if (policyHeader.length > 0) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== '') {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return 'allowed';
    }
    function corsCheck() {
      return 'success';
    }
    function TAOCheck() {
      return 'success';
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set('sec-fetch-mode', header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === 'cors' || request.mode === 'websocket') {
        if (serializedOrigin) {
          request.headersList.append('origin', serializedOrigin);
        }
      } else if (request.method !== 'GET' && request.method !== 'HEAD') {
        switch (request.referrerPolicy) {
          case 'no-referrer':
            serializedOrigin = null;
            break;
          case 'no-referrer-when-downgrade':
          case 'strict-origin':
          case 'strict-origin-when-cross-origin':
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case 'same-origin':
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append('origin', serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      var _a, _b;
      return {
        startTime: (_a = timingInfo.startTime) != null ? _a : 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: (_b = timingInfo.startTime) != null ? _b : 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null,
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: 'strict-origin-when-cross-origin',
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy,
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === 'client') {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === 'null') {
          return 'no-referrer';
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy =
        isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case 'origin':
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case 'unsafe-url':
          return referrerURL;
        case 'same-origin':
          return areSameOrigin ? referrerOrigin : 'no-referrer';
        case 'origin-when-cross-origin':
          return areSameOrigin ? referrerURL : referrerOrigin;
        case 'strict-origin-when-cross-origin': {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return 'no-referrer';
          }
          return referrerOrigin;
        }
        case 'strict-origin':
        case 'no-referrer-when-downgrade':
        default:
          return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin;
      }
    }
    function stripURLForReferrer(url, originOnly) {
      assert(url instanceof URL);
      if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {
        return 'no-referrer';
      }
      url.username = '';
      url.password = '';
      url.hash = '';
      if (originOnly) {
        url.pathname = '';
        url.search = '';
      }
      return url;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }
      if (url.href === 'about:blank' || url.href === 'about:srcdoc') {
        return true;
      }
      if (url.protocol === 'data:') return true;
      if (url.protocol === 'file:') return true;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === 'null') return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {
          return true;
        }
        if (
          /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) ||
          originAsURL.hostname === 'localhost' ||
          originAsURL.hostname.includes('localhost.') ||
          originAsURL.hostname.endsWith('.localhost')
        ) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === 'no metadata') {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));
      const strongest = list[0].algo;
      const metadata = list.filter((item) => item.algo === strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        let expectedValue = item.hash;
        if (expectedValue.endsWith('==')) {
          expectedValue = expectedValue.slice(0, -2);
        }
        let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');
        if (actualValue.endsWith('==')) {
          actualValue = actualValue.slice(0, -2);
        }
        if (actualValue === expectedValue) {
          return true;
        }
        let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest('base64url');
        if (actualBase64URL.endsWith('==')) {
          actualBase64URL = actualBase64URL.slice(0, -2);
        }
        if (actualBase64URL === expectedValue) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\x21-\x7e]?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      const supportedHashes = crypto.getHashes();
      for (const token of metadata.split(' ')) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo;
        if (supportedHashes.includes(algorithm.toLowerCase())) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return 'no metadata';
      }
      return result;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {}
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === 'null') {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === 'aborted';
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === 'aborted' || fetchParams.controller.state === 'terminated';
    }
    function normalizeMethod(method) {
      return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError('Value is not JSON serializable');
      }
      assert(typeof result === 'string');
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator,
      };
      const i = {
        next() {
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        [Symbol.toStringTag]: `${name} Iterator`,
      };
      Object.setPrototypeOf(i, esIteratorPrototype);
      return Object.setPrototypeOf({}, i);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case 'key': {
          result = pair[0];
          break;
        }
        case 'value': {
          result = pair[1];
          break;
        }
        case 'key+value': {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream) {
      if (!ReadableStream) {
        ReadableStream = require('stream/web').ReadableStream;
      }
      return (
        stream instanceof ReadableStream ||
        (stream[Symbol.toStringTag] === 'ReadableStream' && typeof stream.tee === 'function')
      );
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), '');
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes('Controller is already closed')) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i = 0; i < input.length; i++) {
        assert(input.charCodeAt(i) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength);
        }
        if (!isUint8Array(chunk)) {
          throw new TypeError('Received non-Uint8Array chunk');
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    function urlIsLocal(url) {
      assert('protocol' in url);
      const protocol = url.protocol;
      return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:';
    }
    function urlHasHttpsScheme(url) {
      if (typeof url === 'string') {
        return url.startsWith('https:');
      }
      return url.protocol === 'https:';
    }
    function urlIsHttpHttpsScheme(url) {
      assert('protocol' in url);
      const protocol = url.protocol;
      return protocol === 'http:' || protocol === 'https:';
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module2.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/symbols.js'(exports, module2) {
    'use strict';
    module2.exports = {
      kUrl: Symbol('url'),
      kHeaders: Symbol('headers'),
      kSignal: Symbol('signal'),
      kState: Symbol('state'),
      kGuard: Symbol('guard'),
      kRealm: Symbol('realm'),
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/webidl.js'(exports, module2) {
    'use strict';
    var { types } = require('util');
    var { hasOwn, toUSVString } = require_util3();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function (message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function (context) {
      const plural = context.types.length === 1 ? '' : ' one of';
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(', ')}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message,
      });
    };
    webidl.errors.invalidArgument = function (context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`,
      });
    };
    webidl.brandCheck = function (V, I, opts = void 0) {
      if ((opts == null ? void 0 : opts.strict) !== false && !(V instanceof I)) {
        throw new TypeError('Illegal invocation');
      } else {
        return (V == null ? void 0 : V[Symbol.toStringTag]) === I.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function ({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception(
          __spreadValues(
            {
              message: `${min} argument${min !== 1 ? 's' : ''} required, but${length ? ' only' : ''} ${length} found.`,
            },
            ctx
          )
        );
      }
    };
    webidl.illegalConstructor = function () {
      throw webidl.errors.exception({
        header: 'TypeError',
        message: 'Illegal constructor',
      });
    };
    webidl.util.Type = function (V) {
      switch (typeof V) {
        case 'undefined':
          return 'Undefined';
        case 'boolean':
          return 'Boolean';
        case 'string':
          return 'String';
        case 'symbol':
          return 'Symbol';
        case 'number':
          return 'Number';
        case 'bigint':
          return 'BigInt';
        case 'function':
        case 'object': {
          if (V === null) {
            return 'Null';
          }
          return 'Object';
        }
      }
    };
    webidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === 'unsigned') {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === 'unsigned') {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: 'Integer conversion',
            message: `Could not convert ${V} to an integer.`,
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: 'Integer conversion',
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`,
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (
        Number.isNaN(x) ||
        (x === 0 && Object.is(0, x)) ||
        x === Number.POSITIVE_INFINITY ||
        x === Number.NEGATIVE_INFINITY
      ) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function (n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function (converter) {
      return (V) => {
        var _a;
        if (webidl.util.Type(V) !== 'Object') {
          throw webidl.errors.exception({
            header: 'Sequence',
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`,
          });
        }
        const method = (_a = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a.call(V);
        const seq = [];
        if (method === void 0 || typeof method.next !== 'function') {
          throw webidl.errors.exception({
            header: 'Sequence',
            message: 'Object is not an iterator.',
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function (keyConverter, valueConverter) {
      return (O) => {
        if (webidl.util.Type(O) !== 'Object') {
          throw webidl.errors.exception({
            header: 'Record',
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`,
          });
        }
        const result = {};
        if (!types.isProxy(O)) {
          const keys2 = Object.keys(O);
          for (const key of keys2) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc == null ? void 0 : desc.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function (i) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i)) {
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`,
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function (converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === 'Null' || type === 'Undefined') {
          return dict;
        } else if (type !== 'Object') {
          throw webidl.errors.exception({
            header: 'Dictionary',
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`,
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: 'Dictionary',
                message: `Missing required key "${key}".`,
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, 'defaultValue');
          if (hasDefault && value !== null) {
            value = value != null ? value : defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: 'Dictionary',
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`,
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function (converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function (V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return '';
      }
      if (typeof V === 'symbol') {
        throw new TypeError('Could not convert argument of type symbol to string.');
      }
      return String(V);
    };
    webidl.converters.ByteString = function (V) {
      const x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++) {
        const charCode = x.charCodeAt(index);
        if (charCode > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${charCode} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function (V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function (V) {
      return V;
    };
    webidl.converters['long long'] = function (V) {
      const x = webidl.util.ConvertToInt(V, 64, 'signed');
      return x;
    };
    webidl.converters['unsigned long long'] = function (V) {
      const x = webidl.util.ConvertToInt(V, 64, 'unsigned');
      return x;
    };
    webidl.converters['unsigned long'] = function (V) {
      const x = webidl.util.ConvertToInt(V, 32, 'unsigned');
      return x;
    };
    webidl.converters['unsigned short'] = function (V, opts) {
      const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts);
      return x;
    };
    webidl.converters.ArrayBuffer = function (V, opts = {}) {
      if (webidl.util.Type(V) !== 'Object' || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ['ArrayBuffer'],
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: 'ArrayBuffer',
          message: 'SharedArrayBuffer is not allowed.',
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function (V, T, opts = {}) {
      if (webidl.util.Type(V) !== 'Object' || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name],
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: 'ArrayBuffer',
          message: 'SharedArrayBuffer is not allowed.',
        });
      }
      return V;
    };
    webidl.converters.DataView = function (V, opts = {}) {
      if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: 'DataView',
          message: 'Object is not a DataView.',
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: 'ArrayBuffer',
          message: 'SharedArrayBuffer is not allowed.',
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function (V, opts = {}) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(webidl.converters.ByteString);
    webidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(
      webidl.converters['sequence<ByteString>']
    );
    webidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/dataURL.js'(exports, module2) {
    var assert = require('assert');
    var { atob: atob2 } = require('buffer');
    var { isomorphicDecode } = require_util3();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === 'data:');
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(',', input, position);
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return 'failure';
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === 'failure') {
          return 'failure';
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, '');
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(';')) {
        mimeType = 'text/plain' + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === 'failure') {
        mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      const href = url.href;
      if (!excludeFragment) {
        return href;
      }
      const hash = href.lastIndexOf('#');
      if (hash === -1) {
        return href;
      }
      return href.slice(0, hash);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = '';
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast('/', input, position);
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return 'failure';
      }
      if (position.position > input.length) {
        return 'failure';
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(';', input, position);
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return 'failure';
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        parameters: /* @__PURE__ */ new Map(),
        essence: `${typeLowercase}/${subtypeLowercase}`,
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
        let parameterName = collectASequenceOfCodePoints((char) => char !== ';' && char !== '=', input, position);
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ';') {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(';', input, position);
        } else {
          parameterValue = collectASequenceOfCodePointsFast(';', input, position);
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (
          parameterName.length !== 0 &&
          HTTP_TOKEN_CODEPOINTS.test(parameterName) &&
          (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&
          !mimeType.parameters.has(parameterName)
        ) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, '');
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, '');
      }
      if (data.length % 4 === 1) {
        return 'failure';
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return 'failure';
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = '';
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints((char) => char !== '"' && char !== '\\', input, position);
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === '\\') {
          if (position.position >= input.length) {
            value += '\\';
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== 'failure');
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ';';
        serialization += name;
        serialization += '=';
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, '\\$1');
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === '\r' || char === '\n' || char === '	' || char === ' ';
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
      }
      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
      }
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === '\r' || char === '\n' || char === '	' || char === '\f' || char === ' ';
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
      }
      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
      }
      return str.slice(lead, trail + 1);
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/file.js'(exports, module2) {
    'use strict';
    var { Blob: Blob2, File: NativeFile } = require('buffer');
    var { types } = require('util');
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util3();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util2();
    var encoder = new TextEncoder();
    var File = class extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: 'File constructor' });
        fileBits = webidl.converters['sequence<BlobPart>'](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === 'failure') {
              t = '';
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n,
          lastModified: d,
          type: t,
        };
      }
      get name() {
        webidl.brandCheck(this, File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, File);
        return this[kState].type;
      }
    };
    var FileLike = class {
      constructor(blobLike, fileName, options = {}) {
        var _a;
        const n = fileName;
        const t = options.type;
        const d = (_a = options.lastModified) != null ? _a : Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d,
        };
      }
      stream(...args) {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return 'File';
      }
    };
    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: 'File',
        configurable: true,
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty,
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function (V, opts) {
      if (webidl.util.Type(V) === 'Object') {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters['sequence<BlobPart>'] = webidl.sequenceConverter(webidl.converters.BlobPart);
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: 'lastModified',
        converter: webidl.converters['long long'],
        get defaultValue() {
          return Date.now();
        },
      },
      {
        key: 'type',
        converter: webidl.converters.DOMString,
        defaultValue: '',
      },
      {
        key: 'endings',
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== 'native') {
            value = 'transparent';
          }
          return value;
        },
        defaultValue: 'transparent',
      },
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === 'string') {
          let s = element;
          if (options.endings === 'native') {
            s = convertLineEndingsNative(s);
          }
          bytes.push(encoder.encode(s));
        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = '\n';
      if (process.platform === 'win32') {
        nativeLineEnding = '\r\n';
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return (
        (NativeFile && object instanceof NativeFile) ||
        object instanceof File ||
        (object &&
          (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') &&
          object[Symbol.toStringTag] === 'File')
      );
    }
    module2.exports = { File, FileLike, isFileLike };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/formdata.js'(exports, module2) {
    'use strict';
    var { isBlobLike, toUSVString, makeIterator } = require_util3();
    var { kState } = require_symbols2();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = require('buffer');
    var File = NativeFile != null ? NativeFile : UndiciFile;
    var FormData = class {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: 'FormData constructor',
            argument: 'Argument 1',
            types: ['undefined'],
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.append' });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value)
          ? webidl.converters.Blob(value, { strict: false })
          : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.delete' });
        name = webidl.converters.USVString(name);
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.get' });
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.getAll' });
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.has' });
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.set' });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value)
          ? webidl.converters.Blob(value, { strict: false })
          : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name),
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, FormData);
        return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), 'FormData', 'key+value');
      }
      keys() {
        webidl.brandCheck(this, FormData);
        return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), 'FormData', 'key');
      }
      values() {
        webidl.brandCheck(this, FormData);
        return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), 'FormData', 'value');
      }
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.forEach' });
        if (typeof callbackFn !== 'function') {
          throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
    Object.defineProperties(FormData.prototype, {
      [Symbol.toStringTag]: {
        value: 'FormData',
        configurable: true,
      },
    });
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString('utf8');
      if (typeof value === 'string') {
        value = Buffer.from(value).toString('utf8');
      } else {
        if (!isFileLike(value)) {
          value =
            value instanceof Blob2
              ? new File([value], 'blob', { type: value.type })
              : new FileLike(value, 'blob', { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified,
          };
          value =
            (NativeFile && value instanceof NativeFile) || value instanceof UndiciFile
              ? new File([value], filename, options)
              : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module2.exports = { FormData };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/body.js'(exports, module2) {
    'use strict';
    var Busboy = require_main();
    var util = require_util2();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody,
    } = require_util3();
    var { FormData } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException: DOMException2, structuredClone } = require_constants();
    var { Blob: Blob2, File: NativeFile } = require('buffer');
    var { kBodyUsed } = require_symbols();
    var assert = require('assert');
    var { isErrored } = require_util2();
    var { isUint8Array, isArrayBuffer } = require('util/types');
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var ReadableStream = globalThis.ReadableStream;
    var File = NativeFile != null ? NativeFile : UndiciFile;
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require('stream/web').ReadableStream;
      }
      let stream = null;
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(typeof source === 'string' ? textEncoder.encode(source) : source);
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {},
          type: void 0,
        });
      }
      assert(isReadableStreamLike(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === 'string') {
        source = object;
        type = 'text/plain;charset=UTF-8';
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = 'application/x-www-form-urlencoded;charset=UTF-8';
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, '0')}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape2 = (str) => str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22');
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, '\r\n');
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === 'string') {
            const chunk2 = textEncoder.encode(
              prefix +
                `; name="${escape2(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`
            );
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(
              `${prefix}; name="${escape2(normalizeLinefeeds(name))}"` +
                (value.name ? `; filename="${escape2(value.name)}"` : '') +
                `\r
Content-Type: ${value.type || 'application/octet-stream'}\r
\r
`
            );
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === 'number') {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = 'multipart/form-data; boundary=' + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === 'function') {
        if (keepalive) {
          throw new TypeError('keepalive');
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError('Response body object should not be disturbed or locked');
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === 'string' || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0,
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require('stream/web').ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert(!util.isDisturbed(object), 'The body has already been consumed.');
        assert(!object.locked, 'The stream is locked.');
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source,
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;
          if (util.isDisturbed(stream)) {
            throw new TypeError('The body has already been consumed.');
          }
          if (stream.locked) {
            throw new TypeError('The stream is locked.');
          }
          stream[kBodyUsed] = true;
          yield* stream;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException2('The operation was aborted.', 'AbortError');
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(
            this,
            (bytes) => {
              let mimeType = bodyMimeType(this);
              if (mimeType === 'failure') {
                mimeType = '';
              } else if (mimeType) {
                mimeType = serializeAMimeType(mimeType);
              }
              return new Blob2([bytes], { type: mimeType });
            },
            instance
          );
        },
        arrayBuffer() {
          return specConsumeBody(
            this,
            (bytes) => {
              return new Uint8Array(bytes).buffer;
            },
            instance
          );
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get('Content-Type');
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
            const responseFormData = new FormData();
            let busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: true,
              });
            } catch (err) {
              throw new DOMException2(`${err}`, 'AbortError');
            }
            busboy.on('field', (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on('file', (name, value, filename, encoding, mimeType) => {
              const chunks = [];
              if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {
                let base64chunk = '';
                value.on('data', (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, '');
                  const end = base64chunk.length - (base64chunk.length % 4);
                  chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'));
                  base64chunk = base64chunk.slice(end);
                });
                value.on('end', () => {
                  chunks.push(Buffer.from(base64chunk, 'base64'));
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on('data', (chunk) => {
                  chunks.push(chunk);
                });
                value.on('end', () => {
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve, reject) => {
              busboy.on('finish', resolve);
              busboy.on('error', (err) => reject(new TypeError(err)));
            });
            if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = '';
              const streamingDecoder = new TextDecoder('utf-8', { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError('Expected Uint8Array chunk');
                }
                text += streamingDecoder.decode(chunk, { stream: true });
              }
              text += streamingDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: 'Could not parse content as FormData.',
            });
          }
        },
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError('Body is unusable');
      }
      const promise = createDeferredPromise();
      const errorSteps = (error) => promise.reject(error);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return '';
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get('content-type');
      if (contentType === null) {
        return 'failure';
      }
      return parseMIMEType(contentType);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/core/request.js
var require_request2 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/core/request.js'(exports, module2) {
    'use strict';
    var { InvalidArgumentError, NotSupportedError } = require_errors();
    var assert = require('assert');
    var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
    var util = require_util2();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol('handler');
    var channels = {};
    var extractBody;
    try {
      const diagnosticsChannel = require('diagnostics_channel');
      channels.create = diagnosticsChannel.channel('undici:request:create');
      channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent');
      channels.headers = diagnosticsChannel.channel('undici:request:headers');
      channels.trailers = diagnosticsChannel.channel('undici:request:trailers');
      channels.error = diagnosticsChannel.channel('undici:request:error');
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request = class {
      constructor(
        origin,
        {
          path,
          method,
          body,
          headers,
          query,
          idempotent,
          blocking,
          upgrade,
          headersTimeout,
          bodyTimeout,
          reset,
          throwOnError,
          expectContinue,
        },
        handler
      ) {
        if (typeof path !== 'string') {
          throw new InvalidArgumentError('path must be a string');
        } else if (
          path[0] !== '/' &&
          !(path.startsWith('http://') || path.startsWith('https://')) &&
          method !== 'CONNECT'
        ) {
          throw new InvalidArgumentError('path must be an absolute URL or start with a slash');
        } else if (invalidPathRegex.exec(path) !== null) {
          throw new InvalidArgumentError('invalid request path');
        }
        if (typeof method !== 'string') {
          throw new InvalidArgumentError('method must be a string');
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError('invalid request method');
        }
        if (upgrade && typeof upgrade !== 'string') {
          throw new InvalidArgumentError('upgrade must be a string');
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError('invalid headersTimeout');
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError('invalid bodyTimeout');
        }
        if (reset != null && typeof reset !== 'boolean') {
          throw new InvalidArgumentError('invalid reset');
        }
        if (expectContinue != null && typeof expectContinue !== 'boolean') {
          throw new InvalidArgumentError('invalid expectContinue');
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === 'string') {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError(
            'body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable'
          );
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util.buildURL(path, query) : path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === 'HEAD' || method === 'GET' : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = '';
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError('headers array must be even');
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === 'object') {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError('headers must be an object or an array');
        }
        if (util.isFormDataLike(this.body)) {
          if (util.nodeMajor < 16 || (util.nodeMajor === 16 && util.nodeMinor < 8)) {
            throw new InvalidArgumentError('Form-Data bodies are only supported in node v16.8 and newer.');
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.onError(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            this[kHandler].onRequestSent();
          } catch (err) {
            this.onError(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onConnect(abort);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onData(chunk);
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        return this[kHandler].onComplete(trailers);
      }
      onError(error) {
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = __spreadProps(__spreadValues({}, opts), { headers: null });
        const request = new Request(origin, opts, handler);
        request.headers = {};
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError('headers array must be even');
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(request, headers[i], headers[i + 1], true);
          }
        } else if (headers && typeof headers === 'object') {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError('headers must be an object or an array');
        }
        return request;
      }
      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split('\r\n');
        const headers = {};
        for (const header of rawHeaders) {
          const [key, value] = header.split(': ');
          if (value == null || value.length === 0) continue;
          if (headers[key]) headers[key] += `,${value}`;
          else headers[key] = value;
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === 'object') {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : '';
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return skipAppend
        ? val
        : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = false) {
      if (val && typeof val === 'object' && !Array.isArray(val)) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === 'host') {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === 'content-length') {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError('invalid content-length header');
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === 'content-type') {
        request.contentType = val;
        if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
        else request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === 'transfer-encoding') {
        throw new InvalidArgumentError('invalid transfer-encoding header');
      } else if (key.length === 10 && key.toLowerCase() === 'connection') {
        const value = typeof val === 'string' ? val.toLowerCase() : null;
        if (value !== 'close' && value !== 'keep-alive') {
          throw new InvalidArgumentError('invalid connection header');
        } else if (value === 'close') {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === 'keep-alive') {
        throw new InvalidArgumentError('invalid keep-alive header');
      } else if (key.length === 7 && key.toLowerCase() === 'upgrade') {
        throw new InvalidArgumentError('invalid upgrade header');
      } else if (key.length === 6 && key.toLowerCase() === 'expect') {
        throw new NotSupportedError('expect header not supported');
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError('invalid header key');
      } else {
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (skipAppend) {
              if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
              else request.headers[key] = processHeaderValue(key, val[i], skipAppend);
            } else {
              request.headers += processHeaderValue(key, val[i]);
            }
          }
        } else {
          if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
          else request.headers += processHeaderValue(key, val);
        }
      }
    }
    module2.exports = Request;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/dispatcher.js'(exports, module2) {
    'use strict';
    var EventEmitter = require('events');
    var Dispatcher = class extends EventEmitter {
      dispatch() {
        throw new Error('not implemented');
      }
      close() {
        throw new Error('not implemented');
      }
      destroy() {
        throw new Error('not implemented');
      }
    };
    module2.exports = Dispatcher;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/dispatcher-base.js'(exports, module2) {
    'use strict';
    var Dispatcher = require_dispatcher();
    var { ClientDestroyedError, ClientClosedError, InvalidArgumentError } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = Symbol('destroyed');
    var kClosed = Symbol('closed');
    var kOnDestroyed = Symbol('onDestroyed');
    var kOnClosed = Symbol('onClosed');
    var kInterceptedDispatch = Symbol('Intercepted Dispatch');
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== 'function') {
              throw new InvalidArgumentError('interceptor must be an function');
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== 'function') {
          throw new InvalidArgumentError('invalid callback');
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]()
          .then(() => this.destroy())
          .then(() => {
            queueMicrotask(onClosed);
          });
      }
      destroy(err, callback) {
        if (typeof err === 'function') {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? reject(err2) : resolve(data);
            });
          });
        }
        if (typeof callback !== 'function') {
          throw new InvalidArgumentError('invalid callback');
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== 'object') {
          throw new InvalidArgumentError('handler must be an object');
        }
        try {
          if (!opts || typeof opts !== 'object') {
            throw new InvalidArgumentError('opts must be an object.');
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== 'function') {
            throw new InvalidArgumentError('invalid onError method');
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/core/connect.js'(exports, module2) {
    'use strict';
    var net = require('net');
    var assert = require('assert');
    var util = require_util2();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector(_a) {
      var _b = _a,
        { allowH2, maxCachedSessions, socketPath, timeout } = _b,
        opts = __objRest(_b, ['allowH2', 'maxCachedSessions', 'socketPath', 'timeout']);
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');
      }
      const options = __spreadValues({ path: socketPath }, opts);
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === 'https:') {
          if (!tls) {
            tls = require('tls');
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert(sessionKey);
          socket = tls.connect(
            __spreadProps(
              __spreadValues(
                {
                  highWaterMark: 16384,
                },
                options
              ),
              {
                servername,
                session,
                localAddress,
                ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],
                socket: httpSocket,
                port: port || 443,
                host: hostname,
              }
            )
          );
          socket.on('session', function (session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, 'httpSocket can only be sent on TLS update');
          socket = net.connect(
            __spreadProps(
              __spreadValues(
                {
                  highWaterMark: 64 * 1024,
                },
                options
              ),
              {
                localAddress,
                port: port || 80,
                host: hostname,
              }
            )
          );
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket
          .setNoDelay(true)
          .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {
            cancelTimeout();
            if (callback) {
              const cb = callback;
              callback = null;
              cb(null, this);
            }
          })
          .on('error', function (err) {
            cancelTimeout();
            if (callback) {
              const cb = callback;
              callback = null;
              cb(err);
            }
          });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {};
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === 'win32') {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/llhttp/utils.js
var require_utils3 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/llhttp/utils.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === 'number') {
          res[key] = value;
        }
      });
      return res;
    }
    exports.enumToMap = enumToMap;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/llhttp/constants.js'(exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.SPECIAL_HEADERS =
      exports.HEADER_STATE =
      exports.MINOR =
      exports.MAJOR =
      exports.CONNECTION_TOKEN_CHARS =
      exports.HEADER_CHARS =
      exports.TOKEN =
      exports.STRICT_TOKEN =
      exports.HEX =
      exports.URL_CHAR =
      exports.STRICT_URL_CHAR =
      exports.USERINFO_CHARS =
      exports.MARK =
      exports.ALPHANUM =
      exports.NUM =
      exports.HEX_MAP =
      exports.NUM_MAP =
      exports.ALPHA =
      exports.FINISH =
      exports.H_METHOD_MAP =
      exports.METHOD_MAP =
      exports.METHODS_RTSP =
      exports.METHODS_ICE =
      exports.METHODS_HTTP =
      exports.METHODS =
      exports.LENIENT_FLAGS =
      exports.FLAGS =
      exports.TYPE =
      exports.ERROR =
        void 0;
    var utils_1 = require_utils3();
    var ERROR;
    (function (ERROR2) {
      ERROR2[(ERROR2['OK'] = 0)] = 'OK';
      ERROR2[(ERROR2['INTERNAL'] = 1)] = 'INTERNAL';
      ERROR2[(ERROR2['STRICT'] = 2)] = 'STRICT';
      ERROR2[(ERROR2['LF_EXPECTED'] = 3)] = 'LF_EXPECTED';
      ERROR2[(ERROR2['UNEXPECTED_CONTENT_LENGTH'] = 4)] = 'UNEXPECTED_CONTENT_LENGTH';
      ERROR2[(ERROR2['CLOSED_CONNECTION'] = 5)] = 'CLOSED_CONNECTION';
      ERROR2[(ERROR2['INVALID_METHOD'] = 6)] = 'INVALID_METHOD';
      ERROR2[(ERROR2['INVALID_URL'] = 7)] = 'INVALID_URL';
      ERROR2[(ERROR2['INVALID_CONSTANT'] = 8)] = 'INVALID_CONSTANT';
      ERROR2[(ERROR2['INVALID_VERSION'] = 9)] = 'INVALID_VERSION';
      ERROR2[(ERROR2['INVALID_HEADER_TOKEN'] = 10)] = 'INVALID_HEADER_TOKEN';
      ERROR2[(ERROR2['INVALID_CONTENT_LENGTH'] = 11)] = 'INVALID_CONTENT_LENGTH';
      ERROR2[(ERROR2['INVALID_CHUNK_SIZE'] = 12)] = 'INVALID_CHUNK_SIZE';
      ERROR2[(ERROR2['INVALID_STATUS'] = 13)] = 'INVALID_STATUS';
      ERROR2[(ERROR2['INVALID_EOF_STATE'] = 14)] = 'INVALID_EOF_STATE';
      ERROR2[(ERROR2['INVALID_TRANSFER_ENCODING'] = 15)] = 'INVALID_TRANSFER_ENCODING';
      ERROR2[(ERROR2['CB_MESSAGE_BEGIN'] = 16)] = 'CB_MESSAGE_BEGIN';
      ERROR2[(ERROR2['CB_HEADERS_COMPLETE'] = 17)] = 'CB_HEADERS_COMPLETE';
      ERROR2[(ERROR2['CB_MESSAGE_COMPLETE'] = 18)] = 'CB_MESSAGE_COMPLETE';
      ERROR2[(ERROR2['CB_CHUNK_HEADER'] = 19)] = 'CB_CHUNK_HEADER';
      ERROR2[(ERROR2['CB_CHUNK_COMPLETE'] = 20)] = 'CB_CHUNK_COMPLETE';
      ERROR2[(ERROR2['PAUSED'] = 21)] = 'PAUSED';
      ERROR2[(ERROR2['PAUSED_UPGRADE'] = 22)] = 'PAUSED_UPGRADE';
      ERROR2[(ERROR2['PAUSED_H2_UPGRADE'] = 23)] = 'PAUSED_H2_UPGRADE';
      ERROR2[(ERROR2['USER'] = 24)] = 'USER';
    })((ERROR = exports.ERROR || (exports.ERROR = {})));
    var TYPE;
    (function (TYPE2) {
      TYPE2[(TYPE2['BOTH'] = 0)] = 'BOTH';
      TYPE2[(TYPE2['REQUEST'] = 1)] = 'REQUEST';
      TYPE2[(TYPE2['RESPONSE'] = 2)] = 'RESPONSE';
    })((TYPE = exports.TYPE || (exports.TYPE = {})));
    var FLAGS;
    (function (FLAGS2) {
      FLAGS2[(FLAGS2['CONNECTION_KEEP_ALIVE'] = 1)] = 'CONNECTION_KEEP_ALIVE';
      FLAGS2[(FLAGS2['CONNECTION_CLOSE'] = 2)] = 'CONNECTION_CLOSE';
      FLAGS2[(FLAGS2['CONNECTION_UPGRADE'] = 4)] = 'CONNECTION_UPGRADE';
      FLAGS2[(FLAGS2['CHUNKED'] = 8)] = 'CHUNKED';
      FLAGS2[(FLAGS2['UPGRADE'] = 16)] = 'UPGRADE';
      FLAGS2[(FLAGS2['CONTENT_LENGTH'] = 32)] = 'CONTENT_LENGTH';
      FLAGS2[(FLAGS2['SKIPBODY'] = 64)] = 'SKIPBODY';
      FLAGS2[(FLAGS2['TRAILING'] = 128)] = 'TRAILING';
      FLAGS2[(FLAGS2['TRANSFER_ENCODING'] = 512)] = 'TRANSFER_ENCODING';
    })((FLAGS = exports.FLAGS || (exports.FLAGS = {})));
    var LENIENT_FLAGS;
    (function (LENIENT_FLAGS2) {
      LENIENT_FLAGS2[(LENIENT_FLAGS2['HEADERS'] = 1)] = 'HEADERS';
      LENIENT_FLAGS2[(LENIENT_FLAGS2['CHUNKED_LENGTH'] = 2)] = 'CHUNKED_LENGTH';
      LENIENT_FLAGS2[(LENIENT_FLAGS2['KEEP_ALIVE'] = 4)] = 'KEEP_ALIVE';
    })((LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {})));
    var METHODS;
    (function (METHODS2) {
      METHODS2[(METHODS2['DELETE'] = 0)] = 'DELETE';
      METHODS2[(METHODS2['GET'] = 1)] = 'GET';
      METHODS2[(METHODS2['HEAD'] = 2)] = 'HEAD';
      METHODS2[(METHODS2['POST'] = 3)] = 'POST';
      METHODS2[(METHODS2['PUT'] = 4)] = 'PUT';
      METHODS2[(METHODS2['CONNECT'] = 5)] = 'CONNECT';
      METHODS2[(METHODS2['OPTIONS'] = 6)] = 'OPTIONS';
      METHODS2[(METHODS2['TRACE'] = 7)] = 'TRACE';
      METHODS2[(METHODS2['COPY'] = 8)] = 'COPY';
      METHODS2[(METHODS2['LOCK'] = 9)] = 'LOCK';
      METHODS2[(METHODS2['MKCOL'] = 10)] = 'MKCOL';
      METHODS2[(METHODS2['MOVE'] = 11)] = 'MOVE';
      METHODS2[(METHODS2['PROPFIND'] = 12)] = 'PROPFIND';
      METHODS2[(METHODS2['PROPPATCH'] = 13)] = 'PROPPATCH';
      METHODS2[(METHODS2['SEARCH'] = 14)] = 'SEARCH';
      METHODS2[(METHODS2['UNLOCK'] = 15)] = 'UNLOCK';
      METHODS2[(METHODS2['BIND'] = 16)] = 'BIND';
      METHODS2[(METHODS2['REBIND'] = 17)] = 'REBIND';
      METHODS2[(METHODS2['UNBIND'] = 18)] = 'UNBIND';
      METHODS2[(METHODS2['ACL'] = 19)] = 'ACL';
      METHODS2[(METHODS2['REPORT'] = 20)] = 'REPORT';
      METHODS2[(METHODS2['MKACTIVITY'] = 21)] = 'MKACTIVITY';
      METHODS2[(METHODS2['CHECKOUT'] = 22)] = 'CHECKOUT';
      METHODS2[(METHODS2['MERGE'] = 23)] = 'MERGE';
      METHODS2[(METHODS2['M-SEARCH'] = 24)] = 'M-SEARCH';
      METHODS2[(METHODS2['NOTIFY'] = 25)] = 'NOTIFY';
      METHODS2[(METHODS2['SUBSCRIBE'] = 26)] = 'SUBSCRIBE';
      METHODS2[(METHODS2['UNSUBSCRIBE'] = 27)] = 'UNSUBSCRIBE';
      METHODS2[(METHODS2['PATCH'] = 28)] = 'PATCH';
      METHODS2[(METHODS2['PURGE'] = 29)] = 'PURGE';
      METHODS2[(METHODS2['MKCALENDAR'] = 30)] = 'MKCALENDAR';
      METHODS2[(METHODS2['LINK'] = 31)] = 'LINK';
      METHODS2[(METHODS2['UNLINK'] = 32)] = 'UNLINK';
      METHODS2[(METHODS2['SOURCE'] = 33)] = 'SOURCE';
      METHODS2[(METHODS2['PRI'] = 34)] = 'PRI';
      METHODS2[(METHODS2['DESCRIBE'] = 35)] = 'DESCRIBE';
      METHODS2[(METHODS2['ANNOUNCE'] = 36)] = 'ANNOUNCE';
      METHODS2[(METHODS2['SETUP'] = 37)] = 'SETUP';
      METHODS2[(METHODS2['PLAY'] = 38)] = 'PLAY';
      METHODS2[(METHODS2['PAUSE'] = 39)] = 'PAUSE';
      METHODS2[(METHODS2['TEARDOWN'] = 40)] = 'TEARDOWN';
      METHODS2[(METHODS2['GET_PARAMETER'] = 41)] = 'GET_PARAMETER';
      METHODS2[(METHODS2['SET_PARAMETER'] = 42)] = 'SET_PARAMETER';
      METHODS2[(METHODS2['REDIRECT'] = 43)] = 'REDIRECT';
      METHODS2[(METHODS2['RECORD'] = 44)] = 'RECORD';
      METHODS2[(METHODS2['FLUSH'] = 45)] = 'FLUSH';
    })((METHODS = exports.METHODS || (exports.METHODS = {})));
    exports.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS['M-SEARCH'],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      METHODS.SOURCE,
    ];
    exports.METHODS_ICE = [METHODS.SOURCE];
    exports.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      METHODS.GET,
      METHODS.POST,
    ];
    exports.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports.H_METHOD_MAP = {};
    Object.keys(exports.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function (FINISH2) {
      FINISH2[(FINISH2['SAFE'] = 0)] = 'SAFE';
      FINISH2[(FINISH2['SAFE_WITH_CB'] = 1)] = 'SAFE_WITH_CB';
      FINISH2[(FINISH2['UNSAFE'] = 2)] = 'UNSAFE';
    })((FINISH = exports.FINISH || (exports.FINISH = {})));
    exports.ALPHA = [];
    for (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {
      exports.ALPHA.push(String.fromCharCode(i));
      exports.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
    };
    exports.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15,
    };
    exports.NUM = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
    exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
    exports.MARK = ['-', '_', '.', '!', '~', '*', "'", '(', ')'];
    exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(['%', ';', ':', '&', '=', '+', '$', ',']);
    exports.STRICT_URL_CHAR = [
      '!',
      '"',
      '$',
      '%',
      '&',
      "'",
      '(',
      ')',
      '*',
      '+',
      ',',
      '-',
      '.',
      '/',
      ':',
      ';',
      '<',
      '=',
      '>',
      '@',
      '[',
      '\\',
      ']',
      '^',
      '_',
      '`',
      '{',
      '|',
      '}',
      '~',
    ].concat(exports.ALPHANUM);
    exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(['	', '\f']);
    for (let i = 128; i <= 255; i++) {
      exports.URL_CHAR.push(i);
    }
    exports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);
    exports.STRICT_TOKEN = ['!', '#', '$', '%', '&', "'", '*', '+', '-', '.', '^', '_', '`', '|', '~'].concat(
      exports.ALPHANUM
    );
    exports.TOKEN = exports.STRICT_TOKEN.concat([' ']);
    exports.HEADER_CHARS = ['	'];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports.HEADER_CHARS.push(i);
      }
    }
    exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
    exports.MAJOR = exports.NUM_MAP;
    exports.MINOR = exports.MAJOR;
    var HEADER_STATE;
    (function (HEADER_STATE2) {
      HEADER_STATE2[(HEADER_STATE2['GENERAL'] = 0)] = 'GENERAL';
      HEADER_STATE2[(HEADER_STATE2['CONNECTION'] = 1)] = 'CONNECTION';
      HEADER_STATE2[(HEADER_STATE2['CONTENT_LENGTH'] = 2)] = 'CONTENT_LENGTH';
      HEADER_STATE2[(HEADER_STATE2['TRANSFER_ENCODING'] = 3)] = 'TRANSFER_ENCODING';
      HEADER_STATE2[(HEADER_STATE2['UPGRADE'] = 4)] = 'UPGRADE';
      HEADER_STATE2[(HEADER_STATE2['CONNECTION_KEEP_ALIVE'] = 5)] = 'CONNECTION_KEEP_ALIVE';
      HEADER_STATE2[(HEADER_STATE2['CONNECTION_CLOSE'] = 6)] = 'CONNECTION_CLOSE';
      HEADER_STATE2[(HEADER_STATE2['CONNECTION_UPGRADE'] = 7)] = 'CONNECTION_UPGRADE';
      HEADER_STATE2[(HEADER_STATE2['TRANSFER_ENCODING_CHUNKED'] = 8)] = 'TRANSFER_ENCODING_CHUNKED';
    })((HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {})));
    exports.SPECIAL_HEADERS = {
      connection: HEADER_STATE.CONNECTION,
      'content-length': HEADER_STATE.CONTENT_LENGTH,
      'proxy-connection': HEADER_STATE.CONNECTION,
      'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,
      upgrade: HEADER_STATE.UPGRADE,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/handler/RedirectHandler.js'(exports, module2) {
    'use strict';
    var util = require_util2();
    var { kBodyUsed } = require_symbols();
    var assert = require('assert');
    var { InvalidArgumentError } = require_errors();
    var EE = require('events');
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol('body');
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], 'disturbed');
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError('maxRedirections must be a positive number');
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = __spreadProps(__spreadValues({}, opts), { maxRedirections: 0 });
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on('data', function () {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== 'boolean') {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, 'data', function () {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (
          this.opts.body &&
          typeof this.opts.body !== 'string' &&
          !ArrayBuffer.isView(this.opts.body) &&
          util.isIterable(this.opts.body)
        ) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location =
          this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)
            ? null
            : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(
          new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))
        );
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== 'HEAD') {
          this.opts.method = 'GET';
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === 'location') {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      return (
        (header.length === 4 && header.toString().toLowerCase() === 'host') ||
        (removeContent && header.toString().toLowerCase().indexOf('content-') === 0) ||
        (unknownOrigin && header.length === 13 && header.toString().toLowerCase() === 'authorization') ||
        (unknownOrigin && header.length === 6 && header.toString().toLowerCase() === 'cookie')
      );
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === 'object') {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, 'headers must be an object or an array');
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/interceptor/redirectInterceptor.js'(exports, module2) {
    'use strict';
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = __spreadProps(__spreadValues({}, opts), { maxRedirections: 0 });
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/llhttp/llhttp-wasm.js'(exports, module2) {
    module2.exports =
      'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCsLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=';
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js'(exports, module2) {
    module2.exports =
      'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==';
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/client.js
var require_client = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/client.js'(exports, module2) {
    'use strict';
    var assert = require('assert');
    var net = require('net');
    var http = require('http');
    var { pipeline } = require('stream');
    var util = require_util2();
    var timers = require_timers();
    var Request = require_request2();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError,
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest,
    } = require_symbols();
    var http2;
    try {
      http2 = require('http2');
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS,
      },
    } = http2;
    var h2ExperimentalWarned = false;
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = Symbol('kClosedResolve');
    var channels = {};
    try {
      const diagnosticsChannel = require('diagnostics_channel');
      channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');
      channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');
      channels.connectError = diagnosticsChannel.channel('undici:client:connectError');
      channels.connected = diagnosticsChannel.channel('undici:client:connected');
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client = class extends DispatcherBase {
      constructor(
        url,
        {
          interceptors,
          maxHeaderSize,
          headersTimeout,
          socketTimeout,
          requestTimeout,
          connectTimeout,
          bodyTimeout,
          idleTimeout,
          keepAlive,
          keepAliveTimeout,
          maxKeepAliveTimeout,
          keepAliveMaxTimeout,
          keepAliveTimeoutThreshold,
          socketPath,
          pipelining,
          tls,
          strictContentLength,
          maxCachedSessions,
          maxRedirections,
          connect: connect2,
          maxRequestsPerClient,
          localAddress,
          maxResponseSize,
          autoSelectFamily,
          autoSelectFamilyAttemptTimeout,
          allowH2,
          maxConcurrentStreams,
        } = {}
      ) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError('invalid maxHeaderSize');
        }
        if (socketPath != null && typeof socketPath !== 'string') {
          throw new InvalidArgumentError('invalid socketPath');
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError('invalid connectTimeout');
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError('invalid keepAliveTimeout');
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError('invalid keepAliveMaxTimeout');
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');
        }
        if (connect2 != null && typeof connect2 !== 'function' && typeof connect2 !== 'object') {
          throw new InvalidArgumentError('connect must be a function or an object');
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError('maxRedirections must be a positive number');
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');
        }
        if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError('localAddress must be valid string IP address');
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError('maxResponseSize must be a positive number');
        }
        if (
          autoSelectFamilyAttemptTimeout != null &&
          (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)
        ) {
          throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number');
        }
        if (allowH2 != null && typeof allowH2 !== 'boolean') {
          throw new InvalidArgumentError('allowH2 must be a valid boolean value');
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError('maxConcurrentStreams must be a possitive integer, greater than 0');
        }
        if (typeof connect2 !== 'function') {
          connect2 = buildConnector(
            __spreadValues(
              __spreadValues(
                __spreadProps(__spreadValues({}, tls), {
                  maxCachedSessions,
                  allowH2,
                  socketPath,
                  timeout: connectTimeout,
                }),
                util.nodeHasAutoSelectFamily && autoSelectFamily
                  ? { autoSelectFamily, autoSelectFamilyAttemptTimeout }
                  : void 0
              ),
              connect2
            )
          );
        }
        this[kInterceptors] =
          interceptors && interceptors.Client && Array.isArray(interceptors.Client)
            ? interceptors.Client
            : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = 'h1';
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2
          ? null
          : {
              openStreams: 0,
              maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100,
            };
        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}`;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return (
          (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||
          this[kSize] >= (this[kPipelining] || 1) ||
          this[kPending] > 0
        );
      }
      [kConnect](cb) {
        connect(this);
        this.once('connect', cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request =
          this[kHTTPConnVersion] === 'h2'
            ? Request[kHTTP2BuildRequest](origin, opts, handler)
            : Request[kHTTP1BuildRequest](origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (!this[kSize]) {
            resolve(null);
          } else {
            this[kClosedResolve] = resolve;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve();
          };
          if (this[kHTTP2Session] != null) {
            util.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on('close', callback), err);
          }
          resume(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
    function onHttp2FrameError(type, code, id) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }
    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError('other side closed'));
      util.destroy(this[kSocket], new SocketError('other side closed'));
    }
    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
      client[kSocket] = null;
      client[kHTTP2Session] = null;
      if (client.destroyed) {
        assert(this[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit('disconnect', client[kUrl], [client], err);
      resume(client);
    }
    var constants = require_constants2();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), 'base64'));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), 'base64'));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          },
        },
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports2 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports2;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = '';
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = '';
        this.contentLength = '';
        this.connection = '';
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = '';
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message =
                'Response does not match the HTTP/1.1 protocol (' +
                Buffer.from(llhttp.memory.buffer, ptr, len).toString() +
                ')';
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === 'CONNECT');
        this.statusCode = null;
        this.statusText = '';
        this.shouldKeepAlive = null;
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket
          .removeListener('error', onSocketError)
          .removeListener('readable', onSocketReadable)
          .removeListener('end', onSocketEnd)
          .removeListener('close', onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));
          return -1;
        }
        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive =
          shouldKeepAlive ||
          (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive');
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === 'CONNECT') {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        let pause;
        try {
          pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        } catch (err) {
          util.destroy(socket, err);
          return -1;
        }
        if (request.method === 'HEAD') {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        try {
          if (request.onData(buf) === false) {
            return constants.ERROR.PAUSED;
          }
        } catch (err) {
          util.destroy(socket, err);
          return -1;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(statusCode >= 100);
        this.statusCode = null;
        this.statusText = '';
        this.bytesRead = 0;
        this.contentLength = '';
        this.keepAlive = '';
        this.connection = '';
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        try {
          request.onComplete(headers);
        } catch (err) {
          errorRequest(client, request, err);
        }
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError('reset'));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError('reset'));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError('reset'));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!parser.paused, 'cannot be paused while waiting for headers');
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError('socket idle timeout'));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      if (parser) {
        parser.readMore();
      }
    }
    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser } = this;
      assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');
      if (client[kHTTPConnVersion] !== 'h2') {
        if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== 'h2') {
        if (parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser } = this;
      if (client[kHTTPConnVersion] === 'h1' && parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit('disconnect', client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === '[') {
        const idx = hostname.indexOf(']');
        assert(idx !== -1);
        const ip = hostname.substr(1, idx - 1);
        assert(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress],
          },
          connector: client[kConnector],
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector](
            {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress],
            },
            (err, socket2) => {
              if (err) {
                reject(err);
              } else {
                resolve(socket2);
              }
            }
          );
        });
        if (client.destroyed) {
          util.destroy(
            socket.on('error', () => {}),
            new ClientDestroyedError()
          );
          return;
        }
        client[kConnecting] = false;
        assert(socket);
        const isH2 = socket.alpnProtocol === 'h2';
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning('H2 support is experimental, expect them to change at any time.', {
              code: 'UNDICI-H2',
            });
          }
          const session = http2.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams,
          });
          client[kHTTPConnVersion] = 'h2';
          session[kClient] = client;
          session[kSocket] = socket;
          session.on('error', onHttp2SessionError);
          session.on('frameError', onHttp2FrameError);
          session.on('end', onHttp2SessionEnd);
          session.on('goaway', onHTTP2GoAway);
          session.on('close', onSocketClose);
          session.unref();
          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }
          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        socket
          .on('error', onSocketError)
          .on('readable', onSocketReadable)
          .on('end', onSocketEnd)
          .on('close', onSocketClose);
        client[kSocket] = socket;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress],
            },
            connector: client[kConnector],
            socket,
          });
        }
        client.emit('connect', client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress],
            },
            connector: client[kConnector],
            error: err,
          });
        }
        if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit('connectionError', client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit('drain', client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== 'h2') {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout =
                request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError('servername changed'));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {
          return;
        }
        if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {
          request.body
            .on('data', function () {
              assert(false);
            })
            .on('error', function (err) {
              errorRequest(client, request, err);
            })
            .on('end', function () {
              util.destroy(this);
            });
          request.body = null;
        }
        if (client[kRunning] > 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === 'h2') {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      const { body, method, path, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';
      if (body && typeof body.read === 'function') {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util.destroy(socket, new InformationalError('aborted'));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === 'HEAD') {
        socket[kReset] = true;
      }
      if (upgrade || method === 'CONNECT') {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === 'string') {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += 'connection: keep-alive\r\n';
      } else {
        header += 'connection: close\r\n';
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body) {
        if (contentLength === 0) {
          socket.write(
            `${header}content-length: 0\r
\r
`,
            'latin1'
          );
        } else {
          assert(contentLength === null, 'no body must not have content length');
          socket.write(
            `${header}\r
`,
            'latin1'
          );
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, 'buffer body must have content length');
        socket.cork();
        socket.write(
          `${header}content-length: ${contentLength}\r
\r
`,
          'latin1'
        );
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === 'function') {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert(false);
      }
      return true;
    }
    function writeH2(client, session, request) {
      const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let headers;
      if (typeof reqHeaders === 'string') headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
      else headers = reqHeaders;
      if (upgrade) {
        errorRequest(client, request, new Error('Upgrade not supported for H2'));
        return false;
      }
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      let stream;
      const h2State = client[kHTTP2SessionState];
      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;
      if (method === 'CONNECT') {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        } else {
          stream.once('ready', () => {
            request.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          });
        }
        stream.once('close', () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0) session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path;
      headers[HTTP2_HEADER_SCHEME] = 'https';
      const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';
      if (body && typeof body.read === 'function') {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, 'no body must not have content length');
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === 'GET' || method === 'HEAD';
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = '100-continue';
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once('continue', writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal,
        });
        writeBodyH2();
      }
      ++h2State.openStreams;
      stream.once('response', (headers2) => {
        if (
          request.onHeaders(Number(headers2[HTTP2_HEADER_STATUS]), headers2, stream.resume.bind(stream), '') === false
        ) {
          stream.pause();
        }
      });
      stream.once('end', () => {
        request.onComplete([]);
      });
      stream.on('data', (chunk) => {
        if (request.onData(chunk) === false) stream.pause();
      });
      stream.once('close', () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0) session.unref();
      });
      stream.once('error', function (err) {
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      stream.once('frameError', (type, code) => {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        errorRequest(client, request, err);
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      return true;
      function writeBodyH2() {
        if (!body) {
          request.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, 'buffer body must have content length');
          stream.cork();
          stream.write(body);
          stream.uncork();
          stream.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === 'function') {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: '',
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream,
              header: '',
              socket: client[kSocket],
            });
          }
        } else if (util.isStream(body)) {
          writeStream({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream,
            header: '',
          });
        } else if (util.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: '',
            h2stream: stream,
            socket: client[kSocket],
          });
        } else {
          assert(false);
        }
      }
    }
    function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');
      if (client[kHTTPConnVersion] === 'h2') {
        let onPipeData = function (chunk) {
          request.onBodySent(chunk);
        };
        const pipe = pipeline(body, h2stream, (err) => {
          if (err) {
            util.destroy(body, err);
            util.destroy(h2stream, err);
          } else {
            request.onRequestSent();
          }
        });
        pipe.on('data', onPipeData);
        pipe.once('end', () => {
          pipe.removeListener('data', onPipeData);
          util.destroy(pipe);
        });
        return;
      }
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function (chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function () {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function () {
        onFinished(new RequestAbortedError());
      };
      const onFinished = function (err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1));
        socket.off('drain', onDrain).off('error', onFinished);
        body
          .removeListener('data', onData)
          .removeListener('end', onFinished)
          .removeListener('error', onFinished)
          .removeListener('close', onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on('drain', onDrain).on('error', onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength === body.size, 'blob body must have content length');
      const isH2 = client[kHTTPConnVersion] === 'h2';
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(
            `${header}content-length: ${contentLength}\r
\r
`,
            'latin1'
          );
          socket.write(buffer);
          socket.uncork();
        }
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () =>
        new Promise((resolve, reject) => {
          assert(callback === null);
          if (socket[kError]) {
            reject(socket[kError]);
          } else {
            callback = resolve;
          }
        });
      if (client[kHTTPConnVersion] === 'h2') {
        h2stream.on('close', onDrain).on('drain', onDrain);
        try {
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            const res = h2stream.write(chunk);
            request.onBodySent(chunk);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off('close', onDrain).off('drain', onDrain);
        }
        return;
      }
      socket.on('close', onDrain).on('drain', onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off('close', onDrain).off('drain', onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(
              `${header}transfer-encoding: chunked\r
`,
              'latin1'
            );
          } else {
            socket.write(
              `${header}content-length: ${contentLength}\r
\r
`,
              'latin1'
            );
          }
        }
        if (contentLength === null) {
          socket.write(
            `\r
${len.toString(16)}\r
`,
            'latin1'
          );
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(
              `${header}content-length: 0\r
\r
`,
              'latin1'
            );
          } else {
            socket.write(
              `${header}\r
`,
              'latin1'
            );
          }
        } else if (contentLength === null) {
          socket.write('\r\n0\r\n\r\n', 'latin1');
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, 'pipeline should only contain this request');
          util.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit('error', err2);
      }
    }
    module2.exports = Client;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/node/fixed-queue.js'(exports, module2) {
    'use strict';
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return ((this.top + 1) & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = (this.top + 1) & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0) return null;
        this.list[this.bottom] = void 0;
        this.bottom = (this.bottom + 1) & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/pool-stats.js'(exports, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol('pool');
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/pool-base.js'(exports, module2) {
    'use strict';
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } =
      require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol('clients');
    var kNeedDrain = Symbol('needDrain');
    var kQueue = Symbol('queue');
    var kClosedResolve = Symbol('closed resolve');
    var kOnDrain = Symbol('onDrain');
    var kOnConnect = Symbol('onConnect');
    var kOnDisconnect = Symbol('onDisconnect');
    var kOnConnectionError = Symbol('onConnectionError');
    var kGetDispatcher = Symbol('get dispatcher');
    var kAddClient = Symbol('add client');
    var kRemoveClient = Symbol('remove client');
    var kStats = Symbol('stats');
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit('drain', origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit('connect', origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit('disconnect', origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit('connectionError', origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client
          .on('drain', this[kOnDrain])
          .on('connect', this[kOnConnect])
          .on('disconnect', this[kOnDisconnect])
          .on('connectionError', this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some(
          (dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true
        );
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/pool.js'(exports, module2) {
    'use strict';
    var { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } = require_pool_base();
    var Client = require_client();
    var { InvalidArgumentError } = require_errors();
    var util = require_util2();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol('options');
    var kConnections = Symbol('connections');
    var kFactory = Symbol('factory');
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, _a = {}) {
        var _b = _a,
          {
            connections,
            factory = defaultFactory,
            connect,
            connectTimeout,
            tls,
            maxCachedSessions,
            socketPath,
            autoSelectFamily,
            autoSelectFamilyAttemptTimeout,
            allowH2,
          } = _b,
          options = __objRest(_b, [
            'connections',
            'factory',
            'connect',
            'connectTimeout',
            'tls',
            'maxCachedSessions',
            'socketPath',
            'autoSelectFamily',
            'autoSelectFamilyAttemptTimeout',
            'allowH2',
          ]);
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError('invalid connections');
        }
        if (typeof factory !== 'function') {
          throw new InvalidArgumentError('factory must be a function.');
        }
        if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
          throw new InvalidArgumentError('connect must be a function or an object');
        }
        if (typeof connect !== 'function') {
          connect = buildConnector(
            __spreadValues(
              __spreadValues(
                __spreadProps(__spreadValues({}, tls), {
                  maxCachedSessions,
                  allowH2,
                  socketPath,
                  timeout: connectTimeout == null ? 1e4 : connectTimeout,
                }),
                util.nodeHasAutoSelectFamily && autoSelectFamily
                  ? { autoSelectFamily, autoSelectFamilyAttemptTimeout }
                  : void 0
              ),
              connect
            )
          );
        }
        this[kInterceptors] =
          options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool)
            ? options.interceptors.Pool
            : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = __spreadProps(__spreadValues({}, util.deepClone(options)), { connect, allowH2 });
        this[kOptions].interceptors = options.interceptors ? __spreadValues({}, options.interceptors) : void 0;
        this[kFactory] = factory;
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module2.exports = Pool;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/balanced-pool.js'(exports, module2) {
    'use strict';
    var { BalancedPoolMissingUpstreamError, InvalidArgumentError } = require_errors();
    var { PoolBase, kClients, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util2();
    var kFactory = Symbol('factory');
    var kOptions = Symbol('options');
    var kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor');
    var kCurrentWeight = Symbol('kCurrentWeight');
    var kIndex = Symbol('kIndex');
    var kWeight = Symbol('kWeight');
    var kMaxWeightPerServer = Symbol('kMaxWeightPerServer');
    var kErrorPenalty = Symbol('kErrorPenalty');
    function getGreatestCommonDivisor(a, b) {
      if (b === 0) return a;
      return getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], _a = {}) {
        var _b = _a,
          { factory = defaultFactory } = _b,
          opts = __objRest(_b, ['factory']);
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== 'function') {
          throw new InvalidArgumentError('factory must be a function.');
        }
        this[kInterceptors] =
          opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)
            ? opts.interceptors.BalancedPool
            : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (
          this[kClients].find(
            (pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true
          )
        ) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on('connect', () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on('connectionError', () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on('disconnect', (...args) => {
          const err = args[2];
          if (err && err.code === 'UND_ERR_SOCKET') {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find(
          (pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true
        );
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients]
          .filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true)
          .map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find(
          (dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true
        );
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/compat/dispatcher-weakref.js'(exports, module2) {
    'use strict';
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on('disconnect', () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    };
    module2.exports = function () {
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer,
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer,
      };
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/agent.js'(exports, module2) {
    'use strict';
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client = require_client();
    var util = require_util2();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = Symbol('onConnect');
    var kOnDisconnect = Symbol('onDisconnect');
    var kOnConnectionError = Symbol('onConnectionError');
    var kMaxRedirections = Symbol('maxRedirections');
    var kOnDrain = Symbol('onDrain');
    var kFactory = Symbol('factory');
    var kFinalizer = Symbol('finalizer');
    var kOptions = Symbol('options');
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor(_a = {}) {
        var _b = _a,
          { factory = defaultFactory, maxRedirections = 0, connect } = _b,
          options = __objRest(_b, ['factory', 'maxRedirections', 'connect']);
        super();
        if (typeof factory !== 'function') {
          throw new InvalidArgumentError('factory must be a function.');
        }
        if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
          throw new InvalidArgumentError('connect must be a function or an object');
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError('maxRedirections must be a positive number');
        }
        if (connect && typeof connect !== 'function') {
          connect = __spreadValues({}, connect);
        }
        this[kInterceptors] =
          options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent)
            ? options.interceptors.Agent
            : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = __spreadProps(__spreadValues({}, util.deepClone(options)), { connect });
        this[kOptions].interceptors = options.interceptors ? __spreadValues({}, options.interceptors) : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry((key) => {
          const ref = this[kClients].get(key);
          if (ref !== void 0 && ref.deref() === void 0) {
            this[kClients].delete(key);
          }
        });
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit('drain', origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit('connect', origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit('disconnect', origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit('connectionError', origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.');
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions])
            .on('drain', this[kOnDrain])
            .on('connect', this[kOnConnect])
            .on('disconnect', this[kOnDisconnect])
            .on('connectionError', this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/readable.js'(exports, module2) {
    'use strict';
    var assert = require('assert');
    var { Readable } = require('stream');
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
    var util = require_util2();
    var { ReadableStreamFrom, toUSVString } = require_util2();
    var Blob2;
    var kConsume = Symbol('kConsume');
    var kReading = Symbol('kReading');
    var kBody = Symbol('kBody');
    var kAbort = Symbol('abort');
    var kContentType = Symbol('kContentType');
    module2.exports = class BodyReadable extends Readable {
      constructor({ resume, abort, contentType = '', highWaterMark = 64 * 1024 }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark,
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === 'data') {
          this._readableState.dataEmitted = true;
        } else if (ev === 'error') {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === 'data' || ev === 'readable') {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === 'data' || ev === 'readable') {
          this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      async text() {
        return consume(this, 'text');
      }
      async json() {
        return consume(this, 'json');
      }
      async blob() {
        return consume(this, 'blob');
      }
      async arrayBuffer() {
        return consume(this, 'arrayBuffer');
      }
      async formData() {
        throw new NotSupportedError();
      }
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      async dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        const abortFn = () => {
          this.destroy();
        };
        let signalListenerCleanup;
        if (signal) {
          if (typeof signal !== 'object' || !('aborted' in signal)) {
            throw new InvalidArgumentError('signal must be an AbortSignal');
          }
          util.throwIfAborted(signal);
          signalListenerCleanup = util.addAbortListener(signal, abortFn);
        }
        try {
          for await (const chunk of this) {
            util.throwIfAborted(signal);
            limit -= Buffer.byteLength(chunk);
            if (limit < 0) {
              return;
            }
          }
        } catch {
          util.throwIfAborted(signal);
        } finally {
          if (typeof signalListenerCleanup === 'function') {
            signalListenerCleanup();
          } else if (signalListenerCleanup) {
            signalListenerCleanup[Symbol.dispose]();
          }
        }
      }
    };
    function isLocked(self) {
      return (self[kBody] && self[kBody].locked === true) || self[kConsume];
    }
    function isUnusable(self) {
      return util.isDisturbed(self) || isLocked(self);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError('unusable');
      }
      assert(!stream[kConsume]);
      return new Promise((resolve, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve,
          reject,
          length: 0,
          body: [],
        };
        stream
          .on('error', function (err) {
            consumeFinish(this[kConsume], err);
          })
          .on('close', function () {
            if (this[kConsume].body !== null) {
              consumeFinish(this[kConsume], new RequestAbortedError());
            }
          });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on('end', function () {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {}
    }
    function consumeEnd(consume2) {
      const { type, body, resolve, stream, length } = consume2;
      try {
        if (type === 'text') {
          resolve(toUSVString(Buffer.concat(body)));
        } else if (type === 'json') {
          resolve(JSON.parse(Buffer.concat(body)));
        } else if (type === 'arrayBuffer') {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve(dst.buffer);
        } else if (type === 'blob') {
          if (!Blob2) {
            Blob2 = require('buffer').Blob;
          }
          resolve(new Blob2(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/util.js
var require_util4 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/util.js'(exports, module2) {
    var assert = require('assert');
    var { ResponseStatusCodeError } = require_errors();
    var { toUSVString } = require_util2();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert(body);
      let chunks = [];
      let limit = 0;
      for await (const chunk of body) {
        chunks.push(chunk);
        limit += chunk.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(
          callback,
          new ResponseStatusCodeError(
            `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`,
            statusCode,
            headers
          )
        );
        return;
      }
      try {
        if (contentType.startsWith('application/json')) {
          const payload2 = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(
            callback,
            new ResponseStatusCodeError(
              `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`,
              statusCode,
              headers,
              payload2
            )
          );
          return;
        }
        if (contentType.startsWith('text/')) {
          const payload2 = toUSVString(Buffer.concat(chunks));
          process.nextTick(
            callback,
            new ResponseStatusCodeError(
              `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`,
              statusCode,
              headers,
              payload2
            )
          );
          return;
        }
      } catch (err) {}
      process.nextTick(
        callback,
        new ResponseStatusCodeError(
          `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`,
          statusCode,
          headers
        )
      );
    }
    module2.exports = { getResolveErrorBodyCallback };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/abort-signal.js'(exports, module2) {
    var { addAbortListener } = require_util2();
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol('kListener');
    var kSignal = Symbol('kSignal');
    function abort(self) {
      if (self.abort) {
        self.abort();
      } else {
        self.onError(new RequestAbortedError());
      }
    }
    function addSignal(self, signal) {
      self[kSignal] = null;
      self[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self);
        return;
      }
      self[kSignal] = signal;
      self[kListener] = () => {
        abort(self);
      };
      addAbortListener(self[kSignal], self[kListener]);
    }
    function removeSignal(self) {
      if (!self[kSignal]) {
        return;
      }
      if ('removeEventListener' in self[kSignal]) {
        self[kSignal].removeEventListener('abort', self[kListener]);
      } else {
        self[kSignal].removeListener('abort', self[kListener]);
      }
      self[kSignal] = null;
      self[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/api-request.js'(exports, module2) {
    'use strict';
    var Readable = require_readable();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var util = require_util2();
    var { getResolveErrorBodyCallback } = require_util4();
    var { AsyncResource } = require('async_hooks');
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== 'object') {
          throw new InvalidArgumentError('invalid opts');
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== 'function') {
            throw new InvalidArgumentError('invalid callback');
          }
          if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {
            throw new InvalidArgumentError('invalid highWaterMark');
          }
          if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
            throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
          }
          if (method === 'CONNECT') {
            throw new InvalidArgumentError('invalid method');
          }
          if (onInfo && typeof onInfo !== 'function') {
            throw new InvalidArgumentError('invalid onInfo callback');
          }
          super('UNDICI_REQUEST');
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on('error', util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        if (util.isStream(body)) {
          body.on('error', (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders['content-type'];
        const body = new Readable({ resume, abort, contentType, highWaterMark });
        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(getResolveErrorBodyCallback, null, {
              callback,
              body,
              contentType,
              statusCode,
              statusMessage,
              headers,
            });
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context,
            });
          }
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== 'function') {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/api-stream.js'(exports, module2) {
    'use strict';
    var { finished, PassThrough } = require('stream');
    var { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = require_errors();
    var util = require_util2();
    var { getResolveErrorBodyCallback } = require_util4();
    var { AsyncResource } = require('async_hooks');
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== 'object') {
          throw new InvalidArgumentError('invalid opts');
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== 'function') {
            throw new InvalidArgumentError('invalid callback');
          }
          if (typeof factory !== 'function') {
            throw new InvalidArgumentError('invalid factory');
          }
          if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
            throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
          }
          if (method === 'CONNECT') {
            throw new InvalidArgumentError('invalid method');
          }
          if (onInfo && typeof onInfo !== 'function') {
            throw new InvalidArgumentError('invalid onInfo callback');
          }
          super('UNDICI_STREAM');
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on('error', util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util.isStream(body)) {
          body.on('error', (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, callback, responseHeaders } = this;
        const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders['content-type'];
          res = new PassThrough();
          this.callback = null;
          this.runInAsyncScope(getResolveErrorBodyCallback, null, {
            callback,
            body: res,
            contentType,
            statusCode,
            statusMessage,
            headers,
          });
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context,
          });
          if (
            !res ||
            typeof res.write !== 'function' ||
            typeof res.end !== 'function' ||
            typeof res.on !== 'function'
          ) {
            throw new InvalidReturnValueError('expected Writable');
          }
          finished(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on('drain', resume);
        this.res = res;
        const needDrain =
          res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== 'function') {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/api-pipeline.js'(exports, module2) {
    'use strict';
    var { Readable, Duplex, PassThrough } = require('stream');
    var { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = require_errors();
    var util = require_util2();
    var { AsyncResource } = require('async_hooks');
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require('assert');
    var kResume = Symbol('resume');
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== 'object') {
          throw new InvalidArgumentError('invalid opts');
        }
        if (typeof handler !== 'function') {
          throw new InvalidArgumentError('invalid handler');
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
          throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
        }
        if (method === 'CONNECT') {
          throw new InvalidArgumentError('invalid method');
        }
        if (onInfo && typeof onInfo !== 'function') {
          throw new InvalidArgumentError('invalid onInfo callback');
        }
        super('UNDICI_PIPELINE');
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on('error', util.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          },
        }).on('prefinish', () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert(!res, 'pipeline cannot be retried');
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers =
              this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers =
            this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context,
          });
        } catch (err) {
          this.res.on('error', util.nop);
          throw err;
        }
        if (!body || typeof body.on !== 'function') {
          throw new InvalidReturnValueError('expected Readable');
        }
        body
          .on('data', (chunk) => {
            const { ret, body: body2 } = this;
            if (!ret.push(chunk) && body2.pause) {
              body2.pause();
            }
          })
          .on('error', (err) => {
            const { ret } = this;
            util.destroy(ret, err);
          })
          .on('end', () => {
            const { ret } = this;
            ret.push(null);
          })
          .on('close', () => {
            const { ret } = this;
            if (!ret._readableState.ended) {
              util.destroy(ret, new RequestAbortedError());
            }
          });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch(__spreadProps(__spreadValues({}, opts), { body: pipelineHandler.req }), pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/api-upgrade.js'(exports, module2) {
    'use strict';
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = require('async_hooks');
    var util = require_util2();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require('assert');
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== 'object') {
          throw new InvalidArgumentError('invalid opts');
        }
        if (typeof callback !== 'function') {
          throw new InvalidArgumentError('invalid callback');
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
          throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
        }
        super('UNDICI_UPGRADE');
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError('bad upgrade', null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers =
          this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context,
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch(
          __spreadProps(__spreadValues({}, opts), {
            method: opts.method || 'GET',
            upgrade: opts.protocol || 'Websocket',
          }),
          upgradeHandler
        );
      } catch (err) {
        if (typeof callback !== 'function') {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/api-connect.js'(exports, module2) {
    'use strict';
    var { AsyncResource } = require('async_hooks');
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var util = require_util2();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== 'object') {
          throw new InvalidArgumentError('invalid opts');
        }
        if (typeof callback !== 'function') {
          throw new InvalidArgumentError('invalid callback');
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
          throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
        }
        super('UNDICI_CONNECT');
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError('bad connect', null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context,
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch(__spreadProps(__spreadValues({}, opts), { method: 'CONNECT' }), connectHandler);
      } catch (err) {
        if (typeof callback !== 'function') {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/index.js
var require_api2 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/api/index.js'(exports, module2) {
    'use strict';
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-errors.js'(exports, module2) {
    'use strict';
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, MockNotMatchedError);
        this.name = 'MockNotMatchedError';
        this.message = message || 'The request does not match any registered mock dispatches';
        this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED';
      }
    };
    module2.exports = {
      MockNotMatchedError,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-symbols.js'(exports, module2) {
    'use strict';
    module2.exports = {
      kAgent: Symbol('agent'),
      kOptions: Symbol('options'),
      kFactory: Symbol('factory'),
      kDispatches: Symbol('dispatches'),
      kDispatchKey: Symbol('dispatch key'),
      kDefaultHeaders: Symbol('default headers'),
      kDefaultTrailers: Symbol('default trailers'),
      kContentLength: Symbol('content length'),
      kMockAgent: Symbol('mock agent'),
      kMockAgentSet: Symbol('mock agent set'),
      kMockAgentGet: Symbol('mock agent get'),
      kMockDispatch: Symbol('mock dispatch'),
      kClose: Symbol('close'),
      kOriginalClose: Symbol('original agent close'),
      kOrigin: Symbol('origin'),
      kIsMockActive: Symbol('is mock active'),
      kNetConnect: Symbol('net connect'),
      kGetNetConnect: Symbol('get net connect'),
      kConnected: Symbol('connected'),
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-utils.js'(exports, module2) {
    'use strict';
    var { MockNotMatchedError } = require_mock_errors();
    var { kDispatches, kMockAgent, kOriginalDispatch, kOrigin, kGetNetConnect } = require_mock_symbols();
    var { buildURL, nop } = require_util2();
    var { STATUS_CODES } = require('http');
    var {
      types: { isPromise },
    } = require('util');
    function matchValue(match, value) {
      if (typeof match === 'string') {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === 'function') {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === 'function') {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === 'function') {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === 'undefined') {
        return true;
      }
      if (typeof headers !== 'object' || typeof mockDispatch2.headers !== 'object') {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path) {
      if (typeof path !== 'string') {
        return path;
      }
      const pathSegments = path.split('?');
      if (pathSegments.length !== 2) {
        return path;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join('?');
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== 'undefined' ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === 'object') {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches
        .filter(({ consumed }) => !consumed)
        .filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) =>
        typeof body !== 'undefined' ? matchValue(body, key.body) : true
      );
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(
          `Mock dispatch not matched for headers '${
            typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers
          }'`
        );
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === 'function' ? { callback: data } : __spreadValues({}, data);
      const newMockDispatch = __spreadProps(__spreadValues(__spreadValues({}, baseData), key), {
        pending: true,
        data: __spreadValues({ error: null }, replyData),
      });
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query,
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce(
        (keyValuePairs, [key, value]) => [
          ...keyValuePairs,
          Buffer.from(`${key}`),
          Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`),
        ],
        []
      );
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || 'unknown';
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString('utf8');
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = __spreadValues(__spreadValues({}, mockDispatch2.data), mockDispatch2.data.callback(opts));
      }
      const {
        data: { statusCode, data, headers, trailers, error },
        delay,
        persist,
      } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === 'number' && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body =
          typeof _data === 'function'
            ? _data(__spreadProps(__spreadValues({}, opts), { headers: optsHeaders }))
            : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {}
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(
                  `${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`
                );
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(
                  `${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`
                );
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const _a = opts,
          { agent } = _a,
          mockOptions = __objRest(_a, ['agent']);
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-interceptor.js'(exports, module2) {
    'use strict';
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var { kDispatches, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } =
      require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util2();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      delay(waitInMs) {
        if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError('waitInMs must be a valid integer > 0');
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      times(repeatTimes) {
        if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError('repeatTimes must be a valid integer > 0');
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== 'object') {
          throw new InvalidArgumentError('opts must be an object');
        }
        if (typeof opts.path === 'undefined') {
          throw new InvalidArgumentError('opts.path must be defined');
        }
        if (typeof opts.method === 'undefined') {
          opts.method = 'GET';
        }
        if (typeof opts.path === 'string') {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, 'data://');
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === 'string') {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {};
        const headers = __spreadValues(
          __spreadValues(__spreadValues({}, this[kDefaultHeaders]), contentLength),
          responseOptions.headers
        );
        const trailers = __spreadValues(__spreadValues({}, this[kDefaultTrailers]), responseOptions.trailers);
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === 'undefined') {
          throw new InvalidArgumentError('statusCode must be defined');
        }
        if (typeof data === 'undefined') {
          throw new InvalidArgumentError('data must be defined');
        }
        if (typeof responseOptions !== 'object') {
          throw new InvalidArgumentError('responseOptions must be an object');
        }
      }
      reply(replyData) {
        if (typeof replyData === 'function') {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== 'object') {
              throw new InvalidArgumentError('reply options callback must return an object');
            }
            const { statusCode: statusCode2, data: data2 = '', responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return __spreadValues({}, this.createMockScopeDispatchData(statusCode2, data2, responseOptions2));
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = '', responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      replyWithError(error) {
        if (typeof error === 'undefined') {
          throw new InvalidArgumentError('error must be defined');
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
        return new MockScope(newMockDispatch);
      }
      defaultReplyHeaders(headers) {
        if (typeof headers === 'undefined') {
          throw new InvalidArgumentError('headers must be defined');
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      defaultReplyTrailers(trailers) {
        if (typeof trailers === 'undefined') {
          throw new InvalidArgumentError('trailers must be defined');
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-client.js'(exports, module2) {
    'use strict';
    var { promisify } = require('util');
    var Client = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } =
      require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
          throw new InvalidArgumentError('Argument opts.agent must implement Agent');
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-pool.js'(exports, module2) {
    'use strict';
    var { promisify } = require('util');
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } =
      require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
          throw new InvalidArgumentError('Argument opts.agent must implement Agent');
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/pluralizer.js'(exports, module2) {
    'use strict';
    var singulars = {
      pronoun: 'it',
      is: 'is',
      was: 'was',
      this: 'this',
    };
    var plurals = {
      pronoun: 'they',
      is: 'are',
      was: 'were',
      this: 'these',
    };
    module2.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return __spreadProps(__spreadValues({}, keys), { count, noun });
      }
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js'(exports, module2) {
    'use strict';
    var { Transform } = require('stream');
    var { Console } = require('console');
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          },
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI,
          },
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            'Status code': statusCode,
            Persistent: persist ? '\u2705' : '\u274C',
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked,
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/mock/mock-agent.js'(exports, module2) {
    'use strict';
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory,
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== 'function') {
          throw new InvalidArgumentError('Argument opts.agent must implement Agent');
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === 'undefined') {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.');
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1
          ? new MockClient(origin, mockOptions)
          : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== 'string') {
          const dispatcher = this[kFactory]('http://localhost:9999');
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries())
          .flatMap(([origin, scope]) =>
            scope.deref()[kDispatches].map((dispatch) => __spreadProps(__spreadValues({}, dispatch), { origin }))
          )
          .filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length);
        throw new UndiciError(
          `
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim()
        );
      }
    };
    module2.exports = MockAgent;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/proxy-agent.js'(exports, module2) {
    'use strict';
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL2 } = require('url');
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol('proxy agent');
    var kClient = Symbol('proxy client');
    var kProxyHeaders = Symbol('proxy headers');
    var kRequestTls = Symbol('request tls settings');
    var kProxyTls = Symbol('proxy tls settings');
    var kConnectEndpoint = Symbol('connect endpoint function');
    function defaultProtocolPort(protocol) {
      return protocol === 'https:' ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === 'string') {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError('Proxy opts.uri is mandatory');
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || 'https',
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] =
          opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)
            ? opts.interceptors.ProxyAgent
            : [];
        if (typeof opts === 'string') {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError('Proxy opts.uri is mandatory');
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== 'function') {
          throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.');
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token');
        } else if (opts.auth) {
          this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]['proxy-authorization'] = opts.token;
        }
        const resolvedUrl = new URL2(opts.uri);
        const { origin, port, host } = resolvedUrl;
        const connect = buildConnector(__spreadValues({}, opts.proxyTls));
        this[kConnectEndpoint] = buildConnector(__spreadValues({}, opts.requestTls));
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent(
          __spreadProps(__spreadValues({}, opts), {
            connect: async (opts2, callback) => {
              let requestedHost = opts2.host;
              if (!opts2.port) {
                requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
              }
              try {
                const { socket, statusCode } = await this[kClient].connect({
                  origin,
                  port,
                  path: requestedHost,
                  signal: opts2.signal,
                  headers: __spreadProps(__spreadValues({}, this[kProxyHeaders]), {
                    host,
                  }),
                });
                if (statusCode !== 200) {
                  socket.on('error', () => {}).destroy();
                  callback(new RequestAbortedError('Proxy response !== 200 when HTTP Tunneling'));
                }
                if (opts2.protocol !== 'https:') {
                  callback(null, socket);
                  return;
                }
                let servername;
                if (this[kRequestTls]) {
                  servername = this[kRequestTls].servername;
                } else {
                  servername = opts2.servername;
                }
                this[kConnectEndpoint](
                  __spreadProps(__spreadValues({}, opts2), { servername, httpSocket: socket }),
                  callback
                );
              } catch (err) {
                callback(err);
              }
            },
          })
        );
      }
      dispatch(opts, handler) {
        const { host } = new URL2(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          __spreadProps(__spreadValues({}, opts), {
            headers: __spreadProps(__spreadValues({}, headers), {
              host,
            }),
          }),
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === 'proxy-authorization');
      if (existProxyAuth) {
        throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor');
      }
    }
    module2.exports = ProxyAgent;
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/global.js
var require_global3 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/global.js'(exports, module2) {
    'use strict';
    var globalDispatcher = Symbol.for('undici.globalDispatcher.1');
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== 'function') {
        throw new InvalidArgumentError('Argument agent must implement Agent');
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false,
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/handler/DecoratorHandler.js'(exports, module2) {
    'use strict';
    module2.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/headers.js'(exports, module2) {
    'use strict';
    var { kHeadersList } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util2();
    var { makeIterator, isValidHeaderName, isValidHeaderValue } = require_util3();
    var { webidl } = require_webidl();
    var assert = require('assert');
    var kHeadersMap = Symbol('headers map');
    var kHeadersSortedMap = Symbol('headers map sorted');
    function headerValueNormalize(potentialValue) {
      let i = potentialValue.length;
      while (/[\r\n\t ]/.test(potentialValue.charAt(--i)));
      return potentialValue.slice(0, i + 1).replace(/^[\r\n\t ]+/, '');
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (const header of object) {
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: 'Headers constructor',
              message: `expected name/value pair to be length 2, found ${header.length}.`,
            });
          }
          headers.append(header[0], header[1]);
        }
      } else if (typeof object === 'object' && object !== null) {
        for (const [key, value] of Object.entries(object)) {
          headers.append(key, value);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: 'Headers constructor',
          argument: 'Argument 1',
          types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>'],
        });
      }
    }
    var HeadersList = class {
      cookies = null;
      constructor(init) {
        if (init instanceof HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies;
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      append(name, value) {
        var _a;
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === 'cookie' ? '; ' : ', ';
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`,
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === 'set-cookie') {
          (_a = this.cookies) != null ? _a : (this.cookies = []);
          this.cookies.push(value);
        }
      }
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        if (lowercaseName === 'set-cookie') {
          this.cookies = [value];
        }
        return this[kHeadersMap].set(lowercaseName, { name, value });
      }
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        if (name === 'set-cookie') {
          this.cookies = null;
        }
        return this[kHeadersMap].delete(name);
      }
      get(name) {
        var _a, _b;
        if (!this.contains(name)) {
          return null;
        }
        return (_b = (_a = this[kHeadersMap].get(name.toLowerCase())) == null ? void 0 : _a.value) != null ? _b : null;
      }
      *[Symbol.iterator]() {
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
    };
    var Headers = class {
      constructor(init = void 0) {
        this[kHeadersList] = new HeadersList();
        this[kGuard] = 'none';
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }
      append(name, value) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: 'Headers.append',
            value: name,
            type: 'header name',
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: 'Headers.append',
            value,
            type: 'header value',
          });
        }
        if (this[kGuard] === 'immutable') {
          throw new TypeError('immutable');
        } else if (this[kGuard] === 'request-no-cors') {
        }
        return this[kHeadersList].append(name, value);
      }
      delete(name) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: 'Headers.delete',
            value: name,
            type: 'header name',
          });
        }
        if (this[kGuard] === 'immutable') {
          throw new TypeError('immutable');
        } else if (this[kGuard] === 'request-no-cors') {
        }
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        return this[kHeadersList].delete(name);
      }
      get(name) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: 'Headers.get',
            value: name,
            type: 'header name',
          });
        }
        return this[kHeadersList].get(name);
      }
      has(name) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: 'Headers.has',
            value: name,
            type: 'header name',
          });
        }
        return this[kHeadersList].contains(name);
      }
      set(name, value) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: 'Headers.set',
            value: name,
            type: 'header name',
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: 'Headers.set',
            value,
            type: 'header value',
          });
        }
        if (this[kGuard] === 'immutable') {
          throw new TypeError('immutable');
        } else if (this[kGuard] === 'request-no-cors') {
        }
        return this[kHeadersList].set(name, value);
      }
      getSetCookie() {
        webidl.brandCheck(this, Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a, b) => (a[0] < b[0] ? -1 : 1));
        const cookies = this[kHeadersList].cookies;
        for (const [name, value] of names) {
          if (name === 'set-cookie') {
            for (const value2 of cookies) {
              headers.push([name, value2]);
            }
          } else {
            assert(value !== null);
            headers.push([name, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, Headers);
        return makeIterator(() => [...this[kHeadersSortedMap].values()], 'Headers', 'key');
      }
      values() {
        webidl.brandCheck(this, Headers);
        return makeIterator(() => [...this[kHeadersSortedMap].values()], 'Headers', 'value');
      }
      entries() {
        webidl.brandCheck(this, Headers);
        return makeIterator(() => [...this[kHeadersSortedMap].values()], 'Headers', 'key+value');
      }
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.forEach' });
        if (typeof callbackFn !== 'function') {
          throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.for('nodejs.util.inspect.custom')]() {
        webidl.brandCheck(this, Headers);
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: 'Headers',
        configurable: true,
      },
    });
    webidl.converters.HeadersInit = function (V) {
      if (webidl.util.Type(V) === 'Object') {
        if (V[Symbol.iterator]) {
          return webidl.converters['sequence<sequence<ByteString>>'](V);
        }
        return webidl.converters['record<ByteString, ByteString>'](V);
      }
      throw webidl.errors.conversionFailed({
        prefix: 'Headers constructor',
        argument: 'Argument 1',
        types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>'],
      });
    };
    module2.exports = {
      fill,
      Headers,
      HeadersList,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/response.js
var require_response2 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/response.js'(exports, module2) {
    'use strict';
    var { Headers, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util2();
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode,
    } = require_util3();
    var { redirectStatusSet, nullBodyStatus, DOMException: DOMException2 } = require_constants();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData } = require_formdata();
    var { getGlobalOrigin } = require_global2();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList } = require_symbols();
    var assert = require('assert');
    var { types } = require('util');
    var ReadableStream = globalThis.ReadableStream || require('stream/web').ReadableStream;
    var textEncoder = new TextEncoder('utf-8');
    var Response = class {
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = 'immutable';
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: 'Response.json' });
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = 'response';
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init, { body: body[0], type: 'application/json' });
        return responseObject;
      }
      static redirect(url, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: 'Response.redirect' });
        url = webidl.converters.USVString(url);
        status = webidl.converters['unsigned short'](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError('Failed to parse URL from ' + url), {
            cause: err,
          });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError('Invalid status code ' + status);
        }
        const responseObject = new Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = 'immutable';
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append('location', value);
        return responseObject;
      }
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers();
        this[kHeaders][kGuard] = 'response';
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      get type() {
        webidl.brandCheck(this, Response);
        return this[kState].type;
      }
      get url() {
        var _a;
        webidl.brandCheck(this, Response);
        const urlList = this[kState].urlList;
        const url = (_a = urlList[urlList.length - 1]) != null ? _a : null;
        if (url === null) {
          return '';
        }
        return URLSerializer(url, true);
      }
      get redirected() {
        webidl.brandCheck(this, Response);
        return this[kState].urlList.length > 1;
      }
      get status() {
        webidl.brandCheck(this, Response);
        return this[kState].status;
      }
      get ok() {
        webidl.brandCheck(this, Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      get statusText() {
        webidl.brandCheck(this, Response);
        return this[kState].statusText;
      }
      get headers() {
        webidl.brandCheck(this, Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, Response);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      clone() {
        webidl.brandCheck(this, Response);
        if (this.bodyUsed || (this.body && this.body.locked)) {
          throw webidl.errors.exception({
            header: 'Response.clone',
            message: 'Body has already been consumed.',
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: 'Response',
        configurable: true,
      },
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty,
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(cloneResponse(response.internalResponse), response.type);
      }
      const newResponse = makeResponse(__spreadProps(__spreadValues({}, response), { body: null }));
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return __spreadProps(
        __spreadValues(
          {
            aborted: false,
            rangeRequested: false,
            timingAllowPassed: false,
            requestIncludesCredentials: false,
            type: 'default',
            status: 200,
            timingInfo: null,
            cacheState: '',
            statusText: '',
          },
          init
        ),
        {
          headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
          urlList: init.urlList ? [...init.urlList] : [],
        }
      );
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: 'error',
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === 'AbortError',
      });
    }
    function makeFilteredResponse(response, state) {
      state = __spreadValues(
        {
          internalResponse: response,
        },
        state
      );
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        },
      });
    }
    function filterResponse(response, type) {
      if (type === 'basic') {
        return makeFilteredResponse(response, {
          type: 'basic',
          headersList: response.headersList,
        });
      } else if (type === 'cors') {
        return makeFilteredResponse(response, {
          type: 'cors',
          headersList: response.headersList,
        });
      } else if (type === 'opaque') {
        return makeFilteredResponse(response, {
          type: 'opaque',
          urlList: Object.freeze([]),
          status: 0,
          statusText: '',
          body: null,
        });
      } else if (type === 'opaqueredirect') {
        return makeFilteredResponse(response, {
          type: 'opaqueredirect',
          status: 0,
          statusText: '',
          headersList: [],
          body: null,
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams)
        ? makeNetworkError(Object.assign(new DOMException2('The operation was aborted.', 'AbortError'), { cause: err }))
        : makeNetworkError(Object.assign(new DOMException2('Request was cancelled.'), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ('statusText' in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError('Invalid statusText');
        }
      }
      if ('status' in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ('statusText' in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ('headers' in init && init.headers != null) {
        fill(response[kHeaders], init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: 'Response constructor',
            message: 'Invalid response status code ' + response.status,
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains('Content-Type')) {
          response[kState].headersList.append('content-type', body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
    webidl.converters.FormData = webidl.interfaceConverter(FormData);
    webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
    webidl.converters.XMLHttpRequestBodyInit = function (V) {
      if (typeof V === 'string') {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function (V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }
      if (V == null ? void 0 : V[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: 'status',
        converter: webidl.converters['unsigned short'],
        defaultValue: 200,
      },
      {
        key: 'statusText',
        converter: webidl.converters.ByteString,
        defaultValue: '',
      },
      {
        key: 'headers',
        converter: webidl.converters.HeadersInit,
      },
    ]);
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/request.js
var require_request3 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/request.js'(exports, module2) {
    'use strict';
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util = require_util2();
    var { isValidHTTPToken, sameOrigin, normalizeMethod, makePolicyContainer } = require_util3();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex,
    } = require_constants();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global2();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList } = require_symbols();
    var assert = require('assert');
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require('events');
    var TransformStream = globalThis.TransformStream;
    var kInit = Symbol('init');
    var kAbortController = Symbol('abortController');
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener('abort', abort);
    });
    var Request = class {
      constructor(input, init = {}) {
        var _a, _b;
        if (input === kInit) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: 'Request constructor' });
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              var _a2;
              return (_a2 = this.baseUrl) == null ? void 0 : _a2.origin;
            },
            policyContainer: makePolicyContainer(),
          },
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === 'string') {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError('Failed to parse URL from ' + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError('Request cannot be constructed from a URL that includes credentials: ' + input);
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = 'cors';
        } else {
          assert(input instanceof Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window2 = 'client';
        if (
          ((_b = (_a = request.window) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name) ===
            'EnvironmentSettingsObject' &&
          sameOrigin(request.window, origin)
        ) {
          window2 = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window2}' must be null`);
        }
        if ('window' in init) {
          window2 = 'no-window';
        }
        request = makeRequest({
          method: request.method,
          headersList: request.headersList,
          unsafeRequest: request.unsafeRequest,
          client: this[kRealm].settingsObject,
          window: window2,
          priority: request.priority,
          origin: request.origin,
          referrer: request.referrer,
          referrerPolicy: request.referrerPolicy,
          mode: request.mode,
          credentials: request.credentials,
          cache: request.cache,
          redirect: request.redirect,
          integrity: request.integrity,
          keepalive: request.keepalive,
          reloadNavigation: request.reloadNavigation,
          historyNavigation: request.historyNavigation,
          urlList: [...request.urlList],
        });
        if (Object.keys(init).length > 0) {
          if (request.mode === 'navigate') {
            request.mode = 'same-origin';
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = 'client';
          request.referrer = 'client';
          request.referrerPolicy = '';
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === '') {
            request.referrer = 'no-referrer';
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (
              (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||
              (origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl))
            ) {
              request.referrer = 'client';
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === 'navigate') {
          throw webidl.errors.exception({
            header: 'Request constructor',
            message: 'invalid request mode navigate.',
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {
          throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity !== void 0 && init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(init.method)) {
            throw TypeError(`'${init.method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw TypeError(`'${init.method}' HTTP method is unsupported.`);
          }
          method = normalizeMethod(init.method);
          request.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== 'boolean' || typeof signal.addEventListener !== 'function') {
            throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = function () {
              const ac2 = acRef.deref();
              if (ac2 !== void 0) {
                ac2.abort(this.reason);
              }
            };
            try {
              if (typeof getMaxListeners === 'function' && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(100, signal);
              } else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {}
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }
        this[kHeaders] = new Headers();
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = 'request';
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === 'no-cors') {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
          }
          this[kHeaders][kGuard] = 'request-no-cors';
        }
        if (Object.keys(init).length !== 0) {
          let headers = new Headers(this[kHeaders]);
          if (init.headers !== void 0) {
            headers = init.headers;
          }
          this[kHeaders][kHeadersList].clear();
          if (headers.constructor.name === 'Headers') {
            for (const [key, val] of headers) {
              this[kHeaders].append(key, val);
            }
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === 'GET' || request.method === 'HEAD')) {
          throw new TypeError('Request with GET/HEAD method cannot have body.');
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains('content-type')) {
            this[kHeaders].append('content-type', contentType);
          }
        }
        const inputOrInitBody = initBody != null ? initBody : inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError('RequestInit: duplex option is required when sending a body.');
          }
          if (request.mode !== 'same-origin' && request.mode !== 'cors') {
            throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError('Cannot construct a Request with a Request object that has already been used.');
          }
          if (!TransformStream) {
            TransformStream = require('stream/web').TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable,
          };
        }
        this[kState].body = finalBody;
      }
      get method() {
        webidl.brandCheck(this, Request);
        return this[kState].method;
      }
      get url() {
        webidl.brandCheck(this, Request);
        return URLSerializer(this[kState].url);
      }
      get headers() {
        webidl.brandCheck(this, Request);
        return this[kHeaders];
      }
      get destination() {
        webidl.brandCheck(this, Request);
        return this[kState].destination;
      }
      get referrer() {
        webidl.brandCheck(this, Request);
        if (this[kState].referrer === 'no-referrer') {
          return '';
        }
        if (this[kState].referrer === 'client') {
          return 'about:client';
        }
        return this[kState].referrer.toString();
      }
      get referrerPolicy() {
        webidl.brandCheck(this, Request);
        return this[kState].referrerPolicy;
      }
      get mode() {
        webidl.brandCheck(this, Request);
        return this[kState].mode;
      }
      get credentials() {
        return this[kState].credentials;
      }
      get cache() {
        webidl.brandCheck(this, Request);
        return this[kState].cache;
      }
      get redirect() {
        webidl.brandCheck(this, Request);
        return this[kState].redirect;
      }
      get integrity() {
        webidl.brandCheck(this, Request);
        return this[kState].integrity;
      }
      get keepalive() {
        webidl.brandCheck(this, Request);
        return this[kState].keepalive;
      }
      get isReloadNavigation() {
        webidl.brandCheck(this, Request);
        return this[kState].reloadNavigation;
      }
      get isHistoryNavigation() {
        webidl.brandCheck(this, Request);
        return this[kState].historyNavigation;
      }
      get signal() {
        webidl.brandCheck(this, Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, Request);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, Request);
        return 'half';
      }
      clone() {
        var _a;
        webidl.brandCheck(this, Request);
        if (this.bodyUsed || ((_a = this.body) == null ? void 0 : _a.locked)) {
          throw new TypeError('unusable');
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new Request(kInit);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers();
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util.addAbortListener(this.signal, () => {
            ac.abort(this.signal.reason);
          });
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      const request = __spreadProps(
        __spreadValues(
          {
            method: 'GET',
            localURLsOnly: false,
            unsafeRequest: false,
            body: null,
            client: null,
            reservedClient: null,
            replacesClientId: '',
            window: 'client',
            keepalive: false,
            serviceWorkers: 'all',
            initiator: '',
            destination: '',
            priority: null,
            origin: 'client',
            policyContainer: 'client',
            referrer: 'client',
            referrerPolicy: '',
            mode: 'no-cors',
            useCORSPreflightFlag: false,
            credentials: 'same-origin',
            useCredentials: false,
            cache: 'default',
            redirect: 'follow',
            integrity: '',
            cryptoGraphicsNonceMetadata: '',
            parserMetadata: '',
            reloadNavigation: false,
            historyNavigation: false,
            userActivation: false,
            taintedOrigin: false,
            redirectCount: 0,
            responseTainting: 'basic',
            preventNoCacheCacheControlHeaderModification: false,
            done: false,
            timingAllowFailed: false,
          },
          init
        ),
        {
          headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        }
      );
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest(__spreadProps(__spreadValues({}, request), { body: null }));
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: 'Request',
        configurable: true,
      },
    });
    webidl.converters.Request = webidl.interfaceConverter(Request);
    webidl.converters.RequestInfo = function (V) {
      if (typeof V === 'string') {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: 'method',
        converter: webidl.converters.ByteString,
      },
      {
        key: 'headers',
        converter: webidl.converters.HeadersInit,
      },
      {
        key: 'body',
        converter: webidl.nullableConverter(webidl.converters.BodyInit),
      },
      {
        key: 'referrer',
        converter: webidl.converters.USVString,
      },
      {
        key: 'referrerPolicy',
        converter: webidl.converters.DOMString,
        allowedValues: referrerPolicy,
      },
      {
        key: 'mode',
        converter: webidl.converters.DOMString,
        allowedValues: requestMode,
      },
      {
        key: 'credentials',
        converter: webidl.converters.DOMString,
        allowedValues: requestCredentials,
      },
      {
        key: 'cache',
        converter: webidl.converters.DOMString,
        allowedValues: requestCache,
      },
      {
        key: 'redirect',
        converter: webidl.converters.DOMString,
        allowedValues: requestRedirect,
      },
      {
        key: 'integrity',
        converter: webidl.converters.DOMString,
      },
      {
        key: 'keepalive',
        converter: webidl.converters.boolean,
      },
      {
        key: 'signal',
        converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, { strict: false })),
      },
      {
        key: 'window',
        converter: webidl.converters.any,
      },
      {
        key: 'duplex',
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex,
      },
    ]);
    module2.exports = { Request, makeRequest };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fetch/index.js'(exports, module2) {
    'use strict';
    var { Response, makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse } = require_response2();
    var { Headers } = require_headers();
    var { Request, makeRequest } = require_request3();
    var zlib = require('zlib');
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme,
    } = require_util3();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var assert = require('assert');
    var { safelyExtractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2,
    } = require_constants();
    var { kHeadersList } = require_symbols();
    var EE = require('events');
    var { Readable, pipeline } = require('stream');
    var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util2();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = require('stream/web');
    var { getGlobalDispatcher } = require_global3();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require('http');
    var GET_OR_HEAD = ['GET', 'HEAD'];
    var resolveObjectURL;
    var ReadableStream = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = 'ongoing';
        this.setMaxListeners(21);
      }
      terminate(reason) {
        var _a;
        if (this.state !== 'ongoing') {
          return;
        }
        this.state = 'terminated';
        (_a = this.connection) == null ? void 0 : _a.destroy(reason);
        this.emit('terminated', reason);
      }
      abort(error) {
        var _a;
        if (this.state !== 'ongoing') {
          return;
        }
        this.state = 'aborted';
        if (!error) {
          error = new DOMException2('The operation was aborted.', 'AbortError');
        }
        this.serializedAbortReason = error;
        (_a = this.connection) == null ? void 0 : _a.destroy(error);
        this.emit('terminated', error);
      }
    };
    function fetch(input, init = {}) {
      var _a, _b;
      webidl.argumentLengthCheck(arguments, 1, { header: 'globalThis.fetch' });
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (
        ((_a = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a.name) ===
        'ServiceWorkerGlobalScope'
      ) {
        request.serviceWorkers = 'none';
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(requestObject.signal, () => {
        locallyAborted = true;
        assert(controller != null);
        controller.abort(requestObject.signal.reason);
        abortFetch(p, request, responseObject, requestObject.signal.reason);
      });
      const handleFetchDone = (response) => finalizeAndReportTiming(response, 'fetch');
      const processResponse = (response) => {
        if (locallyAborted) {
          return Promise.resolve();
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return Promise.resolve();
        }
        if (response.type === 'error') {
          p.reject(Object.assign(new TypeError('fetch failed'), { cause: response.error }));
          return Promise.resolve();
        }
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = 'immutable';
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: (_b = init.dispatcher) != null ? _b : getGlobalDispatcher(),
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = 'other') {
      var _a;
      if (response.type === 'error' && response.aborted) {
        return;
      }
      if (!((_a = response.urlList) == null ? void 0 : _a.length)) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!timingInfo.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime,
        });
        cacheState = '';
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 2)) {
        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject, error) {
      var _a, _b;
      if (!error) {
        error = new DOMException2('The operation was aborted.', 'AbortError');
      }
      p.reject(error);
      if (request.body != null && isReadable((_a = request.body) == null ? void 0 : _a.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === 'ERR_INVALID_STATE') {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable((_b = response.body) == null ? void 0 : _b.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === 'ERR_INVALID_STATE') {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher,
    }) {
      var _a, _b, _c, _d;
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime,
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability,
      };
      assert(!request.body || request.body.stream);
      if (request.window === 'client') {
        request.window =
          ((_c = (_b = (_a = request.client) == null ? void 0 : _a.globalObject) == null ? void 0 : _b.constructor) ==
          null
            ? void 0
            : _c.name) === 'Window'
            ? request.client
            : 'no-window';
      }
      if (request.origin === 'client') {
        request.origin = (_d = request.client) == null ? void 0 : _d.origin;
      }
      if (request.policyContainer === 'client') {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(request.client.policyContainer);
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains('accept')) {
        const value = '*/*';
        request.headersList.append('accept', value);
      }
      if (!request.headersList.contains('accept-language')) {
        request.headersList.append('accept-language', '*');
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError('local URLs only');
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === 'blocked') {
        response = makeNetworkError('bad port');
      }
      if (request.referrerPolicy === '') {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== 'no-referrer') {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||
            currentURL.protocol === 'data:' ||
            request.mode === 'navigate' ||
            request.mode === 'websocket'
          ) {
            request.responseTainting = 'basic';
            return await schemeFetch(fetchParams);
          }
          if (request.mode === 'same-origin') {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === 'no-cors') {
            if (request.redirect !== 'follow') {
              return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
            }
            request.responseTainting = 'opaque';
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError('URL scheme must be a HTTP(S) scheme');
          }
          request.responseTainting = 'cors';
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === 'cors') {
        }
        if (request.responseTainting === 'basic') {
          response = filterResponse(response, 'basic');
        } else if (request.responseTainting === 'cors') {
          response = filterResponse(response, 'cors');
        } else if (request.responseTainting === 'opaque') {
          response = filterResponse(response, 'opaque');
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (
        response.type === 'opaque' &&
        internalResponse.status === 206 &&
        internalResponse.rangeRequested &&
        !request.headers.contains('range')
      ) {
        response = internalResponse = makeNetworkError();
      }
      if (
        response.status !== 0 &&
        (request.method === 'HEAD' || request.method === 'CONNECT' || nullBodyStatus.includes(internalResponse.status))
      ) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === 'opaque' || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError('integrity mismatch');
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      var _a;
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case 'about:': {
          return Promise.resolve(makeNetworkError('about scheme is not supported'));
        }
        case 'blob:': {
          if (!resolveObjectURL) {
            resolveObjectURL = require('buffer').resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'));
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== 'GET' || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError('invalid method'));
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type = (_a = bodyWithType[1]) != null ? _a : '';
          const response = makeResponse({
            statusText: 'OK',
            headersList: [
              ['content-length', { name: 'Content-Length', value: length }],
              ['content-type', { name: 'Content-Type', value: type }],
            ],
          });
          response.body = body;
          return Promise.resolve(response);
        }
        case 'data:': {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === 'failure') {
            return Promise.resolve(makeNetworkError('failed to fetch the data URL'));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(
            makeResponse({
              statusText: 'OK',
              headersList: [['content-type', { name: 'Content-Type', value: mimeType }]],
              body: safelyExtractBody(dataURLStruct.body)[0],
            })
          );
        }
        case 'file:': {
          return Promise.resolve(makeNetworkError('not implemented... yet...'));
        }
        case 'http:':
        case 'https:': {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError('unknown scheme'));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      if (response.type === 'error') {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime,
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream(
          {
            start() {},
            transform: identityTransformAlgorithm,
            flush: processResponseEndOfBody,
          },
          {
            size() {
              return 1;
            },
          },
          {
            size() {
              return 1;
            },
          }
        );
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === 'all') {
      }
      if (response === null) {
        if (request.redirect === 'follow') {
          request.serviceWorkers = 'none';
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === 'cors' && corsCheck(request, response) === 'failure') {
          return makeNetworkError('cors failure');
        }
        if (TAOCheck(request, response) === 'failure') {
          request.timingAllowFailed = true;
        }
      }
      if (
        (request.responseTainting === 'opaque' || response.type === 'opaque') &&
        crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) ===
          'blocked'
      ) {
        return makeNetworkError('blocked');
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== 'manual') {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === 'error') {
          response = makeNetworkError('unexpected redirect');
        } else if (request.redirect === 'manual') {
          response = actualResponse;
        } else if (request.redirect === 'follow') {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError('redirect count exceeded'));
      }
      request.redirectCount += 1;
      if (
        request.mode === 'cors' &&
        (locationURL.username || locationURL.password) &&
        !sameOrigin(request, locationURL)
      ) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === 'cors' && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if (
        ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||
        (actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method))
      ) {
        request.method = 'GET';
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete('authorization');
        request.headersList.delete('cookie');
        request.headersList.delete('host');
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(
        fetchParams.crossOriginIsolatedCapability
      );
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === 'no-window' && request.redirect === 'error') {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = __spreadValues({}, fetchParams);
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials =
        request.credentials === 'include' ||
        (request.credentials === 'same-origin' && request.responseTainting === 'basic');
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ['POST', 'PUT'].includes(httpRequest.method)) {
        contentLengthHeaderValue = '0';
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append('content-length', contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains('user-agent')) {
        httpRequest.headersList.append('user-agent', typeof esbuildDetection === 'undefined' ? 'undici' : 'node');
      }
      if (
        httpRequest.cache === 'default' &&
        (httpRequest.headersList.contains('if-modified-since') ||
          httpRequest.headersList.contains('if-none-match') ||
          httpRequest.headersList.contains('if-unmodified-since') ||
          httpRequest.headersList.contains('if-match') ||
          httpRequest.headersList.contains('if-range'))
      ) {
        httpRequest.cache = 'no-store';
      }
      if (
        httpRequest.cache === 'no-cache' &&
        !httpRequest.preventNoCacheCacheControlHeaderModification &&
        !httpRequest.headersList.contains('cache-control')
      ) {
        httpRequest.headersList.append('cache-control', 'max-age=0');
      }
      if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {
        if (!httpRequest.headersList.contains('pragma')) {
          httpRequest.headersList.append('pragma', 'no-cache');
        }
        if (!httpRequest.headersList.contains('cache-control')) {
          httpRequest.headersList.append('cache-control', 'no-cache');
        }
      }
      if (httpRequest.headersList.contains('range')) {
        httpRequest.headersList.append('accept-encoding', 'identity');
      }
      if (!httpRequest.headersList.contains('accept-encoding')) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate');
        } else {
          httpRequest.headersList.append('accept-encoding', 'gzip, deflate');
        }
      }
      httpRequest.headersList.delete('host');
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = 'no-store';
      }
      if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {
      }
      if (response == null) {
        if (httpRequest.mode === 'only-if-cached') {
          return makeNetworkError('only if cached');
        }
        const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains('range')) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === 'no-window') {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError('proxy authentication required');
      }
      if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          var _a;
          if (!this.destroyed) {
            this.destroyed = true;
            (_a = this.abort) == null
              ? void 0
              : _a.call(this, err != null ? err : new DOMException2('The operation was aborted.', 'AbortError'));
          }
        },
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = 'no-store';
      }
      const newConnection = forceNewConnection ? 'yes' : 'no';
      if (request.mode === 'websocket') {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          var _a;
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          (_a = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a.call(fetchParams, bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === 'AbortError') {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = (async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        })();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === 'AbortError') {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream) {
        ReadableStream = require('stream/web').ReadableStream;
      }
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          },
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          },
        }
      );
      response.body = { stream };
      fetchParams.controller.on('terminated', onAborted);
      fetchParams.controller.resume = async () => {
        var _a;
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += (_a = bytes == null ? void 0 : bytes.byteLength) != null ? _a : 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              new TypeError('terminated', {
                cause: isErrorLike(reason) ? reason : void 0,
              })
            );
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve, reject) =>
          agent.dispatch(
            {
              path: url.pathname + url.search,
              origin: url.origin,
              method: request.method,
              body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,
              headers: request.headersList.entries,
              maxRedirections: 0,
              upgrade: request.mode === 'websocket' ? 'websocket' : void 0,
            },
            {
              body: null,
              abort: null,
              onConnect(abort) {
                const { connection } = fetchParams.controller;
                if (connection.destroyed) {
                  abort(new DOMException2('The operation was aborted.', 'AbortError'));
                } else {
                  fetchParams.controller.on('terminated', abort);
                  this.abort = connection.abort = abort;
                }
              },
              onHeaders(status, headersList, resume, statusText) {
                if (status < 200) {
                  return;
                }
                let codings = [];
                let location = '';
                const headers = new Headers();
                if (Array.isArray(headersList)) {
                  for (let n = 0; n < headersList.length; n += 2) {
                    const key = headersList[n + 0].toString('latin1');
                    const val = headersList[n + 1].toString('latin1');
                    if (key.toLowerCase() === 'content-encoding') {
                      codings = val
                        .toLowerCase()
                        .split(',')
                        .map((x) => x.trim());
                    } else if (key.toLowerCase() === 'location') {
                      location = val;
                    }
                    headers.append(key, val);
                  }
                } else {
                  const keys = Object.keys(headersList);
                  for (const key of keys) {
                    const val = headersList[key];
                    if (key.toLowerCase() === 'content-encoding') {
                      codings = val
                        .toLowerCase()
                        .split(',')
                        .map((x) => x.trim())
                        .reverse();
                    } else if (key.toLowerCase() === 'location') {
                      location = val;
                    }
                    headers.append(key, val);
                  }
                }
                this.body = new Readable({ read: resume });
                const decoders = [];
                const willFollow = request.redirect === 'follow' && location && redirectStatusSet.has(status);
                if (
                  request.method !== 'HEAD' &&
                  request.method !== 'CONNECT' &&
                  !nullBodyStatus.includes(status) &&
                  !willFollow
                ) {
                  for (const coding of codings) {
                    if (coding === 'x-gzip' || coding === 'gzip') {
                      decoders.push(
                        zlib.createGunzip({
                          flush: zlib.constants.Z_SYNC_FLUSH,
                          finishFlush: zlib.constants.Z_SYNC_FLUSH,
                        })
                      );
                    } else if (coding === 'deflate') {
                      decoders.push(zlib.createInflate());
                    } else if (coding === 'br') {
                      decoders.push(zlib.createBrotliDecompress());
                    } else {
                      decoders.length = 0;
                      break;
                    }
                  }
                }
                resolve({
                  status,
                  statusText,
                  headersList: headers[kHeadersList],
                  body: decoders.length ? pipeline(this.body, ...decoders, () => {}) : this.body.on('error', () => {}),
                });
                return true;
              },
              onData(chunk) {
                if (fetchParams.controller.dump) {
                  return;
                }
                const bytes = chunk;
                timingInfo.encodedBodySize += bytes.byteLength;
                return this.body.push(bytes);
              },
              onComplete() {
                if (this.abort) {
                  fetchParams.controller.off('terminated', this.abort);
                }
                fetchParams.controller.ended = true;
                this.body.push(null);
              },
              onError(error) {
                var _a;
                if (this.abort) {
                  fetchParams.controller.off('terminated', this.abort);
                }
                (_a = this.body) == null ? void 0 : _a.destroy(error);
                fetchParams.controller.terminate(error);
                reject(error);
              },
              onUpgrade(status, headersList, socket) {
                if (status !== 101) {
                  return;
                }
                const headers = new Headers();
                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString('latin1');
                  const val = headersList[n + 1].toString('latin1');
                  headers.append(key, val);
                }
                resolve({
                  status,
                  statusText: STATUS_CODES[status],
                  headersList: headers[kHeadersList],
                  socket,
                });
                return true;
              },
            }
          )
        );
      }
    }
    module2.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fileapi/symbols.js'(exports, module2) {
    'use strict';
    module2.exports = {
      kState: Symbol('FileReader state'),
      kResult: Symbol('FileReader result'),
      kError: Symbol('FileReader error'),
      kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),
      kEvents: Symbol('FileReader events'),
      kAborted: Symbol('FileReader aborted'),
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fileapi/progressevent.js'(exports, module2) {
    'use strict';
    var { webidl } = require_webidl();
    var kState = Symbol('ProgressEvent state');
    var ProgressEvent = class extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict != null ? eventInitDict : {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total,
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: 'lengthComputable',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: 'loaded',
        converter: webidl.converters['unsigned long long'],
        defaultValue: 0,
      },
      {
        key: 'total',
        converter: webidl.converters['unsigned long long'],
        defaultValue: 0,
      },
      {
        key: 'bubbles',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: 'cancelable',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: 'composed',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
    ]);
    module2.exports = {
      ProgressEvent,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fileapi/encoding.js'(exports, module2) {
    'use strict';
    function getEncoding(label) {
      if (!label) {
        return 'failure';
      }
      switch (label.trim().toLowerCase()) {
        case 'unicode-1-1-utf-8':
        case 'unicode11utf8':
        case 'unicode20utf8':
        case 'utf-8':
        case 'utf8':
        case 'x-unicode20utf8':
          return 'UTF-8';
        case '866':
        case 'cp866':
        case 'csibm866':
        case 'ibm866':
          return 'IBM866';
        case 'csisolatin2':
        case 'iso-8859-2':
        case 'iso-ir-101':
        case 'iso8859-2':
        case 'iso88592':
        case 'iso_8859-2':
        case 'iso_8859-2:1987':
        case 'l2':
        case 'latin2':
          return 'ISO-8859-2';
        case 'csisolatin3':
        case 'iso-8859-3':
        case 'iso-ir-109':
        case 'iso8859-3':
        case 'iso88593':
        case 'iso_8859-3':
        case 'iso_8859-3:1988':
        case 'l3':
        case 'latin3':
          return 'ISO-8859-3';
        case 'csisolatin4':
        case 'iso-8859-4':
        case 'iso-ir-110':
        case 'iso8859-4':
        case 'iso88594':
        case 'iso_8859-4':
        case 'iso_8859-4:1988':
        case 'l4':
        case 'latin4':
          return 'ISO-8859-4';
        case 'csisolatincyrillic':
        case 'cyrillic':
        case 'iso-8859-5':
        case 'iso-ir-144':
        case 'iso8859-5':
        case 'iso88595':
        case 'iso_8859-5':
        case 'iso_8859-5:1988':
          return 'ISO-8859-5';
        case 'arabic':
        case 'asmo-708':
        case 'csiso88596e':
        case 'csiso88596i':
        case 'csisolatinarabic':
        case 'ecma-114':
        case 'iso-8859-6':
        case 'iso-8859-6-e':
        case 'iso-8859-6-i':
        case 'iso-ir-127':
        case 'iso8859-6':
        case 'iso88596':
        case 'iso_8859-6':
        case 'iso_8859-6:1987':
          return 'ISO-8859-6';
        case 'csisolatingreek':
        case 'ecma-118':
        case 'elot_928':
        case 'greek':
        case 'greek8':
        case 'iso-8859-7':
        case 'iso-ir-126':
        case 'iso8859-7':
        case 'iso88597':
        case 'iso_8859-7':
        case 'iso_8859-7:1987':
        case 'sun_eu_greek':
          return 'ISO-8859-7';
        case 'csiso88598e':
        case 'csisolatinhebrew':
        case 'hebrew':
        case 'iso-8859-8':
        case 'iso-8859-8-e':
        case 'iso-ir-138':
        case 'iso8859-8':
        case 'iso88598':
        case 'iso_8859-8':
        case 'iso_8859-8:1988':
        case 'visual':
          return 'ISO-8859-8';
        case 'csiso88598i':
        case 'iso-8859-8-i':
        case 'logical':
          return 'ISO-8859-8-I';
        case 'csisolatin6':
        case 'iso-8859-10':
        case 'iso-ir-157':
        case 'iso8859-10':
        case 'iso885910':
        case 'l6':
        case 'latin6':
          return 'ISO-8859-10';
        case 'iso-8859-13':
        case 'iso8859-13':
        case 'iso885913':
          return 'ISO-8859-13';
        case 'iso-8859-14':
        case 'iso8859-14':
        case 'iso885914':
          return 'ISO-8859-14';
        case 'csisolatin9':
        case 'iso-8859-15':
        case 'iso8859-15':
        case 'iso885915':
        case 'iso_8859-15':
        case 'l9':
          return 'ISO-8859-15';
        case 'iso-8859-16':
          return 'ISO-8859-16';
        case 'cskoi8r':
        case 'koi':
        case 'koi8':
        case 'koi8-r':
        case 'koi8_r':
          return 'KOI8-R';
        case 'koi8-ru':
        case 'koi8-u':
          return 'KOI8-U';
        case 'csmacintosh':
        case 'mac':
        case 'macintosh':
        case 'x-mac-roman':
          return 'macintosh';
        case 'iso-8859-11':
        case 'iso8859-11':
        case 'iso885911':
        case 'tis-620':
        case 'windows-874':
          return 'windows-874';
        case 'cp1250':
        case 'windows-1250':
        case 'x-cp1250':
          return 'windows-1250';
        case 'cp1251':
        case 'windows-1251':
        case 'x-cp1251':
          return 'windows-1251';
        case 'ansi_x3.4-1968':
        case 'ascii':
        case 'cp1252':
        case 'cp819':
        case 'csisolatin1':
        case 'ibm819':
        case 'iso-8859-1':
        case 'iso-ir-100':
        case 'iso8859-1':
        case 'iso88591':
        case 'iso_8859-1':
        case 'iso_8859-1:1987':
        case 'l1':
        case 'latin1':
        case 'us-ascii':
        case 'windows-1252':
        case 'x-cp1252':
          return 'windows-1252';
        case 'cp1253':
        case 'windows-1253':
        case 'x-cp1253':
          return 'windows-1253';
        case 'cp1254':
        case 'csisolatin5':
        case 'iso-8859-9':
        case 'iso-ir-148':
        case 'iso8859-9':
        case 'iso88599':
        case 'iso_8859-9':
        case 'iso_8859-9:1989':
        case 'l5':
        case 'latin5':
        case 'windows-1254':
        case 'x-cp1254':
          return 'windows-1254';
        case 'cp1255':
        case 'windows-1255':
        case 'x-cp1255':
          return 'windows-1255';
        case 'cp1256':
        case 'windows-1256':
        case 'x-cp1256':
          return 'windows-1256';
        case 'cp1257':
        case 'windows-1257':
        case 'x-cp1257':
          return 'windows-1257';
        case 'cp1258':
        case 'windows-1258':
        case 'x-cp1258':
          return 'windows-1258';
        case 'x-mac-cyrillic':
        case 'x-mac-ukrainian':
          return 'x-mac-cyrillic';
        case 'chinese':
        case 'csgb2312':
        case 'csiso58gb231280':
        case 'gb2312':
        case 'gb_2312':
        case 'gb_2312-80':
        case 'gbk':
        case 'iso-ir-58':
        case 'x-gbk':
          return 'GBK';
        case 'gb18030':
          return 'gb18030';
        case 'big5':
        case 'big5-hkscs':
        case 'cn-big5':
        case 'csbig5':
        case 'x-x-big5':
          return 'Big5';
        case 'cseucpkdfmtjapanese':
        case 'euc-jp':
        case 'x-euc-jp':
          return 'EUC-JP';
        case 'csiso2022jp':
        case 'iso-2022-jp':
          return 'ISO-2022-JP';
        case 'csshiftjis':
        case 'ms932':
        case 'ms_kanji':
        case 'shift-jis':
        case 'shift_jis':
        case 'sjis':
        case 'windows-31j':
        case 'x-sjis':
          return 'Shift_JIS';
        case 'cseuckr':
        case 'csksc56011987':
        case 'euc-kr':
        case 'iso-ir-149':
        case 'korean':
        case 'ks_c_5601-1987':
        case 'ks_c_5601-1989':
        case 'ksc5601':
        case 'ksc_5601':
        case 'windows-949':
          return 'EUC-KR';
        case 'csiso2022kr':
        case 'hz-gb-2312':
        case 'iso-2022-cn':
        case 'iso-2022-cn-ext':
        case 'iso-2022-kr':
        case 'replacement':
          return 'replacement';
        case 'unicodefffe':
        case 'utf-16be':
          return 'UTF-16BE';
        case 'csunicode':
        case 'iso-10646-ucs-2':
        case 'ucs-2':
        case 'unicode':
        case 'unicodefeff':
        case 'utf-16':
        case 'utf-16le':
          return 'UTF-16LE';
        case 'x-user-defined':
          return 'x-user-defined';
        default:
          return 'failure';
      }
    }
    module2.exports = {
      getEncoding,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fileapi/util.js
var require_util5 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fileapi/util.js'(exports, module2) {
    'use strict';
    var { kState, kError, kResult, kAborted, kLastProgressEventFired } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException: DOMException2 } = require_constants();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types } = require('util');
    var { StringDecoder } = require('string_decoder');
    var { btoa } = require('buffer');
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false,
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === 'loading') {
        throw new DOMException2('Invalid state', 'InvalidStateError');
      }
      fr[kState] = 'loading';
      fr[kResult] = null;
      fr[kError] = null;
      const stream = blob.stream();
      const reader = stream.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent('loadstart', fr);
              });
            }
            isFirstChunk = false;
            if (!done && types.isUint8Array(value)) {
              bytes.push(value);
              if (
                (fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) &&
                !fr[kAborted]
              ) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent('progress', fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = 'done';
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent('load', fr);
                } catch (error) {
                  fr[kError] = error;
                  fireAProgressEvent('error', fr);
                }
                if (fr[kState] !== 'loading') {
                  fireAProgressEvent('loadend', fr);
                }
              });
              break;
            }
          } catch (error) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = 'done';
              fr[kError] = error;
              fireAProgressEvent('error', fr);
              if (fr[kState] !== 'loading') {
                fireAProgressEvent('loadend', fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false,
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case 'DataURL': {
          let dataURL = 'data:';
          const parsed = parseMIMEType(mimeType || 'application/octet-stream');
          if (parsed !== 'failure') {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ';base64,';
          const decoder = new StringDecoder('latin1');
          for (const chunk of bytes) {
            dataURL += btoa(decoder.write(chunk));
          }
          dataURL += btoa(decoder.end());
          return dataURL;
        }
        case 'Text': {
          let encoding = 'failure';
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === 'failure' && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== 'failure') {
              encoding = getEncoding(type2.parameters.get('charset'));
            }
          }
          if (encoding === 'failure') {
            encoding = 'UTF-8';
          }
          return decode(bytes, encoding);
        }
        case 'ArrayBuffer': {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case 'BinaryString': {
          let binaryString = '';
          const decoder = new StringDecoder('latin1');
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === 'UTF-8' ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b, c] = ioQueue;
      if (a === 239 && b === 187 && c === 191) {
        return 'UTF-8';
      } else if (a === 254 && b === 255) {
        return 'UTF-16BE';
      } else if (a === 255 && b === 254) {
        return 'UTF-16LE';
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size));
    }
    module2.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/fileapi/filereader.js'(exports, module2) {
    'use strict';
    var { staticPropertyDescriptors, readOperation, fireAProgressEvent } = require_util5();
    var { kState, kError, kResult, kEvents, kAborted } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util2();
    var FileReader2 = class extends EventTarget {
      constructor() {
        super();
        this[kState] = 'empty';
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null,
        };
      }
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, FileReader2);
        webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsArrayBuffer' });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, 'ArrayBuffer');
      }
      readAsBinaryString(blob) {
        webidl.brandCheck(this, FileReader2);
        webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsBinaryString' });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, 'BinaryString');
      }
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, FileReader2);
        webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsText' });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, 'Text', encoding);
      }
      readAsDataURL(blob) {
        webidl.brandCheck(this, FileReader2);
        webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsDataURL' });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, 'DataURL');
      }
      abort() {
        if (this[kState] === 'empty' || this[kState] === 'done') {
          this[kResult] = null;
          return;
        }
        if (this[kState] === 'loading') {
          this[kState] = 'done';
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent('abort', this);
        if (this[kState] !== 'loading') {
          fireAProgressEvent('loadend', this);
        }
      }
      get readyState() {
        webidl.brandCheck(this, FileReader2);
        switch (this[kState]) {
          case 'empty':
            return this.EMPTY;
          case 'loading':
            return this.LOADING;
          case 'done':
            return this.DONE;
        }
      }
      get result() {
        webidl.brandCheck(this, FileReader2);
        return this[kResult];
      }
      get error() {
        webidl.brandCheck(this, FileReader2);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, FileReader2);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, FileReader2);
        if (this[kEvents].loadend) {
          this.removeEventListener('loadend', this[kEvents].loadend);
        }
        if (typeof fn === 'function') {
          this[kEvents].loadend = fn;
          this.addEventListener('loadend', fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, FileReader2);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, FileReader2);
        if (this[kEvents].error) {
          this.removeEventListener('error', this[kEvents].error);
        }
        if (typeof fn === 'function') {
          this[kEvents].error = fn;
          this.addEventListener('error', fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, FileReader2);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, FileReader2);
        if (this[kEvents].loadstart) {
          this.removeEventListener('loadstart', this[kEvents].loadstart);
        }
        if (typeof fn === 'function') {
          this[kEvents].loadstart = fn;
          this.addEventListener('loadstart', fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, FileReader2);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, FileReader2);
        if (this[kEvents].progress) {
          this.removeEventListener('progress', this[kEvents].progress);
        }
        if (typeof fn === 'function') {
          this[kEvents].progress = fn;
          this.addEventListener('progress', fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, FileReader2);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, FileReader2);
        if (this[kEvents].load) {
          this.removeEventListener('load', this[kEvents].load);
        }
        if (typeof fn === 'function') {
          this[kEvents].load = fn;
          this.addEventListener('load', fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, FileReader2);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, FileReader2);
        if (this[kEvents].abort) {
          this.removeEventListener('abort', this[kEvents].abort);
        }
        if (typeof fn === 'function') {
          this[kEvents].abort = fn;
          this.addEventListener('abort', fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader2.EMPTY = FileReader2.prototype.EMPTY = 0;
    FileReader2.LOADING = FileReader2.prototype.LOADING = 1;
    FileReader2.DONE = FileReader2.prototype.DONE = 2;
    Object.defineProperties(FileReader2.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: 'FileReader',
        writable: false,
        enumerable: false,
        configurable: true,
      },
    });
    Object.defineProperties(FileReader2, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
    });
    module2.exports = {
      FileReader: FileReader2,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cache/symbols.js'(exports, module2) {
    'use strict';
    module2.exports = {
      kConstruct: Symbol('constructable'),
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cache/util.js
var require_util6 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cache/util.js'(exports, module2) {
    'use strict';
    var assert = require('assert');
    var { URLSerializer } = require_dataURL();
    var { isValidHeaderName } = require_util3();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(',')) {
        value = value.trim();
        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      fieldValues,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cache/cache.js'(exports, module2) {
    'use strict';
    var { kConstruct } = require_symbols4();
    var { urlEquals, fieldValues: getFieldValues } = require_util6();
    var { kEnumerableProperty, isDisturbed } = require_util2();
    var { kHeadersList } = require_symbols();
    var { webidl } = require_webidl();
    var { Response, cloneResponse } = require_response2();
    var { Request } = require_request3();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util3();
    var assert = require('assert');
    var { getGlobalDispatcher } = require_global3();
    var _relevantRequestResponseList,
      _batchCacheOperations,
      batchCacheOperations_fn,
      _queryCache,
      queryCache_fn,
      _requestMatchesCachedItem,
      requestMatchesCachedItem_fn;
    var _Cache = class {
      constructor() {
        __privateAdd(this, _batchCacheOperations);
        __privateAdd(this, _queryCache);
        __privateAdd(this, _requestMatchesCachedItem);
        __privateAdd(this, _relevantRequestResponseList, void 0);
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        __privateSet(this, _relevantRequestResponseList, arguments[1]);
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.match' });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        const p = await this.matchAll(request, options);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        var _a, _b;
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== 'GET' && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === 'string') {
            r = new Request(request)[kState];
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = new Response(
            (_b = (_a = response.body) == null ? void 0 : _a.source) != null ? _b : null
          );
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = 'immutable';
          responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.add' });
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.addAll' });
        requests = webidl.converters['sequence<RequestInfo>'](requests);
        const responsePromises = [];
        const requestList = [];
        for (const request of requests) {
          if (typeof request === 'string') {
            continue;
          }
          const r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {
            throw webidl.errors.exception({
              header: 'Cache.addAll',
              message: 'Expected http/s scheme when method is not GET.',
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = new Request(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: 'Cache.addAll',
              message: 'Expected http/s scheme.',
            });
          }
          r.initiator = 'fetch';
          r.destination = 'subresource';
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(
            fetching({
              request: r,
              dispatcher: getGlobalDispatcher(),
              processResponse(response) {
                if (
                  response.type === 'error' ||
                  response.status === 206 ||
                  response.status < 200 ||
                  response.status > 299
                ) {
                  responsePromise.reject(
                    webidl.errors.exception({
                      header: 'Cache.addAll',
                      message: 'Received an invalid status code or the request failed.',
                    })
                  );
                } else if (response.headersList.contains('vary')) {
                  const fieldValues = getFieldValues(response.headersList.get('vary'));
                  for (const fieldValue of fieldValues) {
                    if (fieldValue === '*') {
                      responsePromise.reject(
                        webidl.errors.exception({
                          header: 'Cache.addAll',
                          message: 'invalid vary field value',
                        })
                      );
                      for (const controller of fetchControllers) {
                        controller.abort();
                      }
                      return;
                    }
                  }
                }
              },
              processResponseEndOfBody(response) {
                if (response.aborted) {
                  responsePromise.reject(new DOMException('aborted', 'AbortError'));
                  return;
                }
                responsePromise.resolve(response);
              },
            })
          );
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: 'put',
            request: requestList[index],
            response,
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _batchCacheOperations, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: 'Cache.put' });
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {
          throw webidl.errors.exception({
            header: 'Cache.put',
            message: 'Expected an http/s scheme when method is not GET',
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: 'Cache.put',
            message: 'Got 206 status',
          });
        }
        if (innerResponse.headersList.contains('vary')) {
          const fieldValues = getFieldValues(innerResponse.headersList.get('vary'));
          for (const fieldValue of fieldValues) {
            if (fieldValue === '*') {
              throw webidl.errors.exception({
                header: 'Cache.put',
                message: 'Got * vary field value',
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: 'Cache.put',
            message: 'Response body is locked or disturbed',
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: 'put',
          request: innerRequest,
          response: clonedResponse,
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _batchCacheOperations, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.delete' });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== 'GET' && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === 'string');
          r = new Request(request)[kState];
        }
        const operations = [];
        const operation = {
          type: 'delete',
          request: r,
          options,
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = __privateMethod(this, _batchCacheOperations, batchCacheOperations_fn).call(
            this,
            operations
          );
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!(requestResponses == null ? void 0 : requestResponses.length));
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== 'GET' && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === 'string') {
            r = new Request(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = new Request('https://a');
            requestObject[kState] = request2;
            requestObject[kHeaders][kHeadersList] = request2.headersList;
            requestObject[kHeaders][kGuard] = 'immutable';
            requestObject[kRealm] = request2.client;
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
    };
    var Cache = _Cache;
    _relevantRequestResponseList = new WeakMap();
    _batchCacheOperations = new WeakSet();
    batchCacheOperations_fn = function (operations) {
      const cache = __privateGet(this, _relevantRequestResponseList);
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== 'delete' && operation.type !== 'put') {
            throw webidl.errors.exception({
              header: 'Cache.#batchCacheOperations',
              message: 'operation type does not match "delete" or "put"',
            });
          }
          if (operation.type === 'delete' && operation.response != null) {
            throw webidl.errors.exception({
              header: 'Cache.#batchCacheOperations',
              message: 'delete operation should not have an associated response',
            });
          }
          if (
            __privateMethod(this, _queryCache, queryCache_fn).call(
              this,
              operation.request,
              operation.options,
              addedItems
            ).length
          ) {
            throw new DOMException('???', 'InvalidStateError');
          }
          let requestResponses;
          if (operation.type === 'delete') {
            requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(
              this,
              operation.request,
              operation.options
            );
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === 'put') {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: 'Cache.#batchCacheOperations',
                message: 'put operation should have an associated response',
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: 'Cache.#batchCacheOperations',
                message: 'expected http or https scheme',
              });
            }
            if (r.method !== 'GET') {
              throw webidl.errors.exception({
                header: 'Cache.#batchCacheOperations',
                message: 'not get method',
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: 'Cache.#batchCacheOperations',
                message: 'options must not be defined',
              });
            }
            requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        __privateGet(this, _relevantRequestResponseList).length = 0;
        __privateSet(this, _relevantRequestResponseList, backupCache);
        throw e;
      }
    };
    _queryCache = new WeakSet();
    queryCache_fn = function (requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage != null ? targetStorage : __privateGet(this, _relevantRequestResponseList);
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (
          __privateMethod(this, _requestMatchesCachedItem, requestMatchesCachedItem_fn).call(
            this,
            requestQuery,
            cachedRequest,
            cachedResponse,
            options
          )
        ) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    };
    _requestMatchesCachedItem = new WeakSet();
    requestMatchesCachedItem_fn = function (requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options == null ? void 0 : options.ignoreSearch) {
        cachedURL.search = '';
        queryURL.search = '';
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (
        response == null ||
        (options == null ? void 0 : options.ignoreVary) ||
        !response.headersList.contains('vary')
      ) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get('vary'));
      for (const fieldValue of fieldValues) {
        if (fieldValue === '*') {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    };
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: 'Cache',
        configurable: true,
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty,
    });
    var cacheQueryOptionConverters = [
      {
        key: 'ignoreSearch',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: 'ignoreMethod',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: 'ignoreVary',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: 'cacheName',
        converter: webidl.converters.DOMString,
      },
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response);
    webidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(webidl.converters.RequestInfo);
    module2.exports = {
      Cache,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cache/cachestorage.js'(exports, module2) {
    'use strict';
    var { kConstruct } = require_symbols4();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util2();
    var _caches;
    var _CacheStorage = class {
      constructor() {
        __privateAdd(this, _caches, /* @__PURE__ */ new Map());
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.match' });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (__privateGet(this, _caches).has(options.cacheName)) {
            const cacheList = __privateGet(this, _caches).get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of __privateGet(this, _caches).values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.has' });
        cacheName = webidl.converters.DOMString(cacheName);
        return __privateGet(this, _caches).has(cacheName);
      }
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.open' });
        cacheName = webidl.converters.DOMString(cacheName);
        if (__privateGet(this, _caches).has(cacheName)) {
          const cache2 = __privateGet(this, _caches).get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        __privateGet(this, _caches).set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.delete' });
        cacheName = webidl.converters.DOMString(cacheName);
        return __privateGet(this, _caches).delete(cacheName);
      }
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = __privateGet(this, _caches).keys();
        return [...keys];
      }
    };
    var CacheStorage = _CacheStorage;
    _caches = new WeakMap();
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: 'CacheStorage',
        configurable: true,
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty,
    });
    module2.exports = {
      CacheStorage,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cookies/constants.js
var require_constants3 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cookies/constants.js'(exports, module2) {
    'use strict';
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cookies/util.js
var require_util7 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cookies/util.js'(exports, module2) {
    'use strict';
    var assert = require('assert');
    var { kHeadersList } = require_symbols();
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || code >= 10 || code <= 31 || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);
        if (
          code <= 32 ||
          code > 127 ||
          char === '(' ||
          char === ')' ||
          char === '>' ||
          char === '<' ||
          char === '@' ||
          char === ',' ||
          char === ';' ||
          char === ':' ||
          char === '\\' ||
          char === '"' ||
          char === '/' ||
          char === '[' ||
          char === ']' ||
          char === '?' ||
          char === '=' ||
          char === '{' ||
          char === '}'
        ) {
          throw new Error('Invalid cookie name');
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error('Invalid header value');
        }
      }
    }
    function validateCookiePath(path) {
      for (const char of path) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ';') {
          throw new Error('Invalid cookie path');
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith('-') || domain.endsWith('.') || domain.endsWith('-')) {
        throw new Error('Invalid cookie domain');
      }
    }
    function toIMFDate(date) {
      if (typeof date === 'number') {
        date = new Date(date);
      }
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, '0');
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, '0');
      const minute = date.getUTCMinutes().toString().padStart(2, '0');
      const second = date.getUTCSeconds().toString().padStart(2, '0');
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error('Invalid cookie max-age');
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith('__Secure-')) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith('__Host-')) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = '/';
      }
      if (cookie.secure) {
        out.push('Secure');
      }
      if (cookie.httpOnly) {
        out.push('HttpOnly');
      }
      if (typeof cookie.maxAge === 'number') {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes('=')) {
          throw new Error('Invalid unparsed');
        }
        const [key, ...value] = part.split('=');
        out.push(`${key.trim()}=${value.join('=')}`);
      }
      return out.join('; ');
    }
    var kHeadersListNode;
    function getHeadersList(headers) {
      if (headers[kHeadersList]) {
        return headers[kHeadersList];
      }
      if (!kHeadersListNode) {
        kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
          (symbol) => symbol.description === 'headers list'
        );
        assert(kHeadersListNode, 'Headers cannot be parsed');
      }
      const headersList = headers[kHeadersListNode];
      assert(headersList);
      return headersList;
    }
    module2.exports = {
      isCTLExcludingHtab,
      stringify,
      getHeadersList,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cookies/parse.js
var require_parse2 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cookies/parse.js'(exports, module2) {
    'use strict';
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants3();
    var { isCTLExcludingHtab } = require_util7();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert = require('assert');
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = '';
      let unparsedAttributes = '';
      let name = '';
      let value = '';
      if (header.includes(';')) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(';', header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes('=')) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast('=', nameValuePair, position);
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return __spreadValues(
        {
          name,
          value,
        },
        parseUnparsedAttributes(unparsedAttributes)
      );
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      var _a;
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ';');
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = '';
      if (unparsedAttributes.includes(';')) {
        cookieAv = collectASequenceOfCodePointsFast(';', unparsedAttributes, { position: 0 });
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = '';
      }
      let attributeName = '';
      let attributeValue = '';
      if (cookieAv.includes('=')) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast('=', cookieAv, position);
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === 'expires') {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === 'max-age') {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === 'domain') {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === '.') {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === 'path') {
        let cookiePath = '';
        if (attributeValue.length === 0 || attributeValue[0] !== '/') {
          cookiePath = '/';
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === 'secure') {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === 'httponly') {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === 'samesite') {
        let enforcement = 'Default';
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes('none')) {
          enforcement = 'None';
        }
        if (attributeValueLowercase.includes('strict')) {
          enforcement = 'Strict';
        }
        if (attributeValueLowercase.includes('lax')) {
          enforcement = 'Lax';
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        (_a = cookieAttributeList.unparsed) != null ? _a : (cookieAttributeList.unparsed = []);
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/cookies/index.js'(exports, module2) {
    'use strict';
    var { parseSetCookie } = require_parse2();
    var { stringify, getHeadersList } = require_util7();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: 'getCookies' });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get('cookie');
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(';')) {
        const [name, ...value] = piece.split('=');
        out[name.trim()] = value.join('=');
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: 'deleteCookie' });
      webidl.brandCheck(headers, Headers, { strict: false });
      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(
        headers,
        __spreadValues(
          {
            name,
            value: '',
            expires: new Date(0),
          },
          attributes
        )
      );
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: 'getSetCookies' });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = getHeadersList(headers).cookies;
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: 'setCookie' });
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append('Set-Cookie', stringify(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: 'path',
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: 'domain',
        defaultValue: null,
      },
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: 'name',
      },
      {
        converter: webidl.converters.DOMString,
        key: 'value',
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === 'number') {
            return webidl.converters['unsigned long long'](value);
          }
          return new Date(value);
        }),
        key: 'expires',
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters['long long']),
        key: 'maxAge',
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: 'domain',
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: 'path',
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: 'secure',
        defaultValue: null,
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: 'httpOnly',
        defaultValue: null,
      },
      {
        converter: webidl.converters.USVString,
        key: 'sameSite',
        allowedValues: ['Strict', 'Lax', 'None'],
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: 'unparsed',
        defaultValue: [],
      },
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/constants.js
var require_constants4 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/constants.js'(exports, module2) {
    'use strict';
    var uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false,
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3,
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10,
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4,
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module2.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/symbols.js'(exports, module2) {
    'use strict';
    module2.exports = {
      kWebSocketURL: Symbol('url'),
      kReadyState: Symbol('ready state'),
      kController: Symbol('controller'),
      kResponse: Symbol('response'),
      kBinaryType: Symbol('binary type'),
      kSentClose: Symbol('sent close'),
      kReceivedClose: Symbol('received close'),
      kByteParser: Symbol('byte parser'),
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/events.js'(exports, module2) {
    'use strict';
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util2();
    var { MessagePort } = require('worker_threads');
    var _eventInit;
    var _MessageEvent = class extends Event {
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent constructor' });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit, void 0);
        __privateSet(this, _eventInit, eventInitDict);
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(__privateGet(this, _eventInit).ports)) {
          Object.freeze(__privateGet(this, _eventInit).ports);
        }
        return __privateGet(this, _eventInit).ports;
      }
      initMessageEvent(
        type,
        bubbles = false,
        cancelable = false,
        data = null,
        origin = '',
        lastEventId = '',
        source = null,
        ports = []
      ) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent.initMessageEvent' });
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports,
        });
      }
    };
    var MessageEvent = _MessageEvent;
    _eventInit = new WeakMap();
    var _eventInit2;
    var _CloseEvent = class extends Event {
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: 'CloseEvent constructor' });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit2, void 0);
        __privateSet(this, _eventInit2, eventInitDict);
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).reason;
      }
    };
    var CloseEvent = _CloseEvent;
    _eventInit2 = new WeakMap();
    var _eventInit3;
    var _ErrorEvent = class extends Event {
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: 'ErrorEvent constructor' });
        super(type, eventInitDict);
        __privateAdd(this, _eventInit3, void 0);
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict != null ? eventInitDict : {});
        __privateSet(this, _eventInit3, eventInitDict);
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).error;
      }
    };
    var ErrorEvent = _ErrorEvent;
    _eventInit3 = new WeakMap();
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: 'MessageEvent',
        configurable: true,
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty,
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: 'CloseEvent',
        configurable: true,
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty,
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: 'ErrorEvent',
        configurable: true,
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty,
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(webidl.converters.MessagePort);
    var eventInit = [
      {
        key: 'bubbles',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: 'cancelable',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: 'composed',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: 'data',
        converter: webidl.converters.any,
        defaultValue: null,
      },
      {
        key: 'origin',
        converter: webidl.converters.USVString,
        defaultValue: '',
      },
      {
        key: 'lastEventId',
        converter: webidl.converters.DOMString,
        defaultValue: '',
      },
      {
        key: 'source',
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null,
      },
      {
        key: 'ports',
        converter: webidl.converters['sequence<MessagePort>'],
        get defaultValue() {
          return [];
        },
      },
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: 'wasClean',
        converter: webidl.converters.boolean,
        defaultValue: false,
      },
      {
        key: 'code',
        converter: webidl.converters['unsigned short'],
        defaultValue: 0,
      },
      {
        key: 'reason',
        converter: webidl.converters.USVString,
        defaultValue: '',
      },
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: 'message',
        converter: webidl.converters.DOMString,
        defaultValue: '',
      },
      {
        key: 'filename',
        converter: webidl.converters.USVString,
        defaultValue: '',
      },
      {
        key: 'lineno',
        converter: webidl.converters['unsigned long'],
        defaultValue: 0,
      },
      {
        key: 'colno',
        converter: webidl.converters['unsigned long'],
        defaultValue: 0,
      },
      {
        key: 'error',
        converter: webidl.converters.any,
      },
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/util.js
var require_util8 = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/util.js'(exports, module2) {
    'use strict';
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
    var { states, opcodes } = require_constants4();
    var { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder('utf-8', { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.');
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === 'blob') {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent('message', ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent,
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (
          code < 33 ||
          code > 126 ||
          char === '(' ||
          char === ')' ||
          char === '<' ||
          char === '>' ||
          char === '@' ||
          char === ',' ||
          char === ';' ||
          char === ':' ||
          char === '\\' ||
          char === '"' ||
          char === '/' ||
          char === '[' ||
          char === ']' ||
          char === '?' ||
          char === '=' ||
          char === '{' ||
          char === '}' ||
          code === 32 ||
          code === 9
        ) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && code !== 1005 && code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if ((response == null ? void 0 : response.socket) && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent('error', ws, ErrorEvent, {
          error: new Error(reason),
        });
      }
    }
    module2.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/connection.js'(exports, module2) {
    'use strict';
    var diagnosticsChannel = require('diagnostics_channel');
    var { uid, states } = require_constants4();
    var { kReadyState, kSentClose, kByteParser, kReceivedClose } = require_symbols5();
    var { fireEvent, failWebsocketConnection } = require_util8();
    var { CloseEvent } = require_events();
    var { makeRequest } = require_request3();
    var { fetching } = require_fetch();
    var { Headers } = require_headers();
    var { getGlobalDispatcher } = require_global3();
    var { kHeadersList } = require_symbols();
    var channels = {};
    channels.open = diagnosticsChannel.channel('undici:websocket:open');
    channels.close = diagnosticsChannel.channel('undici:websocket:close');
    channels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error');
    var crypto;
    try {
      crypto = require('crypto');
    } catch {}
    function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
      var _a;
      const requestURL = url;
      requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:';
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: 'none',
        referrer: 'no-referrer',
        mode: 'websocket',
        credentials: 'include',
        cache: 'no-store',
        redirect: 'error',
      });
      if (options.headers) {
        const headersList = new Headers(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      const keyValue = crypto.randomBytes(16).toString('base64');
      request.headersList.append('sec-websocket-key', keyValue);
      request.headersList.append('sec-websocket-version', '13');
      for (const protocol of protocols) {
        request.headersList.append('sec-websocket-protocol', protocol);
      }
      const permessageDeflate = '';
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: (_a = options.dispatcher) != null ? _a : getGlobalDispatcher(),
        processResponse(response) {
          var _a2, _b;
          if (response.type === 'error' || response.status !== 101) {
            failWebsocketConnection(ws, 'Received network error or non-101 status code.');
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {
            failWebsocketConnection(ws, 'Server did not respond with sent protocols.');
            return;
          }
          if (((_a2 = response.headersList.get('Upgrade')) == null ? void 0 : _a2.toLowerCase()) !== 'websocket') {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (((_b = response.headersList.get('Connection')) == null ? void 0 : _b.toLowerCase()) !== 'upgrade') {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');
          const digest = crypto
            .createHash('sha1')
            .update(keyValue + uid)
            .digest('base64');
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');
            return;
          }
          const secExtension = response.headersList.get('Sec-WebSocket-Extensions');
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.');
            return;
          }
          const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');
          if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {
            failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');
            return;
          }
          response.socket.on('data', onSocketData);
          response.socket.on('close', onSocketClose);
          response.socket.on('error', onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension,
            });
          }
          onEstablish(response);
        },
      });
      return controller;
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      var _a;
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = '';
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = (_a = result.code) != null ? _a : 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent('close', ws, CloseEvent, {
        wasClean,
        code,
        reason,
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason,
        });
      }
    }
    function onSocketError(error) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error);
      }
      this.destroy();
    }
    module2.exports = {
      establishWebSocketConnection,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/frame.js'(exports, module2) {
    'use strict';
    var { maxUnsigned16Bit } = require_constants4();
    var crypto;
    try {
      crypto = require('crypto');
    } catch {}
    var WebsocketFrameSend = class {
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto.randomBytes(4);
      }
      createFrame(opcode) {
        var _a, _b;
        const bodyLength = (_b = (_a = this.frameData) == null ? void 0 : _a.byteLength) != null ? _b : 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i = 0; i < bodyLength; i++) {
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        }
        return buffer;
      }
    };
    module2.exports = {
      WebsocketFrameSend,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/receiver.js'(exports, module2) {
    'use strict';
    var { Writable } = require('stream');
    var diagnosticsChannel = require('diagnostics_channel');
    var { parserStates, opcodes, states, emptyBuffer } = require_constants4();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util8();
    var { WebsocketFrameSend } = require_frame();
    var channels = {};
    channels.ping = diagnosticsChannel.channel('undici:websocket:ping');
    channels.pong = diagnosticsChannel.channel('undici:websocket:pong');
    var _buffers, _byteOffset, _state, _info, _fragments;
    var ByteParser = class extends Writable {
      constructor(ws) {
        super();
        __privateAdd(this, _buffers, []);
        __privateAdd(this, _byteOffset, 0);
        __privateAdd(this, _state, parserStates.INFO);
        __privateAdd(this, _info, {});
        __privateAdd(this, _fragments, []);
        this.ws = ws;
      }
      _write(chunk, _, callback) {
        __privateGet(this, _buffers).push(chunk);
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) + chunk.length);
        this.run(callback);
      }
      run(callback) {
        var _a, _b;
        while (true) {
          if (__privateGet(this, _state) === parserStates.INFO) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).fin = (buffer[0] & 128) !== 0;
            __privateGet(this, _info).opcode = buffer[0] & 15;
            (_b = (_a = __privateGet(this, _info)).originalOpcode) != null
              ? _b
              : (_a.originalOpcode = __privateGet(this, _info).opcode);
            __privateGet(this, _info).fragmented =
              !__privateGet(this, _info).fin && __privateGet(this, _info).opcode !== opcodes.CONTINUATION;
            if (
              __privateGet(this, _info).fragmented &&
              __privateGet(this, _info).opcode !== opcodes.BINARY &&
              __privateGet(this, _info).opcode !== opcodes.TEXT
            ) {
              failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.');
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              __privateGet(this, _info).payloadLength = payloadLength;
              __privateSet(this, _state, parserStates.READ_DATA);
            } else if (payloadLength === 126) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_16);
            } else if (payloadLength === 127) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_64);
            }
            if (__privateGet(this, _info).fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.');
              return;
            } else if (
              (__privateGet(this, _info).opcode === opcodes.PING ||
                __privateGet(this, _info).opcode === opcodes.PONG ||
                __privateGet(this, _info).opcode === opcodes.CLOSE) &&
              payloadLength > 125
            ) {
              failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.');
              return;
            } else if (__privateGet(this, _info).opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.');
                return;
              }
              const body = this.consume(payloadLength);
              __privateGet(this, _info).closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(__privateGet(this, _info).closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
                  if (!err) {
                    this.ws[kSentClose] = true;
                  }
                });
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (__privateGet(this, _info).opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body,
                  });
                }
              }
              __privateSet(this, _state, parserStates.INFO);
              if (__privateGet(this, _byteOffset) > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (__privateGet(this, _info).opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body,
                });
              }
              if (__privateGet(this, _byteOffset) > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_16) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).payloadLength = buffer.readUInt16BE(0);
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_64) {
            if (__privateGet(this, _byteOffset) < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.');
              return;
            }
            const lower = buffer.readUInt32BE(4);
            __privateGet(this, _info).payloadLength = (upper << 8) + lower;
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.READ_DATA) {
            if (__privateGet(this, _byteOffset) < __privateGet(this, _info).payloadLength) {
              return callback();
            } else if (__privateGet(this, _byteOffset) >= __privateGet(this, _info).payloadLength) {
              const body = this.consume(__privateGet(this, _info).payloadLength);
              __privateGet(this, _fragments).push(body);
              if (
                !__privateGet(this, _info).fragmented ||
                (__privateGet(this, _info).fin && __privateGet(this, _info).opcode === opcodes.CONTINUATION)
              ) {
                const fullMessage = Buffer.concat(__privateGet(this, _fragments));
                websocketMessageReceived(this.ws, __privateGet(this, _info).originalOpcode, fullMessage);
                __privateSet(this, _info, {});
                __privateGet(this, _fragments).length = 0;
              }
              __privateSet(this, _state, parserStates.INFO);
            }
          }
          if (__privateGet(this, _byteOffset) > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      consume(n) {
        if (n > __privateGet(this, _byteOffset)) {
          return null;
        } else if (n === 0) {
          return emptyBuffer;
        }
        if (__privateGet(this, _buffers)[0].length === n) {
          __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - __privateGet(this, _buffers)[0].length);
          return __privateGet(this, _buffers).shift();
        }
        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;
        while (offset !== n) {
          const next = __privateGet(this, _buffers)[0];
          const { length } = next;
          if (length + offset === n) {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            __privateGet(this, _buffers)[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            offset += next.length;
          }
        }
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - n);
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder('utf-8', { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return __privateGet(this, _info).closeInfo;
      }
    };
    _buffers = new WeakMap();
    _byteOffset = new WeakMap();
    _state = new WeakMap();
    _info = new WeakMap();
    _fragments = new WeakMap();
    module2.exports = {
      ByteParser,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/lib/websocket/websocket.js'(exports, module2) {
    'use strict';
    var { webidl } = require_webidl();
    var { DOMException: DOMException2 } = require_constants();
    var { URLSerializer } = require_dataURL();
    var { getGlobalOrigin } = require_global2();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants4();
    var { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } =
      require_symbols5();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util8();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util2();
    var { getGlobalDispatcher } = require_global3();
    var { types } = require('util');
    var experimentalWarned = false;
    var _events, _bufferedAmount, _protocol, _extensions, _onConnectionEstablished, onConnectionEstablished_fn;
    var _WebSocket = class extends EventTarget {
      constructor(url, protocols = []) {
        super();
        __privateAdd(this, _onConnectionEstablished);
        __privateAdd(this, _events, {
          open: null,
          error: null,
          close: null,
          message: null,
        });
        __privateAdd(this, _bufferedAmount, 0);
        __privateAdd(this, _protocol, '');
        __privateAdd(this, _extensions, '');
        webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket constructor' });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning('WebSockets are experimental, expect them to change at any time.', {
            code: 'UNDICI-WS',
          });
        }
        const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols);
        url = webidl.converters.USVString(url);
        protocols = options.protocols;
        const baseURL = getGlobalOrigin();
        let urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          throw new DOMException2(e, 'SyntaxError');
        }
        if (urlRecord.protocol === 'http:') {
          urlRecord.protocol = 'ws:';
        } else if (urlRecord.protocol === 'https:') {
          urlRecord.protocol = 'wss:';
        }
        if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {
          throw new DOMException2(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, 'SyntaxError');
        }
        if (urlRecord.hash || urlRecord.href.endsWith('#')) {
          throw new DOMException2('Got fragment', 'SyntaxError');
        }
        if (typeof protocols === 'string') {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException2('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException2('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) =>
            __privateMethod(this, _onConnectionEstablished, onConnectionEstablished_fn).call(this, response),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kBinaryType] = 'blob';
      }
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        if (code !== void 0) {
          code = webidl.converters['unsigned short'](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException2('invalid code', 'InvalidAccessError');
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException2(`Reason must be less than 123 bytes; received ${reasonByteLength}`, 'SyntaxError');
          }
        }
        if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) {
        } else if (!isEstablished(this)) {
          failWebsocketConnection(this, 'Connection was closed before it was established.');
          this[kReadyState] = _WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, 'utf-8');
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = _WebSocket.CLOSING;
        }
      }
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === _WebSocket.CONNECTING) {
          throw new DOMException2('Sent before connected.', 'InvalidStateError');
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === 'string') {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
          });
        } else if (types.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + ab.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - ab.byteLength);
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
            socket.write(buffer, () => {
              __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _bufferedAmount);
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _extensions);
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _protocol);
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).open) {
          this.removeEventListener('open', __privateGet(this, _events).open);
        }
        if (typeof fn === 'function') {
          __privateGet(this, _events).open = fn;
          this.addEventListener('open', fn);
        } else {
          __privateGet(this, _events).open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).error) {
          this.removeEventListener('error', __privateGet(this, _events).error);
        }
        if (typeof fn === 'function') {
          __privateGet(this, _events).error = fn;
          this.addEventListener('error', fn);
        } else {
          __privateGet(this, _events).error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).close) {
          this.removeEventListener('close', __privateGet(this, _events).close);
        }
        if (typeof fn === 'function') {
          __privateGet(this, _events).close = fn;
          this.addEventListener('close', fn);
        } else {
          __privateGet(this, _events).close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).message) {
          this.removeEventListener('message', __privateGet(this, _events).message);
        }
        if (typeof fn === 'function') {
          __privateGet(this, _events).message = fn;
          this.addEventListener('message', fn);
        } else {
          __privateGet(this, _events).message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== 'blob' && type !== 'arraybuffer') {
          this[kBinaryType] = 'blob';
        } else {
          this[kBinaryType] = type;
        }
      }
    };
    var WebSocket = _WebSocket;
    _events = new WeakMap();
    _bufferedAmount = new WeakMap();
    _protocol = new WeakMap();
    _extensions = new WeakMap();
    _onConnectionEstablished = new WeakSet();
    onConnectionEstablished_fn = function (response) {
      this[kResponse] = response;
      const parser = new ByteParser(this);
      parser.on('drain', function onParserDrain() {
        this.ws[kResponse].socket.resume();
      });
      response.socket.ws = this;
      this[kByteParser] = parser;
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get('sec-websocket-extensions');
      if (extensions !== null) {
        __privateSet(this, _extensions, extensions);
      }
      const protocol = response.headersList.get('sec-websocket-protocol');
      if (protocol !== null) {
        __privateSet(this, _protocol, protocol);
      }
      fireEvent('open', this);
    };
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: 'WebSocket',
        writable: false,
        enumerable: false,
        configurable: true,
      },
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
    });
    webidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(webidl.converters.DOMString);
    webidl.converters['DOMString or sequence<DOMString>'] = function (V) {
      if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {
        return webidl.converters['sequence<DOMString>'](V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: 'protocols',
        converter: webidl.converters['DOMString or sequence<DOMString>'],
        get defaultValue() {
          return [];
        },
      },
      {
        key: 'dispatcher',
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        },
      },
      {
        key: 'headers',
        converter: webidl.nullableConverter(webidl.converters.HeadersInit),
      },
    ]);
    webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {
      if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) };
    };
    webidl.converters.WebSocketSendData = function (V) {
      if (webidl.util.Type(V) === 'Object') {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket,
    };
  },
});

// node_modules/.pnpm/undici@5.27.0/node_modules/undici/index.js
var require_undici = __commonJS({
  'node_modules/.pnpm/undici@5.27.0/node_modules/undici/index.js'(exports, module2) {
    'use strict';
    var Client = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var util = require_util2();
    var { InvalidArgumentError } = errors;
    var api = require_api2();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global3();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      require('crypto');
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === 'function') {
          handler = opts;
          opts = null;
        }
        if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {
          throw new InvalidArgumentError('invalid url');
        }
        if (opts != null && typeof opts !== 'object') {
          throw new InvalidArgumentError('invalid opts');
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== 'string') {
            throw new InvalidArgumentError('invalid opts.path');
          }
          let path = opts.path;
          if (!opts.path.startsWith('/')) {
            path = `/${path}`;
          }
          url = new URL(util.parseOrigin(url).origin + path);
        } else {
          if (!opts) {
            opts = typeof url === 'object' ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?');
        }
        return fn.call(
          dispatcher,
          __spreadProps(__spreadValues({}, opts), {
            origin: url.origin,
            path: url.search ? `${url.pathname}${url.search}` : url.pathname,
            method: opts.method || (opts.body ? 'PUT' : 'GET'),
          }),
          handler
        );
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util.nodeMajor > 16 || (util.nodeMajor === 16 && util.nodeMinor >= 8)) {
      let fetchImpl = null;
      module2.exports.fetch = async function fetch(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === 'object') {
            Error.captureStackTrace(err, this);
          }
          throw err;
        }
      };
      module2.exports.Headers = require_headers().Headers;
      module2.exports.Response = require_response2().Response;
      module2.exports.Request = require_request3().Request;
      module2.exports.FormData = require_formdata().FormData;
      module2.exports.File = require_file().File;
      module2.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global2();
      module2.exports.setGlobalOrigin = setGlobalOrigin;
      module2.exports.getGlobalOrigin = getGlobalOrigin;
      const { CacheStorage } = require_cachestorage();
      const { kConstruct } = require_symbols4();
      module2.exports.caches = new CacheStorage(kConstruct);
    }
    if (util.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module2.exports.deleteCookie = deleteCookie;
      module2.exports.getCookies = getCookies;
      module2.exports.getSetCookies = getSetCookies;
      module2.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module2.exports.parseMIMEType = parseMIMEType;
      module2.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = require_websocket();
      module2.exports.WebSocket = WebSocket;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  },
});

// node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/index.js
var require_lib2 = __commonJS({
  'node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/index.js'(exports) {
    'use strict';
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports && exports.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, 'default', { enumerable: true, value: v });
          }
        : function (o, v) {
            o['default'] = v;
          });
    var __importStar =
      (exports && exports.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __awaiter =
      (exports && exports.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator['throw'](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.HttpClient =
      exports.isHttps =
      exports.HttpClientResponse =
      exports.HttpClientError =
      exports.getProxyUrl =
      exports.MediaTypes =
      exports.Headers =
      exports.HttpCodes =
        void 0;
    var http = __importStar(require('http'));
    var https2 = __importStar(require('https'));
    var pm = __importStar(require_proxy());
    var tunnel = __importStar(require_tunnel2());
    var undici_1 = require_undici();
    var HttpCodes;
    (function (HttpCodes2) {
      HttpCodes2[(HttpCodes2['OK'] = 200)] = 'OK';
      HttpCodes2[(HttpCodes2['MultipleChoices'] = 300)] = 'MultipleChoices';
      HttpCodes2[(HttpCodes2['MovedPermanently'] = 301)] = 'MovedPermanently';
      HttpCodes2[(HttpCodes2['ResourceMoved'] = 302)] = 'ResourceMoved';
      HttpCodes2[(HttpCodes2['SeeOther'] = 303)] = 'SeeOther';
      HttpCodes2[(HttpCodes2['NotModified'] = 304)] = 'NotModified';
      HttpCodes2[(HttpCodes2['UseProxy'] = 305)] = 'UseProxy';
      HttpCodes2[(HttpCodes2['SwitchProxy'] = 306)] = 'SwitchProxy';
      HttpCodes2[(HttpCodes2['TemporaryRedirect'] = 307)] = 'TemporaryRedirect';
      HttpCodes2[(HttpCodes2['PermanentRedirect'] = 308)] = 'PermanentRedirect';
      HttpCodes2[(HttpCodes2['BadRequest'] = 400)] = 'BadRequest';
      HttpCodes2[(HttpCodes2['Unauthorized'] = 401)] = 'Unauthorized';
      HttpCodes2[(HttpCodes2['PaymentRequired'] = 402)] = 'PaymentRequired';
      HttpCodes2[(HttpCodes2['Forbidden'] = 403)] = 'Forbidden';
      HttpCodes2[(HttpCodes2['NotFound'] = 404)] = 'NotFound';
      HttpCodes2[(HttpCodes2['MethodNotAllowed'] = 405)] = 'MethodNotAllowed';
      HttpCodes2[(HttpCodes2['NotAcceptable'] = 406)] = 'NotAcceptable';
      HttpCodes2[(HttpCodes2['ProxyAuthenticationRequired'] = 407)] = 'ProxyAuthenticationRequired';
      HttpCodes2[(HttpCodes2['RequestTimeout'] = 408)] = 'RequestTimeout';
      HttpCodes2[(HttpCodes2['Conflict'] = 409)] = 'Conflict';
      HttpCodes2[(HttpCodes2['Gone'] = 410)] = 'Gone';
      HttpCodes2[(HttpCodes2['TooManyRequests'] = 429)] = 'TooManyRequests';
      HttpCodes2[(HttpCodes2['InternalServerError'] = 500)] = 'InternalServerError';
      HttpCodes2[(HttpCodes2['NotImplemented'] = 501)] = 'NotImplemented';
      HttpCodes2[(HttpCodes2['BadGateway'] = 502)] = 'BadGateway';
      HttpCodes2[(HttpCodes2['ServiceUnavailable'] = 503)] = 'ServiceUnavailable';
      HttpCodes2[(HttpCodes2['GatewayTimeout'] = 504)] = 'GatewayTimeout';
    })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
    var Headers;
    (function (Headers2) {
      Headers2['Accept'] = 'accept';
      Headers2['ContentType'] = 'content-type';
    })(Headers || (exports.Headers = Headers = {}));
    var MediaTypes;
    (function (MediaTypes2) {
      MediaTypes2['ApplicationJson'] = 'application/json';
    })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : '';
    }
    exports.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect,
    ];
    var HttpResponseRetryCodes = [HttpCodes.BadGateway, HttpCodes.ServiceUnavailable, HttpCodes.GatewayTimeout];
    var RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
      }
    };
    exports.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) =>
            __awaiter(this, void 0, void 0, function* () {
              let output = Buffer.alloc(0);
              this.message.on('data', (chunk) => {
                output = Buffer.concat([output, chunk]);
              });
              this.message.on('end', () => {
                resolve(output.toString());
              });
            })
          );
        });
      }
      readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) =>
            __awaiter(this, void 0, void 0, function* () {
              const chunks = [];
              this.message.on('data', (chunk) => {
                chunks.push(chunk);
              });
              this.message.on('end', () => {
                resolve(Buffer.concat(chunks));
              });
            })
          );
        });
      }
    };
    exports.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === 'https:';
    }
    exports.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.Accept,
            MediaTypes.ApplicationJson
          );
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.Accept,
            MediaTypes.ApplicationJson
          );
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.ContentType,
            MediaTypes.ApplicationJson
          );
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.Accept,
            MediaTypes.ApplicationJson
          );
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.ContentType,
            MediaTypes.ApplicationJson
          );
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.Accept,
            MediaTypes.ApplicationJson
          );
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(
            additionalHeaders,
            Headers.ContentType,
            MediaTypes.ApplicationJson
          );
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error('Client has already been disposed.');
          }
          const parsedUrl = new URL(requestUrl);
          let info = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (
              response.message.statusCode &&
              HttpRedirectCodes.includes(response.message.statusCode) &&
              this._allowRedirects &&
              redirectsRemaining > 0
            ) {
              const redirectUrl = response.message.headers['location'];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (
                parsedUrl.protocol === 'https:' &&
                parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                !this._allowRedirectDowngrade
              ) {
                throw new Error(
                  'Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.'
                );
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === 'authorization') {
                    delete headers[header];
                  }
                }
              }
              info = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error('Unknown error'));
              } else {
                resolve(res);
              }
            }
            this.requestRawWithCallback(info, data, callbackForResult);
          });
        });
      }
      requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
          if (!info.options.headers) {
            info.options.headers = {};
          }
          info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info.httpModule.request(info.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        });
        let socket;
        req.on('socket', (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
          handleResult(err);
        });
        if (data && typeof data === 'string') {
          req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
          data.on('close', function () {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (!useProxy) {
          return;
        }
        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https2 : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
        info.options.path = (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info.options);
          }
        }
        return info;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(
              Object.assign(
                {},
                (proxyUrl.username || proxyUrl.password) && {
                  proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`,
                }
              ),
              { host: proxyUrl.hostname, port: proxyUrl.port }
            ),
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === 'https:';
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (this._keepAlive && !agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https2.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (!agent) {
          agent = usingSsl ? https2.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false,
          });
        }
        return agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive) {
          proxyAgent = this._proxyAgentDispatcher;
        }
        if (proxyAgent) {
          return proxyAgent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        proxyAgent = new undici_1.ProxyAgent(
          Object.assign(
            { uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 },
            (proxyUrl.username || proxyUrl.password) && {
              token: `${proxyUrl.username}:${proxyUrl.password}`,
            }
          )
        );
        this._proxyAgentDispatcher = proxyAgent;
        if (usingSsl && this._ignoreSslError) {
          proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
            rejectUnauthorized: false,
          });
        }
        return proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve) => setTimeout(() => resolve(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) =>
            __awaiter(this, void 0, void 0, function* () {
              const statusCode = res.message.statusCode || 0;
              const response = {
                statusCode,
                result: null,
                headers: {},
              };
              if (statusCode === HttpCodes.NotFound) {
                resolve(response);
              }
              function dateTimeDeserializer(key, value) {
                if (typeof value === 'string') {
                  const a = new Date(value);
                  if (!isNaN(a.valueOf())) {
                    return a;
                  }
                }
                return value;
              }
              let obj;
              let contents;
              try {
                contents = yield res.readBody();
                if (contents && contents.length > 0) {
                  if (options && options.deserializeDates) {
                    obj = JSON.parse(contents, dateTimeDeserializer);
                  } else {
                    obj = JSON.parse(contents);
                  }
                  response.result = obj;
                }
                response.headers = res.message.headers;
              } catch (err) {}
              if (statusCode > 299) {
                let msg;
                if (obj && obj.message) {
                  msg = obj.message;
                } else if (contents && contents.length > 0) {
                  msg = contents;
                } else {
                  msg = `Failed request: (${statusCode})`;
                }
                const err = new HttpClientError(msg, statusCode);
                err.result = response.result;
                reject(err);
              } else {
                resolve(response);
              }
            })
          );
        });
      }
    };
    exports.HttpClient = HttpClient;
    var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
  },
});

// node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  'node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/auth.js'(exports) {
    'use strict';
    var __awaiter =
      (exports && exports.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator['throw'](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.PersonalAccessTokenCredentialHandler =
      exports.BearerCredentialHandler =
      exports.BasicCredentialHandler =
        void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString(
          'base64'
        )}`;
      }
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error('not implemented');
        });
      }
    };
    exports.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
      }
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error('not implemented');
        });
      }
    };
    exports.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
      }
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error('not implemented');
        });
      }
    };
    exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  },
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  'node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/oidc-utils.js'(exports) {
    'use strict';
    var __awaiter =
      (exports && exports.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator['throw'](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.OidcClient = void 0;
    var http_client_1 = require_lib2();
    var auth_1 = require_auth();
    var core_1 = require_core2();
    var OidcClient = class {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry,
        };
        return new http_client_1.HttpClient(
          'actions/oidc-client',
          [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())],
          requestOptions
        );
      }
      static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
          throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
          throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const httpclient = OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error('Response json body do not have ID Token field');
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let id_token_url = OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            core_1.debug(`ID token url is ${id_token_url}`);
            const id_token = yield OidcClient.getCall(id_token_url);
            core_1.setSecret(id_token);
            return id_token;
          } catch (error) {
            throw new Error(`Error message: ${error.message}`);
          }
        });
      }
    };
    exports.OidcClient = OidcClient;
  },
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  'node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/summary.js'(exports) {
    'use strict';
    var __awaiter =
      (exports && exports.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator['throw'](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
    var os_1 = require('os');
    var fs_1 = require('fs');
    var { access, appendFile, writeFile } = fs_1.promises;
    exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
    exports.SUMMARY_DOCS_URL =
      'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
    var Summary = class {
      constructor() {
        this._buffer = '';
      }
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(
              `Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`
            );
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(
              `Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`
            );
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
          .map(([key, value]) => ` ${key}="${value}"`)
          .join('');
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
          return this.emptyBuffer();
        });
      }
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      stringify() {
        return this._buffer;
      }
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      emptyBuffer() {
        this._buffer = '';
        return this;
      }
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
      }
      addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map((item) => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      addTable(rows) {
        const tableBody = rows
          .map((row) => {
            const cells = row
              .map((cell) => {
                if (typeof cell === 'string') {
                  return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
                return this.wrap(tag, data, attrs);
              })
              .join('');
            return this.wrap('tr', cells);
          })
          .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
      }
      addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
      }
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag) ? tag : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
      }
      addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
      }
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
      }
      addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports.markdownSummary = _summary;
    exports.summary = _summary;
  },
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  'node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/path-utils.js'(exports) {
    'use strict';
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            Object.defineProperty(o, k2, {
              enumerable: true,
              get: function () {
                return m[k];
              },
            });
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports && exports.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, 'default', { enumerable: true, value: v });
          }
        : function (o, v) {
            o['default'] = v;
          });
    var __importStar =
      (exports && exports.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== 'default' && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
    var path = __importStar(require('path'));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, '/');
    }
    exports.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, '\\');
    }
    exports.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path.sep);
    }
    exports.toPlatformPath = toPlatformPath;
  },
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/core.js
var require_core2 = __commonJS({
  'node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/core.js'(exports) {
    'use strict';
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            Object.defineProperty(o, k2, {
              enumerable: true,
              get: function () {
                return m[k];
              },
            });
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports && exports.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, 'default', { enumerable: true, value: v });
          }
        : function (o, v) {
            o['default'] = v;
          });
    var __importStar =
      (exports && exports.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== 'default' && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __awaiter =
      (exports && exports.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator['throw'](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.getIDToken =
      exports.getState =
      exports.saveState =
      exports.group =
      exports.endGroup =
      exports.startGroup =
      exports.info =
      exports.notice =
      exports.warning =
      exports.error =
      exports.debug =
      exports.isDebug =
      exports.setFailed =
      exports.setCommandEcho =
      exports.setOutput =
      exports.getBooleanInput =
      exports.getMultilineInput =
      exports.getInput =
      exports.addPath =
      exports.setSecret =
      exports.exportVariable =
      exports.ExitCode =
        void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils2();
    var os = __importStar(require('os'));
    var path = __importStar(require('path'));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function (ExitCode2) {
      ExitCode2[(ExitCode2['Success'] = 0)] = 'Success';
      ExitCode2[(ExitCode2['Failure'] = 1)] = 'Failure';
    })((ExitCode = exports.ExitCode || (exports.ExitCode = {})));
    function exportVariable(name, val) {
      const convertedVal = utils_1.toCommandValue(val);
      process.env[name] = convertedVal;
      const filePath = process.env['GITHUB_ENV'] || '';
      if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
      }
      command_1.issueCommand('set-env', { name }, convertedVal);
    }
    exports.exportVariable = exportVariable;
    function setSecret2(secret) {
      command_1.issueCommand('add-mask', {}, secret);
    }
    exports.setSecret = setSecret2;
    function addPath(inputPath) {
      const filePath = process.env['GITHUB_PATH'] || '';
      if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
      } else {
        command_1.issueCommand('add-path', {}, inputPath);
      }
      process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
    }
    exports.addPath = addPath;
    function getInput2(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports.getInput = getInput2;
    function getMultilineInput(name, options) {
      const inputs = getInput2(name, options)
        .split('\n')
        .filter((x) => x !== '');
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports.getMultilineInput = getMultilineInput;
    function getBooleanInput(name, options) {
      const trueValue = ['true', 'True', 'TRUE'];
      const falseValue = ['false', 'False', 'FALSE'];
      const val = getInput2(name, options);
      if (trueValue.includes(val)) return true;
      if (falseValue.includes(val)) return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports.getBooleanInput = getBooleanInput;
    function setOutput2(name, value) {
      const filePath = process.env['GITHUB_OUTPUT'] || '';
      if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
      }
      process.stdout.write(os.EOL);
      command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
    }
    exports.setOutput = setOutput2;
    function setCommandEcho(enabled) {
      command_1.issue('echo', enabled ? 'on' : 'off');
    }
    exports.setCommandEcho = setCommandEcho;
    function setFailed2(message) {
      process.exitCode = ExitCode.Failure;
      error(message);
    }
    exports.setFailed = setFailed2;
    function isDebug() {
      return process.env['RUNNER_DEBUG'] === '1';
    }
    exports.isDebug = isDebug;
    function debug(message) {
      command_1.issueCommand('debug', {}, message);
    }
    exports.debug = debug;
    function error(message, properties = {}) {
      command_1.issueCommand(
        'error',
        utils_1.toCommandProperties(properties),
        message instanceof Error ? message.toString() : message
      );
    }
    exports.error = error;
    function warning(message, properties = {}) {
      command_1.issueCommand(
        'warning',
        utils_1.toCommandProperties(properties),
        message instanceof Error ? message.toString() : message
      );
    }
    exports.warning = warning;
    function notice(message, properties = {}) {
      command_1.issueCommand(
        'notice',
        utils_1.toCommandProperties(properties),
        message instanceof Error ? message.toString() : message
      );
    }
    exports.notice = notice;
    function info(message) {
      process.stdout.write(message + os.EOL);
    }
    exports.info = info;
    function startGroup(name) {
      command_1.issue('group', name);
    }
    exports.startGroup = startGroup;
    function endGroup() {
      command_1.issue('endgroup');
    }
    exports.endGroup = endGroup;
    function group(name, fn) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports.group = group;
    function saveState(name, value) {
      const filePath = process.env['GITHUB_STATE'] || '';
      if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
      }
      command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
    }
    exports.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || '';
    }
    exports.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports, 'summary', {
      enumerable: true,
      get: function () {
        return summary_1.summary;
      },
    });
    var summary_2 = require_summary();
    Object.defineProperty(exports, 'markdownSummary', {
      enumerable: true,
      get: function () {
        return summary_2.markdownSummary;
      },
    });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports, 'toPosixPath', {
      enumerable: true,
      get: function () {
        return path_utils_1.toPosixPath;
      },
    });
    Object.defineProperty(exports, 'toWin32Path', {
      enumerable: true,
      get: function () {
        return path_utils_1.toWin32Path;
      },
    });
    Object.defineProperty(exports, 'toPlatformPath', {
      enumerable: true,
      get: function () {
        return path_utils_1.toPlatformPath;
      },
    });
  },
});

// src/index.ts
var import_global = __toESM(require_global());
var import_https = __toESM(require('https'));
var import_lambda = __toESM(require_lambda2());
var import_core = __toESM(require_core2());
var apiVersion = '2015-03-31';
var Props = /* @__PURE__ */ ((Props2) => {
  Props2['FunctionName'] = 'FunctionName';
  Props2['InvocationType'] = 'InvocationType';
  Props2['LogType'] = 'LogType';
  Props2['ClientContext'] = 'ClientContext';
  Props2['Payload'] = 'Payload';
  Props2['Qualifier'] = 'Qualifier';
  return Props2;
})(Props || {});
var setAWSCredentials = () => {
  const accessKeyId = (0, import_core.getInput)('AWS_ACCESS_KEY_ID' /* AWS_ACCESS_KEY_ID */);
  (0, import_core.setSecret)(accessKeyId);
  const secretAccessKey = (0, import_core.getInput)('AWS_SECRET_ACCESS_KEY' /* AWS_SECRET_ACCESS_KEY */);
  (0, import_core.setSecret)(secretAccessKey);
  const sessionToken = (0, import_core.getInput)('AWS_SESSION_TOKEN' /* AWS_SESSION_TOKEN */);
  if (sessionToken) {
    (0, import_core.setSecret)(sessionToken);
  }
  import_global.default.config.credentials = {
    accessKeyId,
    secretAccessKey,
    sessionToken,
  };
};
var getParams = () => {
  return Object.keys(Props).reduce((memo, prop) => {
    const value = (0, import_core.getInput)(prop);
    return value ? __spreadProps(__spreadValues({}, memo), { [prop]: value }) : memo;
  }, {});
};
var setAWSConfigOptions = () => {
  const httpTimeout = (0, import_core.getInput)('HTTP_TIMEOUT' /* HTTP_TIMEOUT */);
  if (httpTimeout) {
    import_global.default.config.httpOptions = { timeout: parseInt(httpTimeout, 10) };
  }
  const maxRetries = (0, import_core.getInput)('MAX_RETRIES' /* MAX_RETRIES */);
  if (maxRetries) {
    import_global.default.config.maxRetries = parseInt(maxRetries, 10);
  }
};
var main = async () => {
  try {
    setAWSCredentials();
    setAWSConfigOptions();
    const agent = new import_https.default.Agent({
      keepAlive: true,
      keepAliveMsecs: 500,
      timeout: 6e5,
      maxTotalSockets: 50,
    });
    const params = getParams();
    const lambda = new import_lambda.default({
      apiVersion,
      region: (0, import_core.getInput)('REGION'),
      httpOptions: { agent },
    });
    const response = await lambda.invoke(params).promise();
    (0, import_core.setOutput)('response', response);
    const succeedOnFailure =
      (0, import_core.getInput)('SUCCEED_ON_FUNCTION_FAILURE' /* SUCCEED_ON_FUNCTION_FAILURE */).toLowerCase() ===
      'true';
    if ('FunctionError' in response && !succeedOnFailure) {
      throw new Error('Lambda invocation failed! See outputs.response for more information.');
    }
  } catch (error) {
    (0, import_core.setFailed)(error instanceof Error ? error.message : JSON.stringify(error));
  }
};

// index.ts
main();
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
/*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
